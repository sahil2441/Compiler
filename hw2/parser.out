Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Unused terminals:

    DO
    RETURN
    STRINGCONSTANT
    NOTEQUALS
    INTEGERCONSTANT
    WHILE
    NEW
    DIV
    NULL
    TRUE
    MINUS
    MULT
    COMMENT
    GEQ
    LEQ
    LT
    CONTINUE
    PLUS
    DOT
    COLON
    GT
    FOR
    SPACE
    PLUSPLUS
    ASSIGN
    EQUALS
    ELSE
    INSCANINT
    OUTPRINT
    MINUSMINUS
    INSCANFLOAT
    IF
    AND
    FLOATCONSTANT
    FALSE
    BLOCKCOMMENT
    OR
    BREAK
    THIS
    NOT
    SUPER

Grammar

Rule 0     S' -> classdecl
Rule 1     classdecl -> CLASS IDENTIFIER LCURLY empty RCURLY
Rule 2     classdecl -> CLASS IDENTIFIER LCURLY class_body_decl RCURLY
Rule 3     classdecl -> CLASS IDENTIFIER EXTENDS IDENTIFIER LCURLY class_body_decl RCURLY
Rule 4     class_body_decl -> field_decl
Rule 5     class_body_decl -> method_decl
Rule 6     class_body_decl -> constructor_decl
Rule 7     field_decl -> modifier var_decl
Rule 8     modifier -> PUBLIC
Rule 9     modifier -> PRIVATE
Rule 10    modifier -> STATIC
Rule 11    modifier -> PUBLIC STATIC
Rule 12    modifier -> PRIVATE STATIC
Rule 13    modifier -> empty
Rule 14    var_decl -> type variables SEMICOLON
Rule 15    type -> INT
Rule 16    type -> FLOAT
Rule 17    type -> BOOLEAN
Rule 18    type -> IDENTIFIER
Rule 19    variables -> IDENTIFIER
Rule 20    variables -> IDENTIFIER LSQUARE RSQUARE
Rule 21    variables -> COMMA IDENTIFIER variables
Rule 22    variables -> COMMA IDENTIFIER LSQUARE RSQUARE variables
Rule 23    method_decl -> modifier type IDENTIFIER LPAREN empty RPAREN block
Rule 24    method_decl -> modifier VOID IDENTIFIER LPAREN empty RPAREN block
Rule 25    method_decl -> modifier VOID IDENTIFIER LPAREN formals RPAREN block
Rule 26    method_decl -> modifier type IDENTIFIER LPAREN formals RPAREN block
Rule 27    constructor_decl -> modifier IDENTIFIER LPAREN empty RPAREN block
Rule 28    constructor_decl -> modifier IDENTIFIER LPAREN formals RPAREN block
Rule 29    formals -> type variables
Rule 30    formals -> COMMA formals
Rule 31    block -> LCURLY empty RCURLY
Rule 32    empty -> <empty>

Terminals, with rules where they appear

AND                  : 
ASSIGN               : 
BLOCKCOMMENT         : 
BOOLEAN              : 17
BREAK                : 
CLASS                : 1 2 3
COLON                : 
COMMA                : 21 22 30
COMMENT              : 
CONTINUE             : 
DIV                  : 
DO                   : 
DOT                  : 
ELSE                 : 
EQUALS               : 
EXTENDS              : 3
FALSE                : 
FLOAT                : 16
FLOATCONSTANT        : 
FOR                  : 
GEQ                  : 
GT                   : 
IDENTIFIER           : 1 2 3 3 18 19 20 21 22 23 24 25 26 27 28
IF                   : 
INSCANFLOAT          : 
INSCANINT            : 
INT                  : 15
INTEGERCONSTANT      : 
LCURLY               : 1 2 3 31
LEQ                  : 
LPAREN               : 23 24 25 26 27 28
LSQUARE              : 20 22
LT                   : 
MINUS                : 
MINUSMINUS           : 
MULT                 : 
NEW                  : 
NOT                  : 
NOTEQUALS            : 
NULL                 : 
OR                   : 
OUTPRINT             : 
PLUS                 : 
PLUSPLUS             : 
PRIVATE              : 9 12
PUBLIC               : 8 11
RCURLY               : 1 2 3 31
RETURN               : 
RPAREN               : 23 24 25 26 27 28
RSQUARE              : 20 22
SEMICOLON            : 14
SPACE                : 
STATIC               : 10 11 12
STRINGCONSTANT       : 
SUPER                : 
THIS                 : 
TRUE                 : 
VOID                 : 24 25
WHILE                : 
error                : 

Nonterminals, with rules where they appear

block                : 23 24 25 26 27 28
class_body_decl      : 2 3
classdecl            : 0
constructor_decl     : 6
empty                : 1 13 23 24 27 31
field_decl           : 4
formals              : 25 26 28 30
method_decl          : 5
modifier             : 7 23 24 25 26 27 28
type                 : 14 23 26 29
var_decl             : 7
variables            : 14 21 22 29

Parsing method: LALR

state 0

    (0) S' -> . classdecl
    (1) classdecl -> . CLASS IDENTIFIER LCURLY empty RCURLY
    (2) classdecl -> . CLASS IDENTIFIER LCURLY class_body_decl RCURLY
    (3) classdecl -> . CLASS IDENTIFIER EXTENDS IDENTIFIER LCURLY class_body_decl RCURLY

    CLASS           shift and go to state 2

    classdecl                      shift and go to state 1

state 1

    (0) S' -> classdecl .



state 2

    (1) classdecl -> CLASS . IDENTIFIER LCURLY empty RCURLY
    (2) classdecl -> CLASS . IDENTIFIER LCURLY class_body_decl RCURLY
    (3) classdecl -> CLASS . IDENTIFIER EXTENDS IDENTIFIER LCURLY class_body_decl RCURLY

    IDENTIFIER      shift and go to state 3


state 3

    (1) classdecl -> CLASS IDENTIFIER . LCURLY empty RCURLY
    (2) classdecl -> CLASS IDENTIFIER . LCURLY class_body_decl RCURLY
    (3) classdecl -> CLASS IDENTIFIER . EXTENDS IDENTIFIER LCURLY class_body_decl RCURLY

    LCURLY          shift and go to state 4
    EXTENDS         shift and go to state 5


state 4

    (1) classdecl -> CLASS IDENTIFIER LCURLY . empty RCURLY
    (2) classdecl -> CLASS IDENTIFIER LCURLY . class_body_decl RCURLY
    (32) empty -> .
    (4) class_body_decl -> . field_decl
    (5) class_body_decl -> . method_decl
    (6) class_body_decl -> . constructor_decl
    (7) field_decl -> . modifier var_decl
    (23) method_decl -> . modifier type IDENTIFIER LPAREN empty RPAREN block
    (24) method_decl -> . modifier VOID IDENTIFIER LPAREN empty RPAREN block
    (25) method_decl -> . modifier VOID IDENTIFIER LPAREN formals RPAREN block
    (26) method_decl -> . modifier type IDENTIFIER LPAREN formals RPAREN block
    (27) constructor_decl -> . modifier IDENTIFIER LPAREN empty RPAREN block
    (28) constructor_decl -> . modifier IDENTIFIER LPAREN formals RPAREN block
    (8) modifier -> . PUBLIC
    (9) modifier -> . PRIVATE
    (10) modifier -> . STATIC
    (11) modifier -> . PUBLIC STATIC
    (12) modifier -> . PRIVATE STATIC
    (13) modifier -> . empty

    RCURLY          reduce using rule 32 (empty -> .)
    VOID            reduce using rule 32 (empty -> .)
    IDENTIFIER      reduce using rule 32 (empty -> .)
    INT             reduce using rule 32 (empty -> .)
    FLOAT           reduce using rule 32 (empty -> .)
    BOOLEAN         reduce using rule 32 (empty -> .)
    PUBLIC          shift and go to state 11
    PRIVATE         shift and go to state 12
    STATIC          shift and go to state 13

    class_body_decl                shift and go to state 7
    field_decl                     shift and go to state 8
    constructor_decl               shift and go to state 9
    method_decl                    shift and go to state 10
    modifier                       shift and go to state 6
    empty                          shift and go to state 14

state 5

    (3) classdecl -> CLASS IDENTIFIER EXTENDS . IDENTIFIER LCURLY class_body_decl RCURLY

    IDENTIFIER      shift and go to state 15


state 6

    (7) field_decl -> modifier . var_decl
    (23) method_decl -> modifier . type IDENTIFIER LPAREN empty RPAREN block
    (24) method_decl -> modifier . VOID IDENTIFIER LPAREN empty RPAREN block
    (25) method_decl -> modifier . VOID IDENTIFIER LPAREN formals RPAREN block
    (26) method_decl -> modifier . type IDENTIFIER LPAREN formals RPAREN block
    (27) constructor_decl -> modifier . IDENTIFIER LPAREN empty RPAREN block
    (28) constructor_decl -> modifier . IDENTIFIER LPAREN formals RPAREN block
    (14) var_decl -> . type variables SEMICOLON
    (15) type -> . INT
    (16) type -> . FLOAT
    (17) type -> . BOOLEAN
    (18) type -> . IDENTIFIER

    VOID            shift and go to state 17
    IDENTIFIER      shift and go to state 21
    INT             shift and go to state 16
    FLOAT           shift and go to state 18
    BOOLEAN         shift and go to state 20

    var_decl                       shift and go to state 19
    type                           shift and go to state 22

state 7

    (2) classdecl -> CLASS IDENTIFIER LCURLY class_body_decl . RCURLY

    RCURLY          shift and go to state 23


state 8

    (4) class_body_decl -> field_decl .

    RCURLY          reduce using rule 4 (class_body_decl -> field_decl .)


state 9

    (6) class_body_decl -> constructor_decl .

    RCURLY          reduce using rule 6 (class_body_decl -> constructor_decl .)


state 10

    (5) class_body_decl -> method_decl .

    RCURLY          reduce using rule 5 (class_body_decl -> method_decl .)


state 11

    (8) modifier -> PUBLIC .
    (11) modifier -> PUBLIC . STATIC

    VOID            reduce using rule 8 (modifier -> PUBLIC .)
    IDENTIFIER      reduce using rule 8 (modifier -> PUBLIC .)
    INT             reduce using rule 8 (modifier -> PUBLIC .)
    FLOAT           reduce using rule 8 (modifier -> PUBLIC .)
    BOOLEAN         reduce using rule 8 (modifier -> PUBLIC .)
    STATIC          shift and go to state 24


state 12

    (9) modifier -> PRIVATE .
    (12) modifier -> PRIVATE . STATIC

    VOID            reduce using rule 9 (modifier -> PRIVATE .)
    IDENTIFIER      reduce using rule 9 (modifier -> PRIVATE .)
    INT             reduce using rule 9 (modifier -> PRIVATE .)
    FLOAT           reduce using rule 9 (modifier -> PRIVATE .)
    BOOLEAN         reduce using rule 9 (modifier -> PRIVATE .)
    STATIC          shift and go to state 25


state 13

    (10) modifier -> STATIC .

    VOID            reduce using rule 10 (modifier -> STATIC .)
    IDENTIFIER      reduce using rule 10 (modifier -> STATIC .)
    INT             reduce using rule 10 (modifier -> STATIC .)
    FLOAT           reduce using rule 10 (modifier -> STATIC .)
    BOOLEAN         reduce using rule 10 (modifier -> STATIC .)


state 14

    (1) classdecl -> CLASS IDENTIFIER LCURLY empty . RCURLY
    (13) modifier -> empty .

    RCURLY          shift and go to state 26
    VOID            reduce using rule 13 (modifier -> empty .)
    IDENTIFIER      reduce using rule 13 (modifier -> empty .)
    INT             reduce using rule 13 (modifier -> empty .)
    FLOAT           reduce using rule 13 (modifier -> empty .)
    BOOLEAN         reduce using rule 13 (modifier -> empty .)


state 15

    (3) classdecl -> CLASS IDENTIFIER EXTENDS IDENTIFIER . LCURLY class_body_decl RCURLY

    LCURLY          shift and go to state 27


state 16

    (15) type -> INT .

    IDENTIFIER      reduce using rule 15 (type -> INT .)
    COMMA           reduce using rule 15 (type -> INT .)


state 17

    (24) method_decl -> modifier VOID . IDENTIFIER LPAREN empty RPAREN block
    (25) method_decl -> modifier VOID . IDENTIFIER LPAREN formals RPAREN block

    IDENTIFIER      shift and go to state 28


state 18

    (16) type -> FLOAT .

    IDENTIFIER      reduce using rule 16 (type -> FLOAT .)
    COMMA           reduce using rule 16 (type -> FLOAT .)


state 19

    (7) field_decl -> modifier var_decl .

    RCURLY          reduce using rule 7 (field_decl -> modifier var_decl .)


state 20

    (17) type -> BOOLEAN .

    IDENTIFIER      reduce using rule 17 (type -> BOOLEAN .)
    COMMA           reduce using rule 17 (type -> BOOLEAN .)


state 21

    (27) constructor_decl -> modifier IDENTIFIER . LPAREN empty RPAREN block
    (28) constructor_decl -> modifier IDENTIFIER . LPAREN formals RPAREN block
    (18) type -> IDENTIFIER .

    LPAREN          shift and go to state 29
    IDENTIFIER      reduce using rule 18 (type -> IDENTIFIER .)
    COMMA           reduce using rule 18 (type -> IDENTIFIER .)


state 22

    (23) method_decl -> modifier type . IDENTIFIER LPAREN empty RPAREN block
    (26) method_decl -> modifier type . IDENTIFIER LPAREN formals RPAREN block
    (14) var_decl -> type . variables SEMICOLON
    (19) variables -> . IDENTIFIER
    (20) variables -> . IDENTIFIER LSQUARE RSQUARE
    (21) variables -> . COMMA IDENTIFIER variables
    (22) variables -> . COMMA IDENTIFIER LSQUARE RSQUARE variables

    IDENTIFIER      shift and go to state 32
    COMMA           shift and go to state 31

    variables                      shift and go to state 30

state 23

    (2) classdecl -> CLASS IDENTIFIER LCURLY class_body_decl RCURLY .

    $end            reduce using rule 2 (classdecl -> CLASS IDENTIFIER LCURLY class_body_decl RCURLY .)


state 24

    (11) modifier -> PUBLIC STATIC .

    VOID            reduce using rule 11 (modifier -> PUBLIC STATIC .)
    IDENTIFIER      reduce using rule 11 (modifier -> PUBLIC STATIC .)
    INT             reduce using rule 11 (modifier -> PUBLIC STATIC .)
    FLOAT           reduce using rule 11 (modifier -> PUBLIC STATIC .)
    BOOLEAN         reduce using rule 11 (modifier -> PUBLIC STATIC .)


state 25

    (12) modifier -> PRIVATE STATIC .

    VOID            reduce using rule 12 (modifier -> PRIVATE STATIC .)
    IDENTIFIER      reduce using rule 12 (modifier -> PRIVATE STATIC .)
    INT             reduce using rule 12 (modifier -> PRIVATE STATIC .)
    FLOAT           reduce using rule 12 (modifier -> PRIVATE STATIC .)
    BOOLEAN         reduce using rule 12 (modifier -> PRIVATE STATIC .)


state 26

    (1) classdecl -> CLASS IDENTIFIER LCURLY empty RCURLY .

    $end            reduce using rule 1 (classdecl -> CLASS IDENTIFIER LCURLY empty RCURLY .)


state 27

    (3) classdecl -> CLASS IDENTIFIER EXTENDS IDENTIFIER LCURLY . class_body_decl RCURLY
    (4) class_body_decl -> . field_decl
    (5) class_body_decl -> . method_decl
    (6) class_body_decl -> . constructor_decl
    (7) field_decl -> . modifier var_decl
    (23) method_decl -> . modifier type IDENTIFIER LPAREN empty RPAREN block
    (24) method_decl -> . modifier VOID IDENTIFIER LPAREN empty RPAREN block
    (25) method_decl -> . modifier VOID IDENTIFIER LPAREN formals RPAREN block
    (26) method_decl -> . modifier type IDENTIFIER LPAREN formals RPAREN block
    (27) constructor_decl -> . modifier IDENTIFIER LPAREN empty RPAREN block
    (28) constructor_decl -> . modifier IDENTIFIER LPAREN formals RPAREN block
    (8) modifier -> . PUBLIC
    (9) modifier -> . PRIVATE
    (10) modifier -> . STATIC
    (11) modifier -> . PUBLIC STATIC
    (12) modifier -> . PRIVATE STATIC
    (13) modifier -> . empty
    (32) empty -> .

    PUBLIC          shift and go to state 11
    PRIVATE         shift and go to state 12
    STATIC          shift and go to state 13
    VOID            reduce using rule 32 (empty -> .)
    IDENTIFIER      reduce using rule 32 (empty -> .)
    INT             reduce using rule 32 (empty -> .)
    FLOAT           reduce using rule 32 (empty -> .)
    BOOLEAN         reduce using rule 32 (empty -> .)

    class_body_decl                shift and go to state 33
    field_decl                     shift and go to state 8
    constructor_decl               shift and go to state 9
    method_decl                    shift and go to state 10
    modifier                       shift and go to state 6
    empty                          shift and go to state 34

state 28

    (24) method_decl -> modifier VOID IDENTIFIER . LPAREN empty RPAREN block
    (25) method_decl -> modifier VOID IDENTIFIER . LPAREN formals RPAREN block

    LPAREN          shift and go to state 35


state 29

    (27) constructor_decl -> modifier IDENTIFIER LPAREN . empty RPAREN block
    (28) constructor_decl -> modifier IDENTIFIER LPAREN . formals RPAREN block
    (32) empty -> .
    (29) formals -> . type variables
    (30) formals -> . COMMA formals
    (15) type -> . INT
    (16) type -> . FLOAT
    (17) type -> . BOOLEAN
    (18) type -> . IDENTIFIER

    RPAREN          reduce using rule 32 (empty -> .)
    COMMA           shift and go to state 36
    INT             shift and go to state 16
    FLOAT           shift and go to state 18
    BOOLEAN         shift and go to state 20
    IDENTIFIER      shift and go to state 38

    empty                          shift and go to state 37
    type                           shift and go to state 39
    formals                        shift and go to state 40

state 30

    (14) var_decl -> type variables . SEMICOLON

    SEMICOLON       shift and go to state 41


state 31

    (21) variables -> COMMA . IDENTIFIER variables
    (22) variables -> COMMA . IDENTIFIER LSQUARE RSQUARE variables

    IDENTIFIER      shift and go to state 42


state 32

    (23) method_decl -> modifier type IDENTIFIER . LPAREN empty RPAREN block
    (26) method_decl -> modifier type IDENTIFIER . LPAREN formals RPAREN block
    (19) variables -> IDENTIFIER .
    (20) variables -> IDENTIFIER . LSQUARE RSQUARE

    LPAREN          shift and go to state 44
    SEMICOLON       reduce using rule 19 (variables -> IDENTIFIER .)
    LSQUARE         shift and go to state 43


state 33

    (3) classdecl -> CLASS IDENTIFIER EXTENDS IDENTIFIER LCURLY class_body_decl . RCURLY

    RCURLY          shift and go to state 45


state 34

    (13) modifier -> empty .

    VOID            reduce using rule 13 (modifier -> empty .)
    IDENTIFIER      reduce using rule 13 (modifier -> empty .)
    INT             reduce using rule 13 (modifier -> empty .)
    FLOAT           reduce using rule 13 (modifier -> empty .)
    BOOLEAN         reduce using rule 13 (modifier -> empty .)


state 35

    (24) method_decl -> modifier VOID IDENTIFIER LPAREN . empty RPAREN block
    (25) method_decl -> modifier VOID IDENTIFIER LPAREN . formals RPAREN block
    (32) empty -> .
    (29) formals -> . type variables
    (30) formals -> . COMMA formals
    (15) type -> . INT
    (16) type -> . FLOAT
    (17) type -> . BOOLEAN
    (18) type -> . IDENTIFIER

    RPAREN          reduce using rule 32 (empty -> .)
    COMMA           shift and go to state 36
    INT             shift and go to state 16
    FLOAT           shift and go to state 18
    BOOLEAN         shift and go to state 20
    IDENTIFIER      shift and go to state 38

    empty                          shift and go to state 46
    type                           shift and go to state 39
    formals                        shift and go to state 47

state 36

    (30) formals -> COMMA . formals
    (29) formals -> . type variables
    (30) formals -> . COMMA formals
    (15) type -> . INT
    (16) type -> . FLOAT
    (17) type -> . BOOLEAN
    (18) type -> . IDENTIFIER

    COMMA           shift and go to state 36
    INT             shift and go to state 16
    FLOAT           shift and go to state 18
    BOOLEAN         shift and go to state 20
    IDENTIFIER      shift and go to state 38

    type                           shift and go to state 39
    formals                        shift and go to state 48

state 37

    (27) constructor_decl -> modifier IDENTIFIER LPAREN empty . RPAREN block

    RPAREN          shift and go to state 49


state 38

    (18) type -> IDENTIFIER .

    IDENTIFIER      reduce using rule 18 (type -> IDENTIFIER .)
    COMMA           reduce using rule 18 (type -> IDENTIFIER .)


state 39

    (29) formals -> type . variables
    (19) variables -> . IDENTIFIER
    (20) variables -> . IDENTIFIER LSQUARE RSQUARE
    (21) variables -> . COMMA IDENTIFIER variables
    (22) variables -> . COMMA IDENTIFIER LSQUARE RSQUARE variables

    IDENTIFIER      shift and go to state 51
    COMMA           shift and go to state 31

    variables                      shift and go to state 50

state 40

    (28) constructor_decl -> modifier IDENTIFIER LPAREN formals . RPAREN block

    RPAREN          shift and go to state 52


state 41

    (14) var_decl -> type variables SEMICOLON .

    RCURLY          reduce using rule 14 (var_decl -> type variables SEMICOLON .)


state 42

    (21) variables -> COMMA IDENTIFIER . variables
    (22) variables -> COMMA IDENTIFIER . LSQUARE RSQUARE variables
    (19) variables -> . IDENTIFIER
    (20) variables -> . IDENTIFIER LSQUARE RSQUARE
    (21) variables -> . COMMA IDENTIFIER variables
    (22) variables -> . COMMA IDENTIFIER LSQUARE RSQUARE variables

    LSQUARE         shift and go to state 54
    IDENTIFIER      shift and go to state 51
    COMMA           shift and go to state 31

    variables                      shift and go to state 53

state 43

    (20) variables -> IDENTIFIER LSQUARE . RSQUARE

    RSQUARE         shift and go to state 55


state 44

    (23) method_decl -> modifier type IDENTIFIER LPAREN . empty RPAREN block
    (26) method_decl -> modifier type IDENTIFIER LPAREN . formals RPAREN block
    (32) empty -> .
    (29) formals -> . type variables
    (30) formals -> . COMMA formals
    (15) type -> . INT
    (16) type -> . FLOAT
    (17) type -> . BOOLEAN
    (18) type -> . IDENTIFIER

    RPAREN          reduce using rule 32 (empty -> .)
    COMMA           shift and go to state 36
    INT             shift and go to state 16
    FLOAT           shift and go to state 18
    BOOLEAN         shift and go to state 20
    IDENTIFIER      shift and go to state 38

    empty                          shift and go to state 56
    type                           shift and go to state 39
    formals                        shift and go to state 57

state 45

    (3) classdecl -> CLASS IDENTIFIER EXTENDS IDENTIFIER LCURLY class_body_decl RCURLY .

    $end            reduce using rule 3 (classdecl -> CLASS IDENTIFIER EXTENDS IDENTIFIER LCURLY class_body_decl RCURLY .)


state 46

    (24) method_decl -> modifier VOID IDENTIFIER LPAREN empty . RPAREN block

    RPAREN          shift and go to state 58


state 47

    (25) method_decl -> modifier VOID IDENTIFIER LPAREN formals . RPAREN block

    RPAREN          shift and go to state 59


state 48

    (30) formals -> COMMA formals .

    RPAREN          reduce using rule 30 (formals -> COMMA formals .)


state 49

    (27) constructor_decl -> modifier IDENTIFIER LPAREN empty RPAREN . block
    (31) block -> . LCURLY empty RCURLY

    LCURLY          shift and go to state 60

    block                          shift and go to state 61

state 50

    (29) formals -> type variables .

    RPAREN          reduce using rule 29 (formals -> type variables .)


state 51

    (19) variables -> IDENTIFIER .
    (20) variables -> IDENTIFIER . LSQUARE RSQUARE

    SEMICOLON       reduce using rule 19 (variables -> IDENTIFIER .)
    RPAREN          reduce using rule 19 (variables -> IDENTIFIER .)
    LSQUARE         shift and go to state 43


state 52

    (28) constructor_decl -> modifier IDENTIFIER LPAREN formals RPAREN . block
    (31) block -> . LCURLY empty RCURLY

    LCURLY          shift and go to state 60

    block                          shift and go to state 62

state 53

    (21) variables -> COMMA IDENTIFIER variables .

    SEMICOLON       reduce using rule 21 (variables -> COMMA IDENTIFIER variables .)
    RPAREN          reduce using rule 21 (variables -> COMMA IDENTIFIER variables .)


state 54

    (22) variables -> COMMA IDENTIFIER LSQUARE . RSQUARE variables

    RSQUARE         shift and go to state 63


state 55

    (20) variables -> IDENTIFIER LSQUARE RSQUARE .

    SEMICOLON       reduce using rule 20 (variables -> IDENTIFIER LSQUARE RSQUARE .)
    RPAREN          reduce using rule 20 (variables -> IDENTIFIER LSQUARE RSQUARE .)


state 56

    (23) method_decl -> modifier type IDENTIFIER LPAREN empty . RPAREN block

    RPAREN          shift and go to state 64


state 57

    (26) method_decl -> modifier type IDENTIFIER LPAREN formals . RPAREN block

    RPAREN          shift and go to state 65


state 58

    (24) method_decl -> modifier VOID IDENTIFIER LPAREN empty RPAREN . block
    (31) block -> . LCURLY empty RCURLY

    LCURLY          shift and go to state 60

    block                          shift and go to state 66

state 59

    (25) method_decl -> modifier VOID IDENTIFIER LPAREN formals RPAREN . block
    (31) block -> . LCURLY empty RCURLY

    LCURLY          shift and go to state 60

    block                          shift and go to state 67

state 60

    (31) block -> LCURLY . empty RCURLY
    (32) empty -> .

    RCURLY          reduce using rule 32 (empty -> .)

    empty                          shift and go to state 68

state 61

    (27) constructor_decl -> modifier IDENTIFIER LPAREN empty RPAREN block .

    RCURLY          reduce using rule 27 (constructor_decl -> modifier IDENTIFIER LPAREN empty RPAREN block .)


state 62

    (28) constructor_decl -> modifier IDENTIFIER LPAREN formals RPAREN block .

    RCURLY          reduce using rule 28 (constructor_decl -> modifier IDENTIFIER LPAREN formals RPAREN block .)


state 63

    (22) variables -> COMMA IDENTIFIER LSQUARE RSQUARE . variables
    (19) variables -> . IDENTIFIER
    (20) variables -> . IDENTIFIER LSQUARE RSQUARE
    (21) variables -> . COMMA IDENTIFIER variables
    (22) variables -> . COMMA IDENTIFIER LSQUARE RSQUARE variables

    IDENTIFIER      shift and go to state 51
    COMMA           shift and go to state 31

    variables                      shift and go to state 69

state 64

    (23) method_decl -> modifier type IDENTIFIER LPAREN empty RPAREN . block
    (31) block -> . LCURLY empty RCURLY

    LCURLY          shift and go to state 60

    block                          shift and go to state 70

state 65

    (26) method_decl -> modifier type IDENTIFIER LPAREN formals RPAREN . block
    (31) block -> . LCURLY empty RCURLY

    LCURLY          shift and go to state 60

    block                          shift and go to state 71

state 66

    (24) method_decl -> modifier VOID IDENTIFIER LPAREN empty RPAREN block .

    RCURLY          reduce using rule 24 (method_decl -> modifier VOID IDENTIFIER LPAREN empty RPAREN block .)


state 67

    (25) method_decl -> modifier VOID IDENTIFIER LPAREN formals RPAREN block .

    RCURLY          reduce using rule 25 (method_decl -> modifier VOID IDENTIFIER LPAREN formals RPAREN block .)


state 68

    (31) block -> LCURLY empty . RCURLY

    RCURLY          shift and go to state 72


state 69

    (22) variables -> COMMA IDENTIFIER LSQUARE RSQUARE variables .

    SEMICOLON       reduce using rule 22 (variables -> COMMA IDENTIFIER LSQUARE RSQUARE variables .)
    RPAREN          reduce using rule 22 (variables -> COMMA IDENTIFIER LSQUARE RSQUARE variables .)


state 70

    (23) method_decl -> modifier type IDENTIFIER LPAREN empty RPAREN block .

    RCURLY          reduce using rule 23 (method_decl -> modifier type IDENTIFIER LPAREN empty RPAREN block .)


state 71

    (26) method_decl -> modifier type IDENTIFIER LPAREN formals RPAREN block .

    RCURLY          reduce using rule 26 (method_decl -> modifier type IDENTIFIER LPAREN formals RPAREN block .)


state 72

    (31) block -> LCURLY empty RCURLY .

    RCURLY          reduce using rule 31 (block -> LCURLY empty RCURLY .)

