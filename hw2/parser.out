Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Unused terminals:

    DO
    STRINGCONSTANT
    COMMENT
    COLON
    SPACE
    INSCANINT
    OUTPRINT
    INSCANFLOAT

Grammar

Rule 0     S' -> classdecl
Rule 1     classdecl -> CLASS IDENTIFIER LCURLY class_body_decl_helper RCURLY
Rule 2     classdecl -> CLASS IDENTIFIER EXTENDS IDENTIFIER LCURLY class_body_decl_helper RCURLY
Rule 3     class_body_decl_helper -> class_body_decl
Rule 4     class_body_decl_helper -> class_body_decl class_body_decl_helper
Rule 5     class_body_decl -> field_decl
Rule 6     class_body_decl -> method_decl
Rule 7     class_body_decl -> constructor_decl
Rule 8     field_decl -> modifier var_decl
Rule 9     modifier -> PUBLIC
Rule 10    modifier -> PRIVATE
Rule 11    modifier -> STATIC
Rule 12    modifier -> PUBLIC STATIC
Rule 13    modifier -> PRIVATE STATIC
Rule 14    modifier -> empty
Rule 15    var_decl -> type variables SEMICOLON
Rule 16    type -> INT
Rule 17    type -> FLOAT
Rule 18    type -> BOOLEAN
Rule 19    type -> IDENTIFIER
Rule 20    variables -> variable
Rule 21    variables -> variable COMMA variables
Rule 22    variable -> IDENTIFIER
Rule 23    variable -> IDENTIFIER variable_array
Rule 24    variable_array -> LSQUARE RSQUARE
Rule 25    variable_array -> LSQUARE RSQUARE variable_array
Rule 26    method_decl -> modifier type IDENTIFIER LPAREN RPAREN block
Rule 27    method_decl -> modifier type IDENTIFIER LPAREN formals RPAREN block
Rule 28    method_decl -> modifier VOID IDENTIFIER LPAREN RPAREN block
Rule 29    method_decl -> modifier VOID IDENTIFIER LPAREN formals RPAREN block
Rule 30    constructor_decl -> modifier IDENTIFIER LPAREN RPAREN block
Rule 31    constructor_decl -> modifier IDENTIFIER LPAREN formals RPAREN block
Rule 32    formals -> formal_param
Rule 33    formals -> formal_param COMMA formal_param
Rule 34    formal_param -> type variable
Rule 35    block -> LCURLY stmthelper RCURLY
Rule 36    block -> LCURLY RCURLY
Rule 37    stmthelper -> stmt
Rule 38    stmthelper -> stmt stmthelper
Rule 39    stmt -> IF LPAREN expr RPAREN stmt
Rule 40    stmt -> IF LPAREN expr RPAREN stmt ELSE stmt
Rule 41    stmt -> WHILE LPAREN expr RPAREN stmt
Rule 42    stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt
Rule 43    stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt
Rule 44    stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt
Rule 45    stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt
Rule 46    stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
Rule 47    stmt -> FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt
Rule 48    stmt -> FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
Rule 49    stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt
Rule 50    stmt -> RETURN SEMICOLON
Rule 51    stmt -> RETURN expr SEMICOLON
Rule 52    stmt -> stmt_expr SEMICOLON
Rule 53    stmt -> BREAK SEMICOLON
Rule 54    stmt -> CONTINUE SEMICOLON
Rule 55    stmt -> block
Rule 56    stmt -> var_decl
Rule 57    stmt -> SEMICOLON
Rule 58    expr -> primary
Rule 59    expr -> assign
Rule 60    expr -> new_array
Rule 61    expr -> expr PLUS expr
Rule 62    expr -> expr MINUS expr
Rule 63    expr -> expr MULT expr
Rule 64    expr -> expr DIV expr
Rule 65    expr -> expr OR expr
Rule 66    expr -> expr AND expr
Rule 67    expr -> expr EQUALS expr
Rule 68    expr -> expr NOTEQUALS expr
Rule 69    expr -> expr LT expr
Rule 70    expr -> expr GT expr
Rule 71    expr -> expr LEQ expr
Rule 72    expr -> expr GEQ expr
Rule 73    expr -> PLUS expr
Rule 74    expr -> MINUS expr
Rule 75    expr -> NOT expr
Rule 76    assign -> lhs ASSIGN expr
Rule 77    assign -> lhs PLUSPLUS
Rule 78    assign -> PLUSPLUS lhs
Rule 79    assign -> lhs MINUSMINUS
Rule 80    assign -> MINUSMINUS lhs
Rule 81    new_array -> NEW type expr_array_helper1 expr_array_helper2
Rule 82    expr_array_helper1 -> LSQUARE expr RSQUARE
Rule 83    expr_array_helper1 -> LSQUARE expr RSQUARE expr_array_helper1
Rule 84    expr_array_helper2 -> empty
Rule 85    expr_array_helper2 -> LSQUARE RSQUARE expr_array_helper2
Rule 86    stmt_expr -> empty
Rule 87    literal -> INTEGERCONSTANT
Rule 88    literal -> FLOATCONSTANT
Rule 89    literal -> NULL
Rule 90    literal -> TRUE
Rule 91    literal -> FALSE
Rule 92    primary -> literal
Rule 93    primary -> THIS
Rule 94    primary -> SUPER
Rule 95    primary -> LPAREN expr RPAREN
Rule 96    primary -> NEW IDENTIFIER LPAREN arguments RPAREN
Rule 97    primary -> lhs
Rule 98    primary -> method_invocation
Rule 99    arguments -> expr
Rule 100   arguments -> COMMA arguments
Rule 101   lhs -> field_access
Rule 102   lhs -> array_access
Rule 103   method_invocation -> field_access LPAREN RPAREN
Rule 104   method_invocation -> field_access LPAREN expr RPAREN
Rule 105   field_access -> primary DOT IDENTIFIER
Rule 106   field_access -> IDENTIFIER
Rule 107   array_access -> primary LPAREN expr RPAREN
Rule 108   empty -> <empty>

Terminals, with rules where they appear

AND                  : 66
ASSIGN               : 76
BOOLEAN              : 18
BREAK                : 53
CLASS                : 1 2
COLON                : 
COMMA                : 21 33 100
COMMENT              : 
CONTINUE             : 54
DIV                  : 64
DO                   : 
DOT                  : 105
ELSE                 : 40
EQUALS               : 67
EXTENDS              : 2
FALSE                : 91
FLOAT                : 17
FLOATCONSTANT        : 88
FOR                  : 42 43 44 45 46 47 48 49
GEQ                  : 72
GT                   : 70
IDENTIFIER           : 1 2 2 19 22 23 26 27 28 29 30 31 96 105 106
IF                   : 39 40
INSCANFLOAT          : 
INSCANINT            : 
INT                  : 16
INTEGERCONSTANT      : 87
LCURLY               : 1 2 35 36
LEQ                  : 71
LPAREN               : 26 27 28 29 30 31 39 40 41 42 43 44 45 46 47 48 49 95 96 103 104 107
LSQUARE              : 24 25 82 83 85
LT                   : 69
MINUS                : 62 74
MINUSMINUS           : 79 80
MULT                 : 63
NEW                  : 81 96
NOT                  : 75
NOTEQUALS            : 68
NULL                 : 89
OR                   : 65
OUTPRINT             : 
PLUS                 : 61 73
PLUSPLUS             : 77 78
PRIVATE              : 10 13
PUBLIC               : 9 12
RCURLY               : 1 2 35 36
RETURN               : 50 51
RPAREN               : 26 27 28 29 30 31 39 40 41 42 43 44 45 46 47 48 49 95 96 103 104 107
RSQUARE              : 24 25 82 83 85
SEMICOLON            : 15 42 42 43 43 44 44 45 45 46 46 47 47 48 48 49 49 50 51 52 53 54 57
SPACE                : 
STATIC               : 11 12 13
STRINGCONSTANT       : 
SUPER                : 94
THIS                 : 93
TRUE                 : 90
VOID                 : 28 29
WHILE                : 41
error                : 

Nonterminals, with rules where they appear

arguments            : 96 100
array_access         : 102
assign               : 59
block                : 26 27 28 29 30 31 55
class_body_decl      : 3 4
class_body_decl_helper : 1 2 4
classdecl            : 0
constructor_decl     : 7
empty                : 14 84 86
expr                 : 39 40 41 44 46 47 48 51 61 61 62 62 63 63 64 64 65 65 66 66 67 67 68 68 69 69 70 70 71 71 72 72 73 74 75 76 82 83 95 99 104 107
expr_array_helper1   : 81 83
expr_array_helper2   : 81 85
field_access         : 101 103 104
field_decl           : 5
formal_param         : 32 33 33
formals              : 27 29 31
lhs                  : 76 77 78 79 80 97
literal              : 92
method_decl          : 6
method_invocation    : 98
modifier             : 8 26 27 28 29 30 31
new_array            : 60
primary              : 58 105 107
stmt                 : 37 38 39 40 40 41 42 43 44 45 46 47 48 49
stmt_expr            : 43 44 45 45 46 46 48 49 52
stmthelper           : 35 38
type                 : 15 26 27 34 81
var_decl             : 8 56
variable             : 20 21 34
variable_array       : 23 25
variables            : 15 21

Parsing method: LALR

state 0

    (0) S' -> . classdecl
    (1) classdecl -> . CLASS IDENTIFIER LCURLY class_body_decl_helper RCURLY
    (2) classdecl -> . CLASS IDENTIFIER EXTENDS IDENTIFIER LCURLY class_body_decl_helper RCURLY

    CLASS           shift and go to state 2

    classdecl                      shift and go to state 1

state 1

    (0) S' -> classdecl .



state 2

    (1) classdecl -> CLASS . IDENTIFIER LCURLY class_body_decl_helper RCURLY
    (2) classdecl -> CLASS . IDENTIFIER EXTENDS IDENTIFIER LCURLY class_body_decl_helper RCURLY

    IDENTIFIER      shift and go to state 3


state 3

    (1) classdecl -> CLASS IDENTIFIER . LCURLY class_body_decl_helper RCURLY
    (2) classdecl -> CLASS IDENTIFIER . EXTENDS IDENTIFIER LCURLY class_body_decl_helper RCURLY

    LCURLY          shift and go to state 4
    EXTENDS         shift and go to state 5


state 4

    (1) classdecl -> CLASS IDENTIFIER LCURLY . class_body_decl_helper RCURLY
    (3) class_body_decl_helper -> . class_body_decl
    (4) class_body_decl_helper -> . class_body_decl class_body_decl_helper
    (5) class_body_decl -> . field_decl
    (6) class_body_decl -> . method_decl
    (7) class_body_decl -> . constructor_decl
    (8) field_decl -> . modifier var_decl
    (26) method_decl -> . modifier type IDENTIFIER LPAREN RPAREN block
    (27) method_decl -> . modifier type IDENTIFIER LPAREN formals RPAREN block
    (28) method_decl -> . modifier VOID IDENTIFIER LPAREN RPAREN block
    (29) method_decl -> . modifier VOID IDENTIFIER LPAREN formals RPAREN block
    (30) constructor_decl -> . modifier IDENTIFIER LPAREN RPAREN block
    (31) constructor_decl -> . modifier IDENTIFIER LPAREN formals RPAREN block
    (9) modifier -> . PUBLIC
    (10) modifier -> . PRIVATE
    (11) modifier -> . STATIC
    (12) modifier -> . PUBLIC STATIC
    (13) modifier -> . PRIVATE STATIC
    (14) modifier -> . empty
    (108) empty -> .

    PUBLIC          shift and go to state 11
    PRIVATE         shift and go to state 14
    STATIC          shift and go to state 13
    VOID            reduce using rule 108 (empty -> .)
    IDENTIFIER      reduce using rule 108 (empty -> .)
    INT             reduce using rule 108 (empty -> .)
    FLOAT           reduce using rule 108 (empty -> .)
    BOOLEAN         reduce using rule 108 (empty -> .)

    class_body_decl_helper         shift and go to state 15
    class_body_decl                shift and go to state 7
    field_decl                     shift and go to state 8
    constructor_decl               shift and go to state 9
    method_decl                    shift and go to state 10
    empty                          shift and go to state 12
    modifier                       shift and go to state 6

state 5

    (2) classdecl -> CLASS IDENTIFIER EXTENDS . IDENTIFIER LCURLY class_body_decl_helper RCURLY

    IDENTIFIER      shift and go to state 16


state 6

    (8) field_decl -> modifier . var_decl
    (26) method_decl -> modifier . type IDENTIFIER LPAREN RPAREN block
    (27) method_decl -> modifier . type IDENTIFIER LPAREN formals RPAREN block
    (28) method_decl -> modifier . VOID IDENTIFIER LPAREN RPAREN block
    (29) method_decl -> modifier . VOID IDENTIFIER LPAREN formals RPAREN block
    (30) constructor_decl -> modifier . IDENTIFIER LPAREN RPAREN block
    (31) constructor_decl -> modifier . IDENTIFIER LPAREN formals RPAREN block
    (15) var_decl -> . type variables SEMICOLON
    (16) type -> . INT
    (17) type -> . FLOAT
    (18) type -> . BOOLEAN
    (19) type -> . IDENTIFIER

    VOID            shift and go to state 18
    IDENTIFIER      shift and go to state 22
    INT             shift and go to state 17
    FLOAT           shift and go to state 19
    BOOLEAN         shift and go to state 21

    var_decl                       shift and go to state 20
    type                           shift and go to state 23

state 7

    (3) class_body_decl_helper -> class_body_decl .
    (4) class_body_decl_helper -> class_body_decl . class_body_decl_helper
    (3) class_body_decl_helper -> . class_body_decl
    (4) class_body_decl_helper -> . class_body_decl class_body_decl_helper
    (5) class_body_decl -> . field_decl
    (6) class_body_decl -> . method_decl
    (7) class_body_decl -> . constructor_decl
    (8) field_decl -> . modifier var_decl
    (26) method_decl -> . modifier type IDENTIFIER LPAREN RPAREN block
    (27) method_decl -> . modifier type IDENTIFIER LPAREN formals RPAREN block
    (28) method_decl -> . modifier VOID IDENTIFIER LPAREN RPAREN block
    (29) method_decl -> . modifier VOID IDENTIFIER LPAREN formals RPAREN block
    (30) constructor_decl -> . modifier IDENTIFIER LPAREN RPAREN block
    (31) constructor_decl -> . modifier IDENTIFIER LPAREN formals RPAREN block
    (9) modifier -> . PUBLIC
    (10) modifier -> . PRIVATE
    (11) modifier -> . STATIC
    (12) modifier -> . PUBLIC STATIC
    (13) modifier -> . PRIVATE STATIC
    (14) modifier -> . empty
    (108) empty -> .

    RCURLY          reduce using rule 3 (class_body_decl_helper -> class_body_decl .)
    PUBLIC          shift and go to state 11
    PRIVATE         shift and go to state 14
    STATIC          shift and go to state 13
    VOID            reduce using rule 108 (empty -> .)
    IDENTIFIER      reduce using rule 108 (empty -> .)
    INT             reduce using rule 108 (empty -> .)
    FLOAT           reduce using rule 108 (empty -> .)
    BOOLEAN         reduce using rule 108 (empty -> .)

    class_body_decl_helper         shift and go to state 24
    class_body_decl                shift and go to state 7
    field_decl                     shift and go to state 8
    constructor_decl               shift and go to state 9
    method_decl                    shift and go to state 10
    empty                          shift and go to state 12
    modifier                       shift and go to state 6

state 8

    (5) class_body_decl -> field_decl .

    PUBLIC          reduce using rule 5 (class_body_decl -> field_decl .)
    PRIVATE         reduce using rule 5 (class_body_decl -> field_decl .)
    STATIC          reduce using rule 5 (class_body_decl -> field_decl .)
    VOID            reduce using rule 5 (class_body_decl -> field_decl .)
    IDENTIFIER      reduce using rule 5 (class_body_decl -> field_decl .)
    INT             reduce using rule 5 (class_body_decl -> field_decl .)
    FLOAT           reduce using rule 5 (class_body_decl -> field_decl .)
    BOOLEAN         reduce using rule 5 (class_body_decl -> field_decl .)
    RCURLY          reduce using rule 5 (class_body_decl -> field_decl .)


state 9

    (7) class_body_decl -> constructor_decl .

    PUBLIC          reduce using rule 7 (class_body_decl -> constructor_decl .)
    PRIVATE         reduce using rule 7 (class_body_decl -> constructor_decl .)
    STATIC          reduce using rule 7 (class_body_decl -> constructor_decl .)
    VOID            reduce using rule 7 (class_body_decl -> constructor_decl .)
    IDENTIFIER      reduce using rule 7 (class_body_decl -> constructor_decl .)
    INT             reduce using rule 7 (class_body_decl -> constructor_decl .)
    FLOAT           reduce using rule 7 (class_body_decl -> constructor_decl .)
    BOOLEAN         reduce using rule 7 (class_body_decl -> constructor_decl .)
    RCURLY          reduce using rule 7 (class_body_decl -> constructor_decl .)


state 10

    (6) class_body_decl -> method_decl .

    PUBLIC          reduce using rule 6 (class_body_decl -> method_decl .)
    PRIVATE         reduce using rule 6 (class_body_decl -> method_decl .)
    STATIC          reduce using rule 6 (class_body_decl -> method_decl .)
    VOID            reduce using rule 6 (class_body_decl -> method_decl .)
    IDENTIFIER      reduce using rule 6 (class_body_decl -> method_decl .)
    INT             reduce using rule 6 (class_body_decl -> method_decl .)
    FLOAT           reduce using rule 6 (class_body_decl -> method_decl .)
    BOOLEAN         reduce using rule 6 (class_body_decl -> method_decl .)
    RCURLY          reduce using rule 6 (class_body_decl -> method_decl .)


state 11

    (9) modifier -> PUBLIC .
    (12) modifier -> PUBLIC . STATIC

    VOID            reduce using rule 9 (modifier -> PUBLIC .)
    IDENTIFIER      reduce using rule 9 (modifier -> PUBLIC .)
    INT             reduce using rule 9 (modifier -> PUBLIC .)
    FLOAT           reduce using rule 9 (modifier -> PUBLIC .)
    BOOLEAN         reduce using rule 9 (modifier -> PUBLIC .)
    STATIC          shift and go to state 25


state 12

    (14) modifier -> empty .

    VOID            reduce using rule 14 (modifier -> empty .)
    IDENTIFIER      reduce using rule 14 (modifier -> empty .)
    INT             reduce using rule 14 (modifier -> empty .)
    FLOAT           reduce using rule 14 (modifier -> empty .)
    BOOLEAN         reduce using rule 14 (modifier -> empty .)


state 13

    (11) modifier -> STATIC .

    VOID            reduce using rule 11 (modifier -> STATIC .)
    IDENTIFIER      reduce using rule 11 (modifier -> STATIC .)
    INT             reduce using rule 11 (modifier -> STATIC .)
    FLOAT           reduce using rule 11 (modifier -> STATIC .)
    BOOLEAN         reduce using rule 11 (modifier -> STATIC .)


state 14

    (10) modifier -> PRIVATE .
    (13) modifier -> PRIVATE . STATIC

    VOID            reduce using rule 10 (modifier -> PRIVATE .)
    IDENTIFIER      reduce using rule 10 (modifier -> PRIVATE .)
    INT             reduce using rule 10 (modifier -> PRIVATE .)
    FLOAT           reduce using rule 10 (modifier -> PRIVATE .)
    BOOLEAN         reduce using rule 10 (modifier -> PRIVATE .)
    STATIC          shift and go to state 26


state 15

    (1) classdecl -> CLASS IDENTIFIER LCURLY class_body_decl_helper . RCURLY

    RCURLY          shift and go to state 27


state 16

    (2) classdecl -> CLASS IDENTIFIER EXTENDS IDENTIFIER . LCURLY class_body_decl_helper RCURLY

    LCURLY          shift and go to state 28


state 17

    (16) type -> INT .

    IDENTIFIER      reduce using rule 16 (type -> INT .)
    LSQUARE         reduce using rule 16 (type -> INT .)


state 18

    (28) method_decl -> modifier VOID . IDENTIFIER LPAREN RPAREN block
    (29) method_decl -> modifier VOID . IDENTIFIER LPAREN formals RPAREN block

    IDENTIFIER      shift and go to state 29


state 19

    (17) type -> FLOAT .

    IDENTIFIER      reduce using rule 17 (type -> FLOAT .)
    LSQUARE         reduce using rule 17 (type -> FLOAT .)


state 20

    (8) field_decl -> modifier var_decl .

    PUBLIC          reduce using rule 8 (field_decl -> modifier var_decl .)
    PRIVATE         reduce using rule 8 (field_decl -> modifier var_decl .)
    STATIC          reduce using rule 8 (field_decl -> modifier var_decl .)
    VOID            reduce using rule 8 (field_decl -> modifier var_decl .)
    IDENTIFIER      reduce using rule 8 (field_decl -> modifier var_decl .)
    INT             reduce using rule 8 (field_decl -> modifier var_decl .)
    FLOAT           reduce using rule 8 (field_decl -> modifier var_decl .)
    BOOLEAN         reduce using rule 8 (field_decl -> modifier var_decl .)
    RCURLY          reduce using rule 8 (field_decl -> modifier var_decl .)


state 21

    (18) type -> BOOLEAN .

    IDENTIFIER      reduce using rule 18 (type -> BOOLEAN .)
    LSQUARE         reduce using rule 18 (type -> BOOLEAN .)


state 22

    (30) constructor_decl -> modifier IDENTIFIER . LPAREN RPAREN block
    (31) constructor_decl -> modifier IDENTIFIER . LPAREN formals RPAREN block
    (19) type -> IDENTIFIER .

    LPAREN          shift and go to state 30
    IDENTIFIER      reduce using rule 19 (type -> IDENTIFIER .)


state 23

    (26) method_decl -> modifier type . IDENTIFIER LPAREN RPAREN block
    (27) method_decl -> modifier type . IDENTIFIER LPAREN formals RPAREN block
    (15) var_decl -> type . variables SEMICOLON
    (20) variables -> . variable
    (21) variables -> . variable COMMA variables
    (22) variable -> . IDENTIFIER
    (23) variable -> . IDENTIFIER variable_array

    IDENTIFIER      shift and go to state 33

    variables                      shift and go to state 31
    variable                       shift and go to state 32

state 24

    (4) class_body_decl_helper -> class_body_decl class_body_decl_helper .

    RCURLY          reduce using rule 4 (class_body_decl_helper -> class_body_decl class_body_decl_helper .)


state 25

    (12) modifier -> PUBLIC STATIC .

    VOID            reduce using rule 12 (modifier -> PUBLIC STATIC .)
    IDENTIFIER      reduce using rule 12 (modifier -> PUBLIC STATIC .)
    INT             reduce using rule 12 (modifier -> PUBLIC STATIC .)
    FLOAT           reduce using rule 12 (modifier -> PUBLIC STATIC .)
    BOOLEAN         reduce using rule 12 (modifier -> PUBLIC STATIC .)


state 26

    (13) modifier -> PRIVATE STATIC .

    VOID            reduce using rule 13 (modifier -> PRIVATE STATIC .)
    IDENTIFIER      reduce using rule 13 (modifier -> PRIVATE STATIC .)
    INT             reduce using rule 13 (modifier -> PRIVATE STATIC .)
    FLOAT           reduce using rule 13 (modifier -> PRIVATE STATIC .)
    BOOLEAN         reduce using rule 13 (modifier -> PRIVATE STATIC .)


state 27

    (1) classdecl -> CLASS IDENTIFIER LCURLY class_body_decl_helper RCURLY .

    $end            reduce using rule 1 (classdecl -> CLASS IDENTIFIER LCURLY class_body_decl_helper RCURLY .)


state 28

    (2) classdecl -> CLASS IDENTIFIER EXTENDS IDENTIFIER LCURLY . class_body_decl_helper RCURLY
    (3) class_body_decl_helper -> . class_body_decl
    (4) class_body_decl_helper -> . class_body_decl class_body_decl_helper
    (5) class_body_decl -> . field_decl
    (6) class_body_decl -> . method_decl
    (7) class_body_decl -> . constructor_decl
    (8) field_decl -> . modifier var_decl
    (26) method_decl -> . modifier type IDENTIFIER LPAREN RPAREN block
    (27) method_decl -> . modifier type IDENTIFIER LPAREN formals RPAREN block
    (28) method_decl -> . modifier VOID IDENTIFIER LPAREN RPAREN block
    (29) method_decl -> . modifier VOID IDENTIFIER LPAREN formals RPAREN block
    (30) constructor_decl -> . modifier IDENTIFIER LPAREN RPAREN block
    (31) constructor_decl -> . modifier IDENTIFIER LPAREN formals RPAREN block
    (9) modifier -> . PUBLIC
    (10) modifier -> . PRIVATE
    (11) modifier -> . STATIC
    (12) modifier -> . PUBLIC STATIC
    (13) modifier -> . PRIVATE STATIC
    (14) modifier -> . empty
    (108) empty -> .

    PUBLIC          shift and go to state 11
    PRIVATE         shift and go to state 14
    STATIC          shift and go to state 13
    VOID            reduce using rule 108 (empty -> .)
    IDENTIFIER      reduce using rule 108 (empty -> .)
    INT             reduce using rule 108 (empty -> .)
    FLOAT           reduce using rule 108 (empty -> .)
    BOOLEAN         reduce using rule 108 (empty -> .)

    class_body_decl_helper         shift and go to state 34
    class_body_decl                shift and go to state 7
    field_decl                     shift and go to state 8
    constructor_decl               shift and go to state 9
    method_decl                    shift and go to state 10
    empty                          shift and go to state 12
    modifier                       shift and go to state 6

state 29

    (28) method_decl -> modifier VOID IDENTIFIER . LPAREN RPAREN block
    (29) method_decl -> modifier VOID IDENTIFIER . LPAREN formals RPAREN block

    LPAREN          shift and go to state 35


state 30

    (30) constructor_decl -> modifier IDENTIFIER LPAREN . RPAREN block
    (31) constructor_decl -> modifier IDENTIFIER LPAREN . formals RPAREN block
    (32) formals -> . formal_param
    (33) formals -> . formal_param COMMA formal_param
    (34) formal_param -> . type variable
    (16) type -> . INT
    (17) type -> . FLOAT
    (18) type -> . BOOLEAN
    (19) type -> . IDENTIFIER

    RPAREN          shift and go to state 36
    INT             shift and go to state 17
    FLOAT           shift and go to state 19
    BOOLEAN         shift and go to state 21
    IDENTIFIER      shift and go to state 38

    formal_param                   shift and go to state 37
    type                           shift and go to state 39
    formals                        shift and go to state 40

state 31

    (15) var_decl -> type variables . SEMICOLON

    SEMICOLON       shift and go to state 41


state 32

    (20) variables -> variable .
    (21) variables -> variable . COMMA variables

    SEMICOLON       reduce using rule 20 (variables -> variable .)
    COMMA           shift and go to state 42


state 33

    (26) method_decl -> modifier type IDENTIFIER . LPAREN RPAREN block
    (27) method_decl -> modifier type IDENTIFIER . LPAREN formals RPAREN block
    (22) variable -> IDENTIFIER .
    (23) variable -> IDENTIFIER . variable_array
    (24) variable_array -> . LSQUARE RSQUARE
    (25) variable_array -> . LSQUARE RSQUARE variable_array

    LPAREN          shift and go to state 44
    COMMA           reduce using rule 22 (variable -> IDENTIFIER .)
    SEMICOLON       reduce using rule 22 (variable -> IDENTIFIER .)
    LSQUARE         shift and go to state 43

    variable_array                 shift and go to state 45

state 34

    (2) classdecl -> CLASS IDENTIFIER EXTENDS IDENTIFIER LCURLY class_body_decl_helper . RCURLY

    RCURLY          shift and go to state 46


state 35

    (28) method_decl -> modifier VOID IDENTIFIER LPAREN . RPAREN block
    (29) method_decl -> modifier VOID IDENTIFIER LPAREN . formals RPAREN block
    (32) formals -> . formal_param
    (33) formals -> . formal_param COMMA formal_param
    (34) formal_param -> . type variable
    (16) type -> . INT
    (17) type -> . FLOAT
    (18) type -> . BOOLEAN
    (19) type -> . IDENTIFIER

    RPAREN          shift and go to state 47
    INT             shift and go to state 17
    FLOAT           shift and go to state 19
    BOOLEAN         shift and go to state 21
    IDENTIFIER      shift and go to state 38

    formal_param                   shift and go to state 37
    type                           shift and go to state 39
    formals                        shift and go to state 48

state 36

    (30) constructor_decl -> modifier IDENTIFIER LPAREN RPAREN . block
    (35) block -> . LCURLY stmthelper RCURLY
    (36) block -> . LCURLY RCURLY

    LCURLY          shift and go to state 49

    block                          shift and go to state 50

state 37

    (32) formals -> formal_param .
    (33) formals -> formal_param . COMMA formal_param

    RPAREN          reduce using rule 32 (formals -> formal_param .)
    COMMA           shift and go to state 51


state 38

    (19) type -> IDENTIFIER .

    IDENTIFIER      reduce using rule 19 (type -> IDENTIFIER .)


state 39

    (34) formal_param -> type . variable
    (22) variable -> . IDENTIFIER
    (23) variable -> . IDENTIFIER variable_array

    IDENTIFIER      shift and go to state 53

    variable                       shift and go to state 52

state 40

    (31) constructor_decl -> modifier IDENTIFIER LPAREN formals . RPAREN block

    RPAREN          shift and go to state 54


state 41

    (15) var_decl -> type variables SEMICOLON .

    IF              reduce using rule 15 (var_decl -> type variables SEMICOLON .)
    WHILE           reduce using rule 15 (var_decl -> type variables SEMICOLON .)
    FOR             reduce using rule 15 (var_decl -> type variables SEMICOLON .)
    RETURN          reduce using rule 15 (var_decl -> type variables SEMICOLON .)
    BREAK           reduce using rule 15 (var_decl -> type variables SEMICOLON .)
    CONTINUE        reduce using rule 15 (var_decl -> type variables SEMICOLON .)
    SEMICOLON       reduce using rule 15 (var_decl -> type variables SEMICOLON .)
    LCURLY          reduce using rule 15 (var_decl -> type variables SEMICOLON .)
    INT             reduce using rule 15 (var_decl -> type variables SEMICOLON .)
    FLOAT           reduce using rule 15 (var_decl -> type variables SEMICOLON .)
    BOOLEAN         reduce using rule 15 (var_decl -> type variables SEMICOLON .)
    IDENTIFIER      reduce using rule 15 (var_decl -> type variables SEMICOLON .)
    RCURLY          reduce using rule 15 (var_decl -> type variables SEMICOLON .)
    ELSE            reduce using rule 15 (var_decl -> type variables SEMICOLON .)
    PUBLIC          reduce using rule 15 (var_decl -> type variables SEMICOLON .)
    PRIVATE         reduce using rule 15 (var_decl -> type variables SEMICOLON .)
    STATIC          reduce using rule 15 (var_decl -> type variables SEMICOLON .)
    VOID            reduce using rule 15 (var_decl -> type variables SEMICOLON .)


state 42

    (21) variables -> variable COMMA . variables
    (20) variables -> . variable
    (21) variables -> . variable COMMA variables
    (22) variable -> . IDENTIFIER
    (23) variable -> . IDENTIFIER variable_array

    IDENTIFIER      shift and go to state 53

    variable                       shift and go to state 32
    variables                      shift and go to state 55

state 43

    (24) variable_array -> LSQUARE . RSQUARE
    (25) variable_array -> LSQUARE . RSQUARE variable_array

    RSQUARE         shift and go to state 56


state 44

    (26) method_decl -> modifier type IDENTIFIER LPAREN . RPAREN block
    (27) method_decl -> modifier type IDENTIFIER LPAREN . formals RPAREN block
    (32) formals -> . formal_param
    (33) formals -> . formal_param COMMA formal_param
    (34) formal_param -> . type variable
    (16) type -> . INT
    (17) type -> . FLOAT
    (18) type -> . BOOLEAN
    (19) type -> . IDENTIFIER

    RPAREN          shift and go to state 57
    INT             shift and go to state 17
    FLOAT           shift and go to state 19
    BOOLEAN         shift and go to state 21
    IDENTIFIER      shift and go to state 38

    formal_param                   shift and go to state 37
    type                           shift and go to state 39
    formals                        shift and go to state 58

state 45

    (23) variable -> IDENTIFIER variable_array .

    COMMA           reduce using rule 23 (variable -> IDENTIFIER variable_array .)
    SEMICOLON       reduce using rule 23 (variable -> IDENTIFIER variable_array .)
    RPAREN          reduce using rule 23 (variable -> IDENTIFIER variable_array .)


state 46

    (2) classdecl -> CLASS IDENTIFIER EXTENDS IDENTIFIER LCURLY class_body_decl_helper RCURLY .

    $end            reduce using rule 2 (classdecl -> CLASS IDENTIFIER EXTENDS IDENTIFIER LCURLY class_body_decl_helper RCURLY .)


state 47

    (28) method_decl -> modifier VOID IDENTIFIER LPAREN RPAREN . block
    (35) block -> . LCURLY stmthelper RCURLY
    (36) block -> . LCURLY RCURLY

    LCURLY          shift and go to state 49

    block                          shift and go to state 59

state 48

    (29) method_decl -> modifier VOID IDENTIFIER LPAREN formals . RPAREN block

    RPAREN          shift and go to state 60


state 49

    (35) block -> LCURLY . stmthelper RCURLY
    (36) block -> LCURLY . RCURLY
    (37) stmthelper -> . stmt
    (38) stmthelper -> . stmt stmthelper
    (39) stmt -> . IF LPAREN expr RPAREN stmt
    (40) stmt -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (41) stmt -> . WHILE LPAREN expr RPAREN stmt
    (42) stmt -> . FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt
    (43) stmt -> . FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt
    (44) stmt -> . FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt
    (45) stmt -> . FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt
    (46) stmt -> . FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (47) stmt -> . FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt
    (48) stmt -> . FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (49) stmt -> . FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt
    (50) stmt -> . RETURN SEMICOLON
    (51) stmt -> . RETURN expr SEMICOLON
    (52) stmt -> . stmt_expr SEMICOLON
    (53) stmt -> . BREAK SEMICOLON
    (54) stmt -> . CONTINUE SEMICOLON
    (55) stmt -> . block
    (56) stmt -> . var_decl
    (57) stmt -> . SEMICOLON
    (86) stmt_expr -> . empty
    (35) block -> . LCURLY stmthelper RCURLY
    (36) block -> . LCURLY RCURLY
    (15) var_decl -> . type variables SEMICOLON
    (108) empty -> .
    (16) type -> . INT
    (17) type -> . FLOAT
    (18) type -> . BOOLEAN
    (19) type -> . IDENTIFIER

  ! shift/reduce conflict for SEMICOLON resolved as shift
    RCURLY          shift and go to state 64
    IF              shift and go to state 70
    WHILE           shift and go to state 62
    FOR             shift and go to state 68
    RETURN          shift and go to state 61
    BREAK           shift and go to state 73
    CONTINUE        shift and go to state 74
    SEMICOLON       shift and go to state 63
    LCURLY          shift and go to state 49
    INT             shift and go to state 17
    FLOAT           shift and go to state 19
    BOOLEAN         shift and go to state 21
    IDENTIFIER      shift and go to state 38

  ! SEMICOLON       [ reduce using rule 108 (empty -> .) ]

    stmthelper                     shift and go to state 71
    var_decl                       shift and go to state 72
    stmt_expr                      shift and go to state 65
    empty                          shift and go to state 67
    stmt                           shift and go to state 69
    type                           shift and go to state 66
    block                          shift and go to state 75

state 50

    (30) constructor_decl -> modifier IDENTIFIER LPAREN RPAREN block .

    PUBLIC          reduce using rule 30 (constructor_decl -> modifier IDENTIFIER LPAREN RPAREN block .)
    PRIVATE         reduce using rule 30 (constructor_decl -> modifier IDENTIFIER LPAREN RPAREN block .)
    STATIC          reduce using rule 30 (constructor_decl -> modifier IDENTIFIER LPAREN RPAREN block .)
    VOID            reduce using rule 30 (constructor_decl -> modifier IDENTIFIER LPAREN RPAREN block .)
    IDENTIFIER      reduce using rule 30 (constructor_decl -> modifier IDENTIFIER LPAREN RPAREN block .)
    INT             reduce using rule 30 (constructor_decl -> modifier IDENTIFIER LPAREN RPAREN block .)
    FLOAT           reduce using rule 30 (constructor_decl -> modifier IDENTIFIER LPAREN RPAREN block .)
    BOOLEAN         reduce using rule 30 (constructor_decl -> modifier IDENTIFIER LPAREN RPAREN block .)
    RCURLY          reduce using rule 30 (constructor_decl -> modifier IDENTIFIER LPAREN RPAREN block .)


state 51

    (33) formals -> formal_param COMMA . formal_param
    (34) formal_param -> . type variable
    (16) type -> . INT
    (17) type -> . FLOAT
    (18) type -> . BOOLEAN
    (19) type -> . IDENTIFIER

    INT             shift and go to state 17
    FLOAT           shift and go to state 19
    BOOLEAN         shift and go to state 21
    IDENTIFIER      shift and go to state 38

    formal_param                   shift and go to state 76
    type                           shift and go to state 39

state 52

    (34) formal_param -> type variable .

    RPAREN          reduce using rule 34 (formal_param -> type variable .)
    COMMA           reduce using rule 34 (formal_param -> type variable .)


state 53

    (22) variable -> IDENTIFIER .
    (23) variable -> IDENTIFIER . variable_array
    (24) variable_array -> . LSQUARE RSQUARE
    (25) variable_array -> . LSQUARE RSQUARE variable_array

    COMMA           reduce using rule 22 (variable -> IDENTIFIER .)
    SEMICOLON       reduce using rule 22 (variable -> IDENTIFIER .)
    RPAREN          reduce using rule 22 (variable -> IDENTIFIER .)
    LSQUARE         shift and go to state 43

    variable_array                 shift and go to state 45

state 54

    (31) constructor_decl -> modifier IDENTIFIER LPAREN formals RPAREN . block
    (35) block -> . LCURLY stmthelper RCURLY
    (36) block -> . LCURLY RCURLY

    LCURLY          shift and go to state 49

    block                          shift and go to state 77

state 55

    (21) variables -> variable COMMA variables .

    SEMICOLON       reduce using rule 21 (variables -> variable COMMA variables .)


state 56

    (24) variable_array -> LSQUARE RSQUARE .
    (25) variable_array -> LSQUARE RSQUARE . variable_array
    (24) variable_array -> . LSQUARE RSQUARE
    (25) variable_array -> . LSQUARE RSQUARE variable_array

    COMMA           reduce using rule 24 (variable_array -> LSQUARE RSQUARE .)
    SEMICOLON       reduce using rule 24 (variable_array -> LSQUARE RSQUARE .)
    RPAREN          reduce using rule 24 (variable_array -> LSQUARE RSQUARE .)
    LSQUARE         shift and go to state 43

    variable_array                 shift and go to state 78

state 57

    (26) method_decl -> modifier type IDENTIFIER LPAREN RPAREN . block
    (35) block -> . LCURLY stmthelper RCURLY
    (36) block -> . LCURLY RCURLY

    LCURLY          shift and go to state 49

    block                          shift and go to state 79

state 58

    (27) method_decl -> modifier type IDENTIFIER LPAREN formals . RPAREN block

    RPAREN          shift and go to state 80


state 59

    (28) method_decl -> modifier VOID IDENTIFIER LPAREN RPAREN block .

    PUBLIC          reduce using rule 28 (method_decl -> modifier VOID IDENTIFIER LPAREN RPAREN block .)
    PRIVATE         reduce using rule 28 (method_decl -> modifier VOID IDENTIFIER LPAREN RPAREN block .)
    STATIC          reduce using rule 28 (method_decl -> modifier VOID IDENTIFIER LPAREN RPAREN block .)
    VOID            reduce using rule 28 (method_decl -> modifier VOID IDENTIFIER LPAREN RPAREN block .)
    IDENTIFIER      reduce using rule 28 (method_decl -> modifier VOID IDENTIFIER LPAREN RPAREN block .)
    INT             reduce using rule 28 (method_decl -> modifier VOID IDENTIFIER LPAREN RPAREN block .)
    FLOAT           reduce using rule 28 (method_decl -> modifier VOID IDENTIFIER LPAREN RPAREN block .)
    BOOLEAN         reduce using rule 28 (method_decl -> modifier VOID IDENTIFIER LPAREN RPAREN block .)
    RCURLY          reduce using rule 28 (method_decl -> modifier VOID IDENTIFIER LPAREN RPAREN block .)


state 60

    (29) method_decl -> modifier VOID IDENTIFIER LPAREN formals RPAREN . block
    (35) block -> . LCURLY stmthelper RCURLY
    (36) block -> . LCURLY RCURLY

    LCURLY          shift and go to state 49

    block                          shift and go to state 81

state 61

    (50) stmt -> RETURN . SEMICOLON
    (51) stmt -> RETURN . expr SEMICOLON
    (58) expr -> . primary
    (59) expr -> . assign
    (60) expr -> . new_array
    (61) expr -> . expr PLUS expr
    (62) expr -> . expr MINUS expr
    (63) expr -> . expr MULT expr
    (64) expr -> . expr DIV expr
    (65) expr -> . expr OR expr
    (66) expr -> . expr AND expr
    (67) expr -> . expr EQUALS expr
    (68) expr -> . expr NOTEQUALS expr
    (69) expr -> . expr LT expr
    (70) expr -> . expr GT expr
    (71) expr -> . expr LEQ expr
    (72) expr -> . expr GEQ expr
    (73) expr -> . PLUS expr
    (74) expr -> . MINUS expr
    (75) expr -> . NOT expr
    (92) primary -> . literal
    (93) primary -> . THIS
    (94) primary -> . SUPER
    (95) primary -> . LPAREN expr RPAREN
    (96) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (97) primary -> . lhs
    (98) primary -> . method_invocation
    (76) assign -> . lhs ASSIGN expr
    (77) assign -> . lhs PLUSPLUS
    (78) assign -> . PLUSPLUS lhs
    (79) assign -> . lhs MINUSMINUS
    (80) assign -> . MINUSMINUS lhs
    (81) new_array -> . NEW type expr_array_helper1 expr_array_helper2
    (87) literal -> . INTEGERCONSTANT
    (88) literal -> . FLOATCONSTANT
    (89) literal -> . NULL
    (90) literal -> . TRUE
    (91) literal -> . FALSE
    (101) lhs -> . field_access
    (102) lhs -> . array_access
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN expr RPAREN
    (105) field_access -> . primary DOT IDENTIFIER
    (106) field_access -> . IDENTIFIER
    (107) array_access -> . primary LPAREN expr RPAREN

    SEMICOLON       shift and go to state 89
    PLUS            shift and go to state 92
    MINUS           shift and go to state 88
    NOT             shift and go to state 104
    THIS            shift and go to state 101
    SUPER           shift and go to state 105
    LPAREN          shift and go to state 97
    NEW             shift and go to state 85
    PLUSPLUS        shift and go to state 96
    MINUSMINUS      shift and go to state 98
    INTEGERCONSTANT shift and go to state 84
    FLOATCONSTANT   shift and go to state 99
    NULL            shift and go to state 86
    TRUE            shift and go to state 87
    FALSE           shift and go to state 100
    IDENTIFIER      shift and go to state 94

    new_array                      shift and go to state 82
    field_access                   shift and go to state 95
    expr                           shift and go to state 102
    primary                        shift and go to state 83
    array_access                   shift and go to state 90
    literal                        shift and go to state 91
    lhs                            shift and go to state 103
    method_invocation              shift and go to state 93
    assign                         shift and go to state 106

state 62

    (41) stmt -> WHILE . LPAREN expr RPAREN stmt

    LPAREN          shift and go to state 107


state 63

    (57) stmt -> SEMICOLON .

    IF              reduce using rule 57 (stmt -> SEMICOLON .)
    WHILE           reduce using rule 57 (stmt -> SEMICOLON .)
    FOR             reduce using rule 57 (stmt -> SEMICOLON .)
    RETURN          reduce using rule 57 (stmt -> SEMICOLON .)
    BREAK           reduce using rule 57 (stmt -> SEMICOLON .)
    CONTINUE        reduce using rule 57 (stmt -> SEMICOLON .)
    SEMICOLON       reduce using rule 57 (stmt -> SEMICOLON .)
    LCURLY          reduce using rule 57 (stmt -> SEMICOLON .)
    INT             reduce using rule 57 (stmt -> SEMICOLON .)
    FLOAT           reduce using rule 57 (stmt -> SEMICOLON .)
    BOOLEAN         reduce using rule 57 (stmt -> SEMICOLON .)
    IDENTIFIER      reduce using rule 57 (stmt -> SEMICOLON .)
    RCURLY          reduce using rule 57 (stmt -> SEMICOLON .)
    ELSE            reduce using rule 57 (stmt -> SEMICOLON .)


state 64

    (36) block -> LCURLY RCURLY .

    IF              reduce using rule 36 (block -> LCURLY RCURLY .)
    WHILE           reduce using rule 36 (block -> LCURLY RCURLY .)
    FOR             reduce using rule 36 (block -> LCURLY RCURLY .)
    RETURN          reduce using rule 36 (block -> LCURLY RCURLY .)
    BREAK           reduce using rule 36 (block -> LCURLY RCURLY .)
    CONTINUE        reduce using rule 36 (block -> LCURLY RCURLY .)
    SEMICOLON       reduce using rule 36 (block -> LCURLY RCURLY .)
    LCURLY          reduce using rule 36 (block -> LCURLY RCURLY .)
    INT             reduce using rule 36 (block -> LCURLY RCURLY .)
    FLOAT           reduce using rule 36 (block -> LCURLY RCURLY .)
    BOOLEAN         reduce using rule 36 (block -> LCURLY RCURLY .)
    IDENTIFIER      reduce using rule 36 (block -> LCURLY RCURLY .)
    RCURLY          reduce using rule 36 (block -> LCURLY RCURLY .)
    ELSE            reduce using rule 36 (block -> LCURLY RCURLY .)
    PUBLIC          reduce using rule 36 (block -> LCURLY RCURLY .)
    PRIVATE         reduce using rule 36 (block -> LCURLY RCURLY .)
    STATIC          reduce using rule 36 (block -> LCURLY RCURLY .)
    VOID            reduce using rule 36 (block -> LCURLY RCURLY .)


state 65

    (52) stmt -> stmt_expr . SEMICOLON

    SEMICOLON       shift and go to state 108


state 66

    (15) var_decl -> type . variables SEMICOLON
    (20) variables -> . variable
    (21) variables -> . variable COMMA variables
    (22) variable -> . IDENTIFIER
    (23) variable -> . IDENTIFIER variable_array

    IDENTIFIER      shift and go to state 53

    variable                       shift and go to state 32
    variables                      shift and go to state 31

state 67

    (86) stmt_expr -> empty .

    SEMICOLON       reduce using rule 86 (stmt_expr -> empty .)
    RPAREN          reduce using rule 86 (stmt_expr -> empty .)


state 68

    (42) stmt -> FOR . LPAREN SEMICOLON SEMICOLON RPAREN stmt
    (43) stmt -> FOR . LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt
    (44) stmt -> FOR . LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt
    (45) stmt -> FOR . LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt
    (46) stmt -> FOR . LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (47) stmt -> FOR . LPAREN SEMICOLON expr SEMICOLON RPAREN stmt
    (48) stmt -> FOR . LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (49) stmt -> FOR . LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt

    LPAREN          shift and go to state 109


state 69

    (37) stmthelper -> stmt .
    (38) stmthelper -> stmt . stmthelper
    (37) stmthelper -> . stmt
    (38) stmthelper -> . stmt stmthelper
    (39) stmt -> . IF LPAREN expr RPAREN stmt
    (40) stmt -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (41) stmt -> . WHILE LPAREN expr RPAREN stmt
    (42) stmt -> . FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt
    (43) stmt -> . FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt
    (44) stmt -> . FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt
    (45) stmt -> . FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt
    (46) stmt -> . FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (47) stmt -> . FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt
    (48) stmt -> . FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (49) stmt -> . FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt
    (50) stmt -> . RETURN SEMICOLON
    (51) stmt -> . RETURN expr SEMICOLON
    (52) stmt -> . stmt_expr SEMICOLON
    (53) stmt -> . BREAK SEMICOLON
    (54) stmt -> . CONTINUE SEMICOLON
    (55) stmt -> . block
    (56) stmt -> . var_decl
    (57) stmt -> . SEMICOLON
    (86) stmt_expr -> . empty
    (35) block -> . LCURLY stmthelper RCURLY
    (36) block -> . LCURLY RCURLY
    (15) var_decl -> . type variables SEMICOLON
    (108) empty -> .
    (16) type -> . INT
    (17) type -> . FLOAT
    (18) type -> . BOOLEAN
    (19) type -> . IDENTIFIER

  ! shift/reduce conflict for SEMICOLON resolved as shift
    RCURLY          reduce using rule 37 (stmthelper -> stmt .)
    IF              shift and go to state 70
    WHILE           shift and go to state 62
    FOR             shift and go to state 68
    RETURN          shift and go to state 61
    BREAK           shift and go to state 73
    CONTINUE        shift and go to state 74
    SEMICOLON       shift and go to state 63
    LCURLY          shift and go to state 49
    INT             shift and go to state 17
    FLOAT           shift and go to state 19
    BOOLEAN         shift and go to state 21
    IDENTIFIER      shift and go to state 38

  ! SEMICOLON       [ reduce using rule 108 (empty -> .) ]

    stmthelper                     shift and go to state 110
    var_decl                       shift and go to state 72
    stmt_expr                      shift and go to state 65
    empty                          shift and go to state 67
    stmt                           shift and go to state 69
    type                           shift and go to state 66
    block                          shift and go to state 75

state 70

    (39) stmt -> IF . LPAREN expr RPAREN stmt
    (40) stmt -> IF . LPAREN expr RPAREN stmt ELSE stmt

    LPAREN          shift and go to state 111


state 71

    (35) block -> LCURLY stmthelper . RCURLY

    RCURLY          shift and go to state 112


state 72

    (56) stmt -> var_decl .

    IF              reduce using rule 56 (stmt -> var_decl .)
    WHILE           reduce using rule 56 (stmt -> var_decl .)
    FOR             reduce using rule 56 (stmt -> var_decl .)
    RETURN          reduce using rule 56 (stmt -> var_decl .)
    BREAK           reduce using rule 56 (stmt -> var_decl .)
    CONTINUE        reduce using rule 56 (stmt -> var_decl .)
    SEMICOLON       reduce using rule 56 (stmt -> var_decl .)
    LCURLY          reduce using rule 56 (stmt -> var_decl .)
    INT             reduce using rule 56 (stmt -> var_decl .)
    FLOAT           reduce using rule 56 (stmt -> var_decl .)
    BOOLEAN         reduce using rule 56 (stmt -> var_decl .)
    IDENTIFIER      reduce using rule 56 (stmt -> var_decl .)
    RCURLY          reduce using rule 56 (stmt -> var_decl .)
    ELSE            reduce using rule 56 (stmt -> var_decl .)


state 73

    (53) stmt -> BREAK . SEMICOLON

    SEMICOLON       shift and go to state 113


state 74

    (54) stmt -> CONTINUE . SEMICOLON

    SEMICOLON       shift and go to state 114


state 75

    (55) stmt -> block .

    IF              reduce using rule 55 (stmt -> block .)
    WHILE           reduce using rule 55 (stmt -> block .)
    FOR             reduce using rule 55 (stmt -> block .)
    RETURN          reduce using rule 55 (stmt -> block .)
    BREAK           reduce using rule 55 (stmt -> block .)
    CONTINUE        reduce using rule 55 (stmt -> block .)
    SEMICOLON       reduce using rule 55 (stmt -> block .)
    LCURLY          reduce using rule 55 (stmt -> block .)
    INT             reduce using rule 55 (stmt -> block .)
    FLOAT           reduce using rule 55 (stmt -> block .)
    BOOLEAN         reduce using rule 55 (stmt -> block .)
    IDENTIFIER      reduce using rule 55 (stmt -> block .)
    RCURLY          reduce using rule 55 (stmt -> block .)
    ELSE            reduce using rule 55 (stmt -> block .)


state 76

    (33) formals -> formal_param COMMA formal_param .

    RPAREN          reduce using rule 33 (formals -> formal_param COMMA formal_param .)


state 77

    (31) constructor_decl -> modifier IDENTIFIER LPAREN formals RPAREN block .

    PUBLIC          reduce using rule 31 (constructor_decl -> modifier IDENTIFIER LPAREN formals RPAREN block .)
    PRIVATE         reduce using rule 31 (constructor_decl -> modifier IDENTIFIER LPAREN formals RPAREN block .)
    STATIC          reduce using rule 31 (constructor_decl -> modifier IDENTIFIER LPAREN formals RPAREN block .)
    VOID            reduce using rule 31 (constructor_decl -> modifier IDENTIFIER LPAREN formals RPAREN block .)
    IDENTIFIER      reduce using rule 31 (constructor_decl -> modifier IDENTIFIER LPAREN formals RPAREN block .)
    INT             reduce using rule 31 (constructor_decl -> modifier IDENTIFIER LPAREN formals RPAREN block .)
    FLOAT           reduce using rule 31 (constructor_decl -> modifier IDENTIFIER LPAREN formals RPAREN block .)
    BOOLEAN         reduce using rule 31 (constructor_decl -> modifier IDENTIFIER LPAREN formals RPAREN block .)
    RCURLY          reduce using rule 31 (constructor_decl -> modifier IDENTIFIER LPAREN formals RPAREN block .)


state 78

    (25) variable_array -> LSQUARE RSQUARE variable_array .

    COMMA           reduce using rule 25 (variable_array -> LSQUARE RSQUARE variable_array .)
    SEMICOLON       reduce using rule 25 (variable_array -> LSQUARE RSQUARE variable_array .)
    RPAREN          reduce using rule 25 (variable_array -> LSQUARE RSQUARE variable_array .)


state 79

    (26) method_decl -> modifier type IDENTIFIER LPAREN RPAREN block .

    PUBLIC          reduce using rule 26 (method_decl -> modifier type IDENTIFIER LPAREN RPAREN block .)
    PRIVATE         reduce using rule 26 (method_decl -> modifier type IDENTIFIER LPAREN RPAREN block .)
    STATIC          reduce using rule 26 (method_decl -> modifier type IDENTIFIER LPAREN RPAREN block .)
    VOID            reduce using rule 26 (method_decl -> modifier type IDENTIFIER LPAREN RPAREN block .)
    IDENTIFIER      reduce using rule 26 (method_decl -> modifier type IDENTIFIER LPAREN RPAREN block .)
    INT             reduce using rule 26 (method_decl -> modifier type IDENTIFIER LPAREN RPAREN block .)
    FLOAT           reduce using rule 26 (method_decl -> modifier type IDENTIFIER LPAREN RPAREN block .)
    BOOLEAN         reduce using rule 26 (method_decl -> modifier type IDENTIFIER LPAREN RPAREN block .)
    RCURLY          reduce using rule 26 (method_decl -> modifier type IDENTIFIER LPAREN RPAREN block .)


state 80

    (27) method_decl -> modifier type IDENTIFIER LPAREN formals RPAREN . block
    (35) block -> . LCURLY stmthelper RCURLY
    (36) block -> . LCURLY RCURLY

    LCURLY          shift and go to state 49

    block                          shift and go to state 115

state 81

    (29) method_decl -> modifier VOID IDENTIFIER LPAREN formals RPAREN block .

    PUBLIC          reduce using rule 29 (method_decl -> modifier VOID IDENTIFIER LPAREN formals RPAREN block .)
    PRIVATE         reduce using rule 29 (method_decl -> modifier VOID IDENTIFIER LPAREN formals RPAREN block .)
    STATIC          reduce using rule 29 (method_decl -> modifier VOID IDENTIFIER LPAREN formals RPAREN block .)
    VOID            reduce using rule 29 (method_decl -> modifier VOID IDENTIFIER LPAREN formals RPAREN block .)
    IDENTIFIER      reduce using rule 29 (method_decl -> modifier VOID IDENTIFIER LPAREN formals RPAREN block .)
    INT             reduce using rule 29 (method_decl -> modifier VOID IDENTIFIER LPAREN formals RPAREN block .)
    FLOAT           reduce using rule 29 (method_decl -> modifier VOID IDENTIFIER LPAREN formals RPAREN block .)
    BOOLEAN         reduce using rule 29 (method_decl -> modifier VOID IDENTIFIER LPAREN formals RPAREN block .)
    RCURLY          reduce using rule 29 (method_decl -> modifier VOID IDENTIFIER LPAREN formals RPAREN block .)


state 82

    (60) expr -> new_array .

    RPAREN          reduce using rule 60 (expr -> new_array .)
    PLUS            reduce using rule 60 (expr -> new_array .)
    MINUS           reduce using rule 60 (expr -> new_array .)
    MULT            reduce using rule 60 (expr -> new_array .)
    DIV             reduce using rule 60 (expr -> new_array .)
    OR              reduce using rule 60 (expr -> new_array .)
    AND             reduce using rule 60 (expr -> new_array .)
    EQUALS          reduce using rule 60 (expr -> new_array .)
    NOTEQUALS       reduce using rule 60 (expr -> new_array .)
    LT              reduce using rule 60 (expr -> new_array .)
    GT              reduce using rule 60 (expr -> new_array .)
    LEQ             reduce using rule 60 (expr -> new_array .)
    GEQ             reduce using rule 60 (expr -> new_array .)
    SEMICOLON       reduce using rule 60 (expr -> new_array .)
    RSQUARE         reduce using rule 60 (expr -> new_array .)


state 83

    (58) expr -> primary .
    (105) field_access -> primary . DOT IDENTIFIER
    (107) array_access -> primary . LPAREN expr RPAREN

    RPAREN          reduce using rule 58 (expr -> primary .)
    PLUS            reduce using rule 58 (expr -> primary .)
    MINUS           reduce using rule 58 (expr -> primary .)
    MULT            reduce using rule 58 (expr -> primary .)
    DIV             reduce using rule 58 (expr -> primary .)
    OR              reduce using rule 58 (expr -> primary .)
    AND             reduce using rule 58 (expr -> primary .)
    EQUALS          reduce using rule 58 (expr -> primary .)
    NOTEQUALS       reduce using rule 58 (expr -> primary .)
    LT              reduce using rule 58 (expr -> primary .)
    GT              reduce using rule 58 (expr -> primary .)
    LEQ             reduce using rule 58 (expr -> primary .)
    GEQ             reduce using rule 58 (expr -> primary .)
    SEMICOLON       reduce using rule 58 (expr -> primary .)
    RSQUARE         reduce using rule 58 (expr -> primary .)
    DOT             shift and go to state 117
    LPAREN          shift and go to state 116


state 84

    (87) literal -> INTEGERCONSTANT .

    DOT             reduce using rule 87 (literal -> INTEGERCONSTANT .)
    LPAREN          reduce using rule 87 (literal -> INTEGERCONSTANT .)
    PLUS            reduce using rule 87 (literal -> INTEGERCONSTANT .)
    MINUS           reduce using rule 87 (literal -> INTEGERCONSTANT .)
    MULT            reduce using rule 87 (literal -> INTEGERCONSTANT .)
    DIV             reduce using rule 87 (literal -> INTEGERCONSTANT .)
    OR              reduce using rule 87 (literal -> INTEGERCONSTANT .)
    AND             reduce using rule 87 (literal -> INTEGERCONSTANT .)
    EQUALS          reduce using rule 87 (literal -> INTEGERCONSTANT .)
    NOTEQUALS       reduce using rule 87 (literal -> INTEGERCONSTANT .)
    LT              reduce using rule 87 (literal -> INTEGERCONSTANT .)
    GT              reduce using rule 87 (literal -> INTEGERCONSTANT .)
    LEQ             reduce using rule 87 (literal -> INTEGERCONSTANT .)
    GEQ             reduce using rule 87 (literal -> INTEGERCONSTANT .)
    SEMICOLON       reduce using rule 87 (literal -> INTEGERCONSTANT .)
    RPAREN          reduce using rule 87 (literal -> INTEGERCONSTANT .)
    RSQUARE         reduce using rule 87 (literal -> INTEGERCONSTANT .)


state 85

    (96) primary -> NEW . IDENTIFIER LPAREN arguments RPAREN
    (81) new_array -> NEW . type expr_array_helper1 expr_array_helper2
    (16) type -> . INT
    (17) type -> . FLOAT
    (18) type -> . BOOLEAN
    (19) type -> . IDENTIFIER

    IDENTIFIER      shift and go to state 118
    INT             shift and go to state 17
    FLOAT           shift and go to state 19
    BOOLEAN         shift and go to state 21

    type                           shift and go to state 119

state 86

    (89) literal -> NULL .

    DOT             reduce using rule 89 (literal -> NULL .)
    LPAREN          reduce using rule 89 (literal -> NULL .)
    PLUS            reduce using rule 89 (literal -> NULL .)
    MINUS           reduce using rule 89 (literal -> NULL .)
    MULT            reduce using rule 89 (literal -> NULL .)
    DIV             reduce using rule 89 (literal -> NULL .)
    OR              reduce using rule 89 (literal -> NULL .)
    AND             reduce using rule 89 (literal -> NULL .)
    EQUALS          reduce using rule 89 (literal -> NULL .)
    NOTEQUALS       reduce using rule 89 (literal -> NULL .)
    LT              reduce using rule 89 (literal -> NULL .)
    GT              reduce using rule 89 (literal -> NULL .)
    LEQ             reduce using rule 89 (literal -> NULL .)
    GEQ             reduce using rule 89 (literal -> NULL .)
    SEMICOLON       reduce using rule 89 (literal -> NULL .)
    RPAREN          reduce using rule 89 (literal -> NULL .)
    RSQUARE         reduce using rule 89 (literal -> NULL .)


state 87

    (90) literal -> TRUE .

    DOT             reduce using rule 90 (literal -> TRUE .)
    LPAREN          reduce using rule 90 (literal -> TRUE .)
    PLUS            reduce using rule 90 (literal -> TRUE .)
    MINUS           reduce using rule 90 (literal -> TRUE .)
    MULT            reduce using rule 90 (literal -> TRUE .)
    DIV             reduce using rule 90 (literal -> TRUE .)
    OR              reduce using rule 90 (literal -> TRUE .)
    AND             reduce using rule 90 (literal -> TRUE .)
    EQUALS          reduce using rule 90 (literal -> TRUE .)
    NOTEQUALS       reduce using rule 90 (literal -> TRUE .)
    LT              reduce using rule 90 (literal -> TRUE .)
    GT              reduce using rule 90 (literal -> TRUE .)
    LEQ             reduce using rule 90 (literal -> TRUE .)
    GEQ             reduce using rule 90 (literal -> TRUE .)
    SEMICOLON       reduce using rule 90 (literal -> TRUE .)
    RPAREN          reduce using rule 90 (literal -> TRUE .)
    RSQUARE         reduce using rule 90 (literal -> TRUE .)


state 88

    (74) expr -> MINUS . expr
    (58) expr -> . primary
    (59) expr -> . assign
    (60) expr -> . new_array
    (61) expr -> . expr PLUS expr
    (62) expr -> . expr MINUS expr
    (63) expr -> . expr MULT expr
    (64) expr -> . expr DIV expr
    (65) expr -> . expr OR expr
    (66) expr -> . expr AND expr
    (67) expr -> . expr EQUALS expr
    (68) expr -> . expr NOTEQUALS expr
    (69) expr -> . expr LT expr
    (70) expr -> . expr GT expr
    (71) expr -> . expr LEQ expr
    (72) expr -> . expr GEQ expr
    (73) expr -> . PLUS expr
    (74) expr -> . MINUS expr
    (75) expr -> . NOT expr
    (92) primary -> . literal
    (93) primary -> . THIS
    (94) primary -> . SUPER
    (95) primary -> . LPAREN expr RPAREN
    (96) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (97) primary -> . lhs
    (98) primary -> . method_invocation
    (76) assign -> . lhs ASSIGN expr
    (77) assign -> . lhs PLUSPLUS
    (78) assign -> . PLUSPLUS lhs
    (79) assign -> . lhs MINUSMINUS
    (80) assign -> . MINUSMINUS lhs
    (81) new_array -> . NEW type expr_array_helper1 expr_array_helper2
    (87) literal -> . INTEGERCONSTANT
    (88) literal -> . FLOATCONSTANT
    (89) literal -> . NULL
    (90) literal -> . TRUE
    (91) literal -> . FALSE
    (101) lhs -> . field_access
    (102) lhs -> . array_access
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN expr RPAREN
    (105) field_access -> . primary DOT IDENTIFIER
    (106) field_access -> . IDENTIFIER
    (107) array_access -> . primary LPAREN expr RPAREN

    PLUS            shift and go to state 92
    MINUS           shift and go to state 88
    NOT             shift and go to state 104
    THIS            shift and go to state 101
    SUPER           shift and go to state 105
    LPAREN          shift and go to state 97
    NEW             shift and go to state 85
    PLUSPLUS        shift and go to state 96
    MINUSMINUS      shift and go to state 98
    INTEGERCONSTANT shift and go to state 84
    FLOATCONSTANT   shift and go to state 99
    NULL            shift and go to state 86
    TRUE            shift and go to state 87
    FALSE           shift and go to state 100
    IDENTIFIER      shift and go to state 94

    new_array                      shift and go to state 82
    field_access                   shift and go to state 95
    expr                           shift and go to state 120
    primary                        shift and go to state 83
    array_access                   shift and go to state 90
    literal                        shift and go to state 91
    lhs                            shift and go to state 103
    method_invocation              shift and go to state 93
    assign                         shift and go to state 106

state 89

    (50) stmt -> RETURN SEMICOLON .

    IF              reduce using rule 50 (stmt -> RETURN SEMICOLON .)
    WHILE           reduce using rule 50 (stmt -> RETURN SEMICOLON .)
    FOR             reduce using rule 50 (stmt -> RETURN SEMICOLON .)
    RETURN          reduce using rule 50 (stmt -> RETURN SEMICOLON .)
    BREAK           reduce using rule 50 (stmt -> RETURN SEMICOLON .)
    CONTINUE        reduce using rule 50 (stmt -> RETURN SEMICOLON .)
    SEMICOLON       reduce using rule 50 (stmt -> RETURN SEMICOLON .)
    LCURLY          reduce using rule 50 (stmt -> RETURN SEMICOLON .)
    INT             reduce using rule 50 (stmt -> RETURN SEMICOLON .)
    FLOAT           reduce using rule 50 (stmt -> RETURN SEMICOLON .)
    BOOLEAN         reduce using rule 50 (stmt -> RETURN SEMICOLON .)
    IDENTIFIER      reduce using rule 50 (stmt -> RETURN SEMICOLON .)
    RCURLY          reduce using rule 50 (stmt -> RETURN SEMICOLON .)
    ELSE            reduce using rule 50 (stmt -> RETURN SEMICOLON .)


state 90

    (102) lhs -> array_access .

    ASSIGN          reduce using rule 102 (lhs -> array_access .)
    PLUSPLUS        reduce using rule 102 (lhs -> array_access .)
    MINUSMINUS      reduce using rule 102 (lhs -> array_access .)
    DOT             reduce using rule 102 (lhs -> array_access .)
    LPAREN          reduce using rule 102 (lhs -> array_access .)
    PLUS            reduce using rule 102 (lhs -> array_access .)
    MINUS           reduce using rule 102 (lhs -> array_access .)
    MULT            reduce using rule 102 (lhs -> array_access .)
    DIV             reduce using rule 102 (lhs -> array_access .)
    OR              reduce using rule 102 (lhs -> array_access .)
    AND             reduce using rule 102 (lhs -> array_access .)
    EQUALS          reduce using rule 102 (lhs -> array_access .)
    NOTEQUALS       reduce using rule 102 (lhs -> array_access .)
    LT              reduce using rule 102 (lhs -> array_access .)
    GT              reduce using rule 102 (lhs -> array_access .)
    LEQ             reduce using rule 102 (lhs -> array_access .)
    GEQ             reduce using rule 102 (lhs -> array_access .)
    SEMICOLON       reduce using rule 102 (lhs -> array_access .)
    RPAREN          reduce using rule 102 (lhs -> array_access .)
    RSQUARE         reduce using rule 102 (lhs -> array_access .)


state 91

    (92) primary -> literal .

    DOT             reduce using rule 92 (primary -> literal .)
    LPAREN          reduce using rule 92 (primary -> literal .)
    RPAREN          reduce using rule 92 (primary -> literal .)
    PLUS            reduce using rule 92 (primary -> literal .)
    MINUS           reduce using rule 92 (primary -> literal .)
    MULT            reduce using rule 92 (primary -> literal .)
    DIV             reduce using rule 92 (primary -> literal .)
    OR              reduce using rule 92 (primary -> literal .)
    AND             reduce using rule 92 (primary -> literal .)
    EQUALS          reduce using rule 92 (primary -> literal .)
    NOTEQUALS       reduce using rule 92 (primary -> literal .)
    LT              reduce using rule 92 (primary -> literal .)
    GT              reduce using rule 92 (primary -> literal .)
    LEQ             reduce using rule 92 (primary -> literal .)
    GEQ             reduce using rule 92 (primary -> literal .)
    SEMICOLON       reduce using rule 92 (primary -> literal .)
    RSQUARE         reduce using rule 92 (primary -> literal .)


state 92

    (73) expr -> PLUS . expr
    (58) expr -> . primary
    (59) expr -> . assign
    (60) expr -> . new_array
    (61) expr -> . expr PLUS expr
    (62) expr -> . expr MINUS expr
    (63) expr -> . expr MULT expr
    (64) expr -> . expr DIV expr
    (65) expr -> . expr OR expr
    (66) expr -> . expr AND expr
    (67) expr -> . expr EQUALS expr
    (68) expr -> . expr NOTEQUALS expr
    (69) expr -> . expr LT expr
    (70) expr -> . expr GT expr
    (71) expr -> . expr LEQ expr
    (72) expr -> . expr GEQ expr
    (73) expr -> . PLUS expr
    (74) expr -> . MINUS expr
    (75) expr -> . NOT expr
    (92) primary -> . literal
    (93) primary -> . THIS
    (94) primary -> . SUPER
    (95) primary -> . LPAREN expr RPAREN
    (96) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (97) primary -> . lhs
    (98) primary -> . method_invocation
    (76) assign -> . lhs ASSIGN expr
    (77) assign -> . lhs PLUSPLUS
    (78) assign -> . PLUSPLUS lhs
    (79) assign -> . lhs MINUSMINUS
    (80) assign -> . MINUSMINUS lhs
    (81) new_array -> . NEW type expr_array_helper1 expr_array_helper2
    (87) literal -> . INTEGERCONSTANT
    (88) literal -> . FLOATCONSTANT
    (89) literal -> . NULL
    (90) literal -> . TRUE
    (91) literal -> . FALSE
    (101) lhs -> . field_access
    (102) lhs -> . array_access
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN expr RPAREN
    (105) field_access -> . primary DOT IDENTIFIER
    (106) field_access -> . IDENTIFIER
    (107) array_access -> . primary LPAREN expr RPAREN

    PLUS            shift and go to state 92
    MINUS           shift and go to state 88
    NOT             shift and go to state 104
    THIS            shift and go to state 101
    SUPER           shift and go to state 105
    LPAREN          shift and go to state 97
    NEW             shift and go to state 85
    PLUSPLUS        shift and go to state 96
    MINUSMINUS      shift and go to state 98
    INTEGERCONSTANT shift and go to state 84
    FLOATCONSTANT   shift and go to state 99
    NULL            shift and go to state 86
    TRUE            shift and go to state 87
    FALSE           shift and go to state 100
    IDENTIFIER      shift and go to state 94

    new_array                      shift and go to state 82
    field_access                   shift and go to state 95
    expr                           shift and go to state 121
    primary                        shift and go to state 83
    array_access                   shift and go to state 90
    literal                        shift and go to state 91
    lhs                            shift and go to state 103
    method_invocation              shift and go to state 93
    assign                         shift and go to state 106

state 93

    (98) primary -> method_invocation .

    DOT             reduce using rule 98 (primary -> method_invocation .)
    LPAREN          reduce using rule 98 (primary -> method_invocation .)
    RPAREN          reduce using rule 98 (primary -> method_invocation .)
    PLUS            reduce using rule 98 (primary -> method_invocation .)
    MINUS           reduce using rule 98 (primary -> method_invocation .)
    MULT            reduce using rule 98 (primary -> method_invocation .)
    DIV             reduce using rule 98 (primary -> method_invocation .)
    OR              reduce using rule 98 (primary -> method_invocation .)
    AND             reduce using rule 98 (primary -> method_invocation .)
    EQUALS          reduce using rule 98 (primary -> method_invocation .)
    NOTEQUALS       reduce using rule 98 (primary -> method_invocation .)
    LT              reduce using rule 98 (primary -> method_invocation .)
    GT              reduce using rule 98 (primary -> method_invocation .)
    LEQ             reduce using rule 98 (primary -> method_invocation .)
    GEQ             reduce using rule 98 (primary -> method_invocation .)
    SEMICOLON       reduce using rule 98 (primary -> method_invocation .)
    RSQUARE         reduce using rule 98 (primary -> method_invocation .)


state 94

    (106) field_access -> IDENTIFIER .

    LPAREN          reduce using rule 106 (field_access -> IDENTIFIER .)
    ASSIGN          reduce using rule 106 (field_access -> IDENTIFIER .)
    PLUSPLUS        reduce using rule 106 (field_access -> IDENTIFIER .)
    MINUSMINUS      reduce using rule 106 (field_access -> IDENTIFIER .)
    DOT             reduce using rule 106 (field_access -> IDENTIFIER .)
    PLUS            reduce using rule 106 (field_access -> IDENTIFIER .)
    MINUS           reduce using rule 106 (field_access -> IDENTIFIER .)
    MULT            reduce using rule 106 (field_access -> IDENTIFIER .)
    DIV             reduce using rule 106 (field_access -> IDENTIFIER .)
    OR              reduce using rule 106 (field_access -> IDENTIFIER .)
    AND             reduce using rule 106 (field_access -> IDENTIFIER .)
    EQUALS          reduce using rule 106 (field_access -> IDENTIFIER .)
    NOTEQUALS       reduce using rule 106 (field_access -> IDENTIFIER .)
    LT              reduce using rule 106 (field_access -> IDENTIFIER .)
    GT              reduce using rule 106 (field_access -> IDENTIFIER .)
    LEQ             reduce using rule 106 (field_access -> IDENTIFIER .)
    GEQ             reduce using rule 106 (field_access -> IDENTIFIER .)
    SEMICOLON       reduce using rule 106 (field_access -> IDENTIFIER .)
    RPAREN          reduce using rule 106 (field_access -> IDENTIFIER .)
    RSQUARE         reduce using rule 106 (field_access -> IDENTIFIER .)


state 95

    (101) lhs -> field_access .
    (103) method_invocation -> field_access . LPAREN RPAREN
    (104) method_invocation -> field_access . LPAREN expr RPAREN

  ! shift/reduce conflict for LPAREN resolved as shift
    ASSIGN          reduce using rule 101 (lhs -> field_access .)
    PLUSPLUS        reduce using rule 101 (lhs -> field_access .)
    MINUSMINUS      reduce using rule 101 (lhs -> field_access .)
    DOT             reduce using rule 101 (lhs -> field_access .)
    PLUS            reduce using rule 101 (lhs -> field_access .)
    MINUS           reduce using rule 101 (lhs -> field_access .)
    MULT            reduce using rule 101 (lhs -> field_access .)
    DIV             reduce using rule 101 (lhs -> field_access .)
    OR              reduce using rule 101 (lhs -> field_access .)
    AND             reduce using rule 101 (lhs -> field_access .)
    EQUALS          reduce using rule 101 (lhs -> field_access .)
    NOTEQUALS       reduce using rule 101 (lhs -> field_access .)
    LT              reduce using rule 101 (lhs -> field_access .)
    GT              reduce using rule 101 (lhs -> field_access .)
    LEQ             reduce using rule 101 (lhs -> field_access .)
    GEQ             reduce using rule 101 (lhs -> field_access .)
    SEMICOLON       reduce using rule 101 (lhs -> field_access .)
    RPAREN          reduce using rule 101 (lhs -> field_access .)
    RSQUARE         reduce using rule 101 (lhs -> field_access .)
    LPAREN          shift and go to state 122

  ! LPAREN          [ reduce using rule 101 (lhs -> field_access .) ]


state 96

    (78) assign -> PLUSPLUS . lhs
    (101) lhs -> . field_access
    (102) lhs -> . array_access
    (105) field_access -> . primary DOT IDENTIFIER
    (106) field_access -> . IDENTIFIER
    (107) array_access -> . primary LPAREN expr RPAREN
    (92) primary -> . literal
    (93) primary -> . THIS
    (94) primary -> . SUPER
    (95) primary -> . LPAREN expr RPAREN
    (96) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (97) primary -> . lhs
    (98) primary -> . method_invocation
    (87) literal -> . INTEGERCONSTANT
    (88) literal -> . FLOATCONSTANT
    (89) literal -> . NULL
    (90) literal -> . TRUE
    (91) literal -> . FALSE
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN expr RPAREN

    IDENTIFIER      shift and go to state 94
    THIS            shift and go to state 101
    SUPER           shift and go to state 105
    LPAREN          shift and go to state 97
    NEW             shift and go to state 125
    INTEGERCONSTANT shift and go to state 84
    FLOATCONSTANT   shift and go to state 99
    NULL            shift and go to state 86
    TRUE            shift and go to state 87
    FALSE           shift and go to state 100

    field_access                   shift and go to state 95
    primary                        shift and go to state 123
    literal                        shift and go to state 91
    lhs                            shift and go to state 124
    method_invocation              shift and go to state 93
    array_access                   shift and go to state 90

state 97

    (95) primary -> LPAREN . expr RPAREN
    (58) expr -> . primary
    (59) expr -> . assign
    (60) expr -> . new_array
    (61) expr -> . expr PLUS expr
    (62) expr -> . expr MINUS expr
    (63) expr -> . expr MULT expr
    (64) expr -> . expr DIV expr
    (65) expr -> . expr OR expr
    (66) expr -> . expr AND expr
    (67) expr -> . expr EQUALS expr
    (68) expr -> . expr NOTEQUALS expr
    (69) expr -> . expr LT expr
    (70) expr -> . expr GT expr
    (71) expr -> . expr LEQ expr
    (72) expr -> . expr GEQ expr
    (73) expr -> . PLUS expr
    (74) expr -> . MINUS expr
    (75) expr -> . NOT expr
    (92) primary -> . literal
    (93) primary -> . THIS
    (94) primary -> . SUPER
    (95) primary -> . LPAREN expr RPAREN
    (96) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (97) primary -> . lhs
    (98) primary -> . method_invocation
    (76) assign -> . lhs ASSIGN expr
    (77) assign -> . lhs PLUSPLUS
    (78) assign -> . PLUSPLUS lhs
    (79) assign -> . lhs MINUSMINUS
    (80) assign -> . MINUSMINUS lhs
    (81) new_array -> . NEW type expr_array_helper1 expr_array_helper2
    (87) literal -> . INTEGERCONSTANT
    (88) literal -> . FLOATCONSTANT
    (89) literal -> . NULL
    (90) literal -> . TRUE
    (91) literal -> . FALSE
    (101) lhs -> . field_access
    (102) lhs -> . array_access
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN expr RPAREN
    (105) field_access -> . primary DOT IDENTIFIER
    (106) field_access -> . IDENTIFIER
    (107) array_access -> . primary LPAREN expr RPAREN

    PLUS            shift and go to state 92
    MINUS           shift and go to state 88
    NOT             shift and go to state 104
    THIS            shift and go to state 101
    SUPER           shift and go to state 105
    LPAREN          shift and go to state 97
    NEW             shift and go to state 85
    PLUSPLUS        shift and go to state 96
    MINUSMINUS      shift and go to state 98
    INTEGERCONSTANT shift and go to state 84
    FLOATCONSTANT   shift and go to state 99
    NULL            shift and go to state 86
    TRUE            shift and go to state 87
    FALSE           shift and go to state 100
    IDENTIFIER      shift and go to state 94

    new_array                      shift and go to state 82
    field_access                   shift and go to state 95
    expr                           shift and go to state 126
    primary                        shift and go to state 83
    array_access                   shift and go to state 90
    literal                        shift and go to state 91
    lhs                            shift and go to state 103
    method_invocation              shift and go to state 93
    assign                         shift and go to state 106

state 98

    (80) assign -> MINUSMINUS . lhs
    (101) lhs -> . field_access
    (102) lhs -> . array_access
    (105) field_access -> . primary DOT IDENTIFIER
    (106) field_access -> . IDENTIFIER
    (107) array_access -> . primary LPAREN expr RPAREN
    (92) primary -> . literal
    (93) primary -> . THIS
    (94) primary -> . SUPER
    (95) primary -> . LPAREN expr RPAREN
    (96) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (97) primary -> . lhs
    (98) primary -> . method_invocation
    (87) literal -> . INTEGERCONSTANT
    (88) literal -> . FLOATCONSTANT
    (89) literal -> . NULL
    (90) literal -> . TRUE
    (91) literal -> . FALSE
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN expr RPAREN

    IDENTIFIER      shift and go to state 94
    THIS            shift and go to state 101
    SUPER           shift and go to state 105
    LPAREN          shift and go to state 97
    NEW             shift and go to state 125
    INTEGERCONSTANT shift and go to state 84
    FLOATCONSTANT   shift and go to state 99
    NULL            shift and go to state 86
    TRUE            shift and go to state 87
    FALSE           shift and go to state 100

    field_access                   shift and go to state 95
    primary                        shift and go to state 123
    literal                        shift and go to state 91
    lhs                            shift and go to state 127
    method_invocation              shift and go to state 93
    array_access                   shift and go to state 90

state 99

    (88) literal -> FLOATCONSTANT .

    DOT             reduce using rule 88 (literal -> FLOATCONSTANT .)
    LPAREN          reduce using rule 88 (literal -> FLOATCONSTANT .)
    PLUS            reduce using rule 88 (literal -> FLOATCONSTANT .)
    MINUS           reduce using rule 88 (literal -> FLOATCONSTANT .)
    MULT            reduce using rule 88 (literal -> FLOATCONSTANT .)
    DIV             reduce using rule 88 (literal -> FLOATCONSTANT .)
    OR              reduce using rule 88 (literal -> FLOATCONSTANT .)
    AND             reduce using rule 88 (literal -> FLOATCONSTANT .)
    EQUALS          reduce using rule 88 (literal -> FLOATCONSTANT .)
    NOTEQUALS       reduce using rule 88 (literal -> FLOATCONSTANT .)
    LT              reduce using rule 88 (literal -> FLOATCONSTANT .)
    GT              reduce using rule 88 (literal -> FLOATCONSTANT .)
    LEQ             reduce using rule 88 (literal -> FLOATCONSTANT .)
    GEQ             reduce using rule 88 (literal -> FLOATCONSTANT .)
    SEMICOLON       reduce using rule 88 (literal -> FLOATCONSTANT .)
    RPAREN          reduce using rule 88 (literal -> FLOATCONSTANT .)
    RSQUARE         reduce using rule 88 (literal -> FLOATCONSTANT .)


state 100

    (91) literal -> FALSE .

    DOT             reduce using rule 91 (literal -> FALSE .)
    LPAREN          reduce using rule 91 (literal -> FALSE .)
    PLUS            reduce using rule 91 (literal -> FALSE .)
    MINUS           reduce using rule 91 (literal -> FALSE .)
    MULT            reduce using rule 91 (literal -> FALSE .)
    DIV             reduce using rule 91 (literal -> FALSE .)
    OR              reduce using rule 91 (literal -> FALSE .)
    AND             reduce using rule 91 (literal -> FALSE .)
    EQUALS          reduce using rule 91 (literal -> FALSE .)
    NOTEQUALS       reduce using rule 91 (literal -> FALSE .)
    LT              reduce using rule 91 (literal -> FALSE .)
    GT              reduce using rule 91 (literal -> FALSE .)
    LEQ             reduce using rule 91 (literal -> FALSE .)
    GEQ             reduce using rule 91 (literal -> FALSE .)
    SEMICOLON       reduce using rule 91 (literal -> FALSE .)
    RPAREN          reduce using rule 91 (literal -> FALSE .)
    RSQUARE         reduce using rule 91 (literal -> FALSE .)


state 101

    (93) primary -> THIS .

    DOT             reduce using rule 93 (primary -> THIS .)
    LPAREN          reduce using rule 93 (primary -> THIS .)
    RPAREN          reduce using rule 93 (primary -> THIS .)
    PLUS            reduce using rule 93 (primary -> THIS .)
    MINUS           reduce using rule 93 (primary -> THIS .)
    MULT            reduce using rule 93 (primary -> THIS .)
    DIV             reduce using rule 93 (primary -> THIS .)
    OR              reduce using rule 93 (primary -> THIS .)
    AND             reduce using rule 93 (primary -> THIS .)
    EQUALS          reduce using rule 93 (primary -> THIS .)
    NOTEQUALS       reduce using rule 93 (primary -> THIS .)
    LT              reduce using rule 93 (primary -> THIS .)
    GT              reduce using rule 93 (primary -> THIS .)
    LEQ             reduce using rule 93 (primary -> THIS .)
    GEQ             reduce using rule 93 (primary -> THIS .)
    SEMICOLON       reduce using rule 93 (primary -> THIS .)
    RSQUARE         reduce using rule 93 (primary -> THIS .)


state 102

    (51) stmt -> RETURN expr . SEMICOLON
    (61) expr -> expr . PLUS expr
    (62) expr -> expr . MINUS expr
    (63) expr -> expr . MULT expr
    (64) expr -> expr . DIV expr
    (65) expr -> expr . OR expr
    (66) expr -> expr . AND expr
    (67) expr -> expr . EQUALS expr
    (68) expr -> expr . NOTEQUALS expr
    (69) expr -> expr . LT expr
    (70) expr -> expr . GT expr
    (71) expr -> expr . LEQ expr
    (72) expr -> expr . GEQ expr

    SEMICOLON       shift and go to state 132
    PLUS            shift and go to state 137
    MINUS           shift and go to state 139
    MULT            shift and go to state 140
    DIV             shift and go to state 138
    OR              shift and go to state 134
    AND             shift and go to state 128
    EQUALS          shift and go to state 133
    NOTEQUALS       shift and go to state 129
    LT              shift and go to state 136
    GT              shift and go to state 131
    LEQ             shift and go to state 135
    GEQ             shift and go to state 130


state 103

    (97) primary -> lhs .
    (76) assign -> lhs . ASSIGN expr
    (77) assign -> lhs . PLUSPLUS
    (79) assign -> lhs . MINUSMINUS

    DOT             reduce using rule 97 (primary -> lhs .)
    LPAREN          reduce using rule 97 (primary -> lhs .)
    RPAREN          reduce using rule 97 (primary -> lhs .)
    PLUS            reduce using rule 97 (primary -> lhs .)
    MINUS           reduce using rule 97 (primary -> lhs .)
    MULT            reduce using rule 97 (primary -> lhs .)
    DIV             reduce using rule 97 (primary -> lhs .)
    OR              reduce using rule 97 (primary -> lhs .)
    AND             reduce using rule 97 (primary -> lhs .)
    EQUALS          reduce using rule 97 (primary -> lhs .)
    NOTEQUALS       reduce using rule 97 (primary -> lhs .)
    LT              reduce using rule 97 (primary -> lhs .)
    GT              reduce using rule 97 (primary -> lhs .)
    LEQ             reduce using rule 97 (primary -> lhs .)
    GEQ             reduce using rule 97 (primary -> lhs .)
    SEMICOLON       reduce using rule 97 (primary -> lhs .)
    RSQUARE         reduce using rule 97 (primary -> lhs .)
    ASSIGN          shift and go to state 143
    PLUSPLUS        shift and go to state 141
    MINUSMINUS      shift and go to state 142


state 104

    (75) expr -> NOT . expr
    (58) expr -> . primary
    (59) expr -> . assign
    (60) expr -> . new_array
    (61) expr -> . expr PLUS expr
    (62) expr -> . expr MINUS expr
    (63) expr -> . expr MULT expr
    (64) expr -> . expr DIV expr
    (65) expr -> . expr OR expr
    (66) expr -> . expr AND expr
    (67) expr -> . expr EQUALS expr
    (68) expr -> . expr NOTEQUALS expr
    (69) expr -> . expr LT expr
    (70) expr -> . expr GT expr
    (71) expr -> . expr LEQ expr
    (72) expr -> . expr GEQ expr
    (73) expr -> . PLUS expr
    (74) expr -> . MINUS expr
    (75) expr -> . NOT expr
    (92) primary -> . literal
    (93) primary -> . THIS
    (94) primary -> . SUPER
    (95) primary -> . LPAREN expr RPAREN
    (96) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (97) primary -> . lhs
    (98) primary -> . method_invocation
    (76) assign -> . lhs ASSIGN expr
    (77) assign -> . lhs PLUSPLUS
    (78) assign -> . PLUSPLUS lhs
    (79) assign -> . lhs MINUSMINUS
    (80) assign -> . MINUSMINUS lhs
    (81) new_array -> . NEW type expr_array_helper1 expr_array_helper2
    (87) literal -> . INTEGERCONSTANT
    (88) literal -> . FLOATCONSTANT
    (89) literal -> . NULL
    (90) literal -> . TRUE
    (91) literal -> . FALSE
    (101) lhs -> . field_access
    (102) lhs -> . array_access
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN expr RPAREN
    (105) field_access -> . primary DOT IDENTIFIER
    (106) field_access -> . IDENTIFIER
    (107) array_access -> . primary LPAREN expr RPAREN

    PLUS            shift and go to state 92
    MINUS           shift and go to state 88
    NOT             shift and go to state 104
    THIS            shift and go to state 101
    SUPER           shift and go to state 105
    LPAREN          shift and go to state 97
    NEW             shift and go to state 85
    PLUSPLUS        shift and go to state 96
    MINUSMINUS      shift and go to state 98
    INTEGERCONSTANT shift and go to state 84
    FLOATCONSTANT   shift and go to state 99
    NULL            shift and go to state 86
    TRUE            shift and go to state 87
    FALSE           shift and go to state 100
    IDENTIFIER      shift and go to state 94

    new_array                      shift and go to state 82
    field_access                   shift and go to state 95
    expr                           shift and go to state 144
    primary                        shift and go to state 83
    array_access                   shift and go to state 90
    literal                        shift and go to state 91
    lhs                            shift and go to state 103
    method_invocation              shift and go to state 93
    assign                         shift and go to state 106

state 105

    (94) primary -> SUPER .

    DOT             reduce using rule 94 (primary -> SUPER .)
    LPAREN          reduce using rule 94 (primary -> SUPER .)
    RPAREN          reduce using rule 94 (primary -> SUPER .)
    PLUS            reduce using rule 94 (primary -> SUPER .)
    MINUS           reduce using rule 94 (primary -> SUPER .)
    MULT            reduce using rule 94 (primary -> SUPER .)
    DIV             reduce using rule 94 (primary -> SUPER .)
    OR              reduce using rule 94 (primary -> SUPER .)
    AND             reduce using rule 94 (primary -> SUPER .)
    EQUALS          reduce using rule 94 (primary -> SUPER .)
    NOTEQUALS       reduce using rule 94 (primary -> SUPER .)
    LT              reduce using rule 94 (primary -> SUPER .)
    GT              reduce using rule 94 (primary -> SUPER .)
    LEQ             reduce using rule 94 (primary -> SUPER .)
    GEQ             reduce using rule 94 (primary -> SUPER .)
    SEMICOLON       reduce using rule 94 (primary -> SUPER .)
    RSQUARE         reduce using rule 94 (primary -> SUPER .)


state 106

    (59) expr -> assign .

    RPAREN          reduce using rule 59 (expr -> assign .)
    PLUS            reduce using rule 59 (expr -> assign .)
    MINUS           reduce using rule 59 (expr -> assign .)
    MULT            reduce using rule 59 (expr -> assign .)
    DIV             reduce using rule 59 (expr -> assign .)
    OR              reduce using rule 59 (expr -> assign .)
    AND             reduce using rule 59 (expr -> assign .)
    EQUALS          reduce using rule 59 (expr -> assign .)
    NOTEQUALS       reduce using rule 59 (expr -> assign .)
    LT              reduce using rule 59 (expr -> assign .)
    GT              reduce using rule 59 (expr -> assign .)
    LEQ             reduce using rule 59 (expr -> assign .)
    GEQ             reduce using rule 59 (expr -> assign .)
    SEMICOLON       reduce using rule 59 (expr -> assign .)
    RSQUARE         reduce using rule 59 (expr -> assign .)


state 107

    (41) stmt -> WHILE LPAREN . expr RPAREN stmt
    (58) expr -> . primary
    (59) expr -> . assign
    (60) expr -> . new_array
    (61) expr -> . expr PLUS expr
    (62) expr -> . expr MINUS expr
    (63) expr -> . expr MULT expr
    (64) expr -> . expr DIV expr
    (65) expr -> . expr OR expr
    (66) expr -> . expr AND expr
    (67) expr -> . expr EQUALS expr
    (68) expr -> . expr NOTEQUALS expr
    (69) expr -> . expr LT expr
    (70) expr -> . expr GT expr
    (71) expr -> . expr LEQ expr
    (72) expr -> . expr GEQ expr
    (73) expr -> . PLUS expr
    (74) expr -> . MINUS expr
    (75) expr -> . NOT expr
    (92) primary -> . literal
    (93) primary -> . THIS
    (94) primary -> . SUPER
    (95) primary -> . LPAREN expr RPAREN
    (96) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (97) primary -> . lhs
    (98) primary -> . method_invocation
    (76) assign -> . lhs ASSIGN expr
    (77) assign -> . lhs PLUSPLUS
    (78) assign -> . PLUSPLUS lhs
    (79) assign -> . lhs MINUSMINUS
    (80) assign -> . MINUSMINUS lhs
    (81) new_array -> . NEW type expr_array_helper1 expr_array_helper2
    (87) literal -> . INTEGERCONSTANT
    (88) literal -> . FLOATCONSTANT
    (89) literal -> . NULL
    (90) literal -> . TRUE
    (91) literal -> . FALSE
    (101) lhs -> . field_access
    (102) lhs -> . array_access
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN expr RPAREN
    (105) field_access -> . primary DOT IDENTIFIER
    (106) field_access -> . IDENTIFIER
    (107) array_access -> . primary LPAREN expr RPAREN

    PLUS            shift and go to state 92
    MINUS           shift and go to state 88
    NOT             shift and go to state 104
    THIS            shift and go to state 101
    SUPER           shift and go to state 105
    LPAREN          shift and go to state 97
    NEW             shift and go to state 85
    PLUSPLUS        shift and go to state 96
    MINUSMINUS      shift and go to state 98
    INTEGERCONSTANT shift and go to state 84
    FLOATCONSTANT   shift and go to state 99
    NULL            shift and go to state 86
    TRUE            shift and go to state 87
    FALSE           shift and go to state 100
    IDENTIFIER      shift and go to state 94

    new_array                      shift and go to state 82
    field_access                   shift and go to state 95
    expr                           shift and go to state 145
    primary                        shift and go to state 83
    literal                        shift and go to state 91
    array_access                   shift and go to state 90
    lhs                            shift and go to state 103
    method_invocation              shift and go to state 93
    assign                         shift and go to state 106

state 108

    (52) stmt -> stmt_expr SEMICOLON .

    IF              reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)
    WHILE           reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)
    FOR             reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)
    RETURN          reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)
    BREAK           reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)
    CONTINUE        reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)
    SEMICOLON       reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)
    LCURLY          reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)
    INT             reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)
    FLOAT           reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)
    BOOLEAN         reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)
    IDENTIFIER      reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)
    RCURLY          reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)
    ELSE            reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)


state 109

    (42) stmt -> FOR LPAREN . SEMICOLON SEMICOLON RPAREN stmt
    (43) stmt -> FOR LPAREN . stmt_expr SEMICOLON SEMICOLON RPAREN stmt
    (44) stmt -> FOR LPAREN . stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt
    (45) stmt -> FOR LPAREN . stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt
    (46) stmt -> FOR LPAREN . stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (47) stmt -> FOR LPAREN . SEMICOLON expr SEMICOLON RPAREN stmt
    (48) stmt -> FOR LPAREN . SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (49) stmt -> FOR LPAREN . SEMICOLON SEMICOLON stmt_expr RPAREN stmt
    (86) stmt_expr -> . empty
    (108) empty -> .

  ! shift/reduce conflict for SEMICOLON resolved as shift
    SEMICOLON       shift and go to state 146

  ! SEMICOLON       [ reduce using rule 108 (empty -> .) ]

    stmt_expr                      shift and go to state 147
    empty                          shift and go to state 67

state 110

    (38) stmthelper -> stmt stmthelper .

    RCURLY          reduce using rule 38 (stmthelper -> stmt stmthelper .)


state 111

    (39) stmt -> IF LPAREN . expr RPAREN stmt
    (40) stmt -> IF LPAREN . expr RPAREN stmt ELSE stmt
    (58) expr -> . primary
    (59) expr -> . assign
    (60) expr -> . new_array
    (61) expr -> . expr PLUS expr
    (62) expr -> . expr MINUS expr
    (63) expr -> . expr MULT expr
    (64) expr -> . expr DIV expr
    (65) expr -> . expr OR expr
    (66) expr -> . expr AND expr
    (67) expr -> . expr EQUALS expr
    (68) expr -> . expr NOTEQUALS expr
    (69) expr -> . expr LT expr
    (70) expr -> . expr GT expr
    (71) expr -> . expr LEQ expr
    (72) expr -> . expr GEQ expr
    (73) expr -> . PLUS expr
    (74) expr -> . MINUS expr
    (75) expr -> . NOT expr
    (92) primary -> . literal
    (93) primary -> . THIS
    (94) primary -> . SUPER
    (95) primary -> . LPAREN expr RPAREN
    (96) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (97) primary -> . lhs
    (98) primary -> . method_invocation
    (76) assign -> . lhs ASSIGN expr
    (77) assign -> . lhs PLUSPLUS
    (78) assign -> . PLUSPLUS lhs
    (79) assign -> . lhs MINUSMINUS
    (80) assign -> . MINUSMINUS lhs
    (81) new_array -> . NEW type expr_array_helper1 expr_array_helper2
    (87) literal -> . INTEGERCONSTANT
    (88) literal -> . FLOATCONSTANT
    (89) literal -> . NULL
    (90) literal -> . TRUE
    (91) literal -> . FALSE
    (101) lhs -> . field_access
    (102) lhs -> . array_access
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN expr RPAREN
    (105) field_access -> . primary DOT IDENTIFIER
    (106) field_access -> . IDENTIFIER
    (107) array_access -> . primary LPAREN expr RPAREN

    PLUS            shift and go to state 92
    MINUS           shift and go to state 88
    NOT             shift and go to state 104
    THIS            shift and go to state 101
    SUPER           shift and go to state 105
    LPAREN          shift and go to state 97
    NEW             shift and go to state 85
    PLUSPLUS        shift and go to state 96
    MINUSMINUS      shift and go to state 98
    INTEGERCONSTANT shift and go to state 84
    FLOATCONSTANT   shift and go to state 99
    NULL            shift and go to state 86
    TRUE            shift and go to state 87
    FALSE           shift and go to state 100
    IDENTIFIER      shift and go to state 94

    new_array                      shift and go to state 82
    field_access                   shift and go to state 95
    expr                           shift and go to state 148
    primary                        shift and go to state 83
    literal                        shift and go to state 91
    array_access                   shift and go to state 90
    lhs                            shift and go to state 103
    method_invocation              shift and go to state 93
    assign                         shift and go to state 106

state 112

    (35) block -> LCURLY stmthelper RCURLY .

    IF              reduce using rule 35 (block -> LCURLY stmthelper RCURLY .)
    WHILE           reduce using rule 35 (block -> LCURLY stmthelper RCURLY .)
    FOR             reduce using rule 35 (block -> LCURLY stmthelper RCURLY .)
    RETURN          reduce using rule 35 (block -> LCURLY stmthelper RCURLY .)
    BREAK           reduce using rule 35 (block -> LCURLY stmthelper RCURLY .)
    CONTINUE        reduce using rule 35 (block -> LCURLY stmthelper RCURLY .)
    SEMICOLON       reduce using rule 35 (block -> LCURLY stmthelper RCURLY .)
    LCURLY          reduce using rule 35 (block -> LCURLY stmthelper RCURLY .)
    INT             reduce using rule 35 (block -> LCURLY stmthelper RCURLY .)
    FLOAT           reduce using rule 35 (block -> LCURLY stmthelper RCURLY .)
    BOOLEAN         reduce using rule 35 (block -> LCURLY stmthelper RCURLY .)
    IDENTIFIER      reduce using rule 35 (block -> LCURLY stmthelper RCURLY .)
    RCURLY          reduce using rule 35 (block -> LCURLY stmthelper RCURLY .)
    ELSE            reduce using rule 35 (block -> LCURLY stmthelper RCURLY .)
    PUBLIC          reduce using rule 35 (block -> LCURLY stmthelper RCURLY .)
    PRIVATE         reduce using rule 35 (block -> LCURLY stmthelper RCURLY .)
    STATIC          reduce using rule 35 (block -> LCURLY stmthelper RCURLY .)
    VOID            reduce using rule 35 (block -> LCURLY stmthelper RCURLY .)


state 113

    (53) stmt -> BREAK SEMICOLON .

    IF              reduce using rule 53 (stmt -> BREAK SEMICOLON .)
    WHILE           reduce using rule 53 (stmt -> BREAK SEMICOLON .)
    FOR             reduce using rule 53 (stmt -> BREAK SEMICOLON .)
    RETURN          reduce using rule 53 (stmt -> BREAK SEMICOLON .)
    BREAK           reduce using rule 53 (stmt -> BREAK SEMICOLON .)
    CONTINUE        reduce using rule 53 (stmt -> BREAK SEMICOLON .)
    SEMICOLON       reduce using rule 53 (stmt -> BREAK SEMICOLON .)
    LCURLY          reduce using rule 53 (stmt -> BREAK SEMICOLON .)
    INT             reduce using rule 53 (stmt -> BREAK SEMICOLON .)
    FLOAT           reduce using rule 53 (stmt -> BREAK SEMICOLON .)
    BOOLEAN         reduce using rule 53 (stmt -> BREAK SEMICOLON .)
    IDENTIFIER      reduce using rule 53 (stmt -> BREAK SEMICOLON .)
    RCURLY          reduce using rule 53 (stmt -> BREAK SEMICOLON .)
    ELSE            reduce using rule 53 (stmt -> BREAK SEMICOLON .)


state 114

    (54) stmt -> CONTINUE SEMICOLON .

    IF              reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)
    WHILE           reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)
    FOR             reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)
    RETURN          reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)
    BREAK           reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)
    CONTINUE        reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)
    SEMICOLON       reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)
    LCURLY          reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)
    INT             reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)
    FLOAT           reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)
    BOOLEAN         reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)
    IDENTIFIER      reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)
    RCURLY          reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)
    ELSE            reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)


state 115

    (27) method_decl -> modifier type IDENTIFIER LPAREN formals RPAREN block .

    PUBLIC          reduce using rule 27 (method_decl -> modifier type IDENTIFIER LPAREN formals RPAREN block .)
    PRIVATE         reduce using rule 27 (method_decl -> modifier type IDENTIFIER LPAREN formals RPAREN block .)
    STATIC          reduce using rule 27 (method_decl -> modifier type IDENTIFIER LPAREN formals RPAREN block .)
    VOID            reduce using rule 27 (method_decl -> modifier type IDENTIFIER LPAREN formals RPAREN block .)
    IDENTIFIER      reduce using rule 27 (method_decl -> modifier type IDENTIFIER LPAREN formals RPAREN block .)
    INT             reduce using rule 27 (method_decl -> modifier type IDENTIFIER LPAREN formals RPAREN block .)
    FLOAT           reduce using rule 27 (method_decl -> modifier type IDENTIFIER LPAREN formals RPAREN block .)
    BOOLEAN         reduce using rule 27 (method_decl -> modifier type IDENTIFIER LPAREN formals RPAREN block .)
    RCURLY          reduce using rule 27 (method_decl -> modifier type IDENTIFIER LPAREN formals RPAREN block .)


state 116

    (107) array_access -> primary LPAREN . expr RPAREN
    (58) expr -> . primary
    (59) expr -> . assign
    (60) expr -> . new_array
    (61) expr -> . expr PLUS expr
    (62) expr -> . expr MINUS expr
    (63) expr -> . expr MULT expr
    (64) expr -> . expr DIV expr
    (65) expr -> . expr OR expr
    (66) expr -> . expr AND expr
    (67) expr -> . expr EQUALS expr
    (68) expr -> . expr NOTEQUALS expr
    (69) expr -> . expr LT expr
    (70) expr -> . expr GT expr
    (71) expr -> . expr LEQ expr
    (72) expr -> . expr GEQ expr
    (73) expr -> . PLUS expr
    (74) expr -> . MINUS expr
    (75) expr -> . NOT expr
    (92) primary -> . literal
    (93) primary -> . THIS
    (94) primary -> . SUPER
    (95) primary -> . LPAREN expr RPAREN
    (96) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (97) primary -> . lhs
    (98) primary -> . method_invocation
    (76) assign -> . lhs ASSIGN expr
    (77) assign -> . lhs PLUSPLUS
    (78) assign -> . PLUSPLUS lhs
    (79) assign -> . lhs MINUSMINUS
    (80) assign -> . MINUSMINUS lhs
    (81) new_array -> . NEW type expr_array_helper1 expr_array_helper2
    (87) literal -> . INTEGERCONSTANT
    (88) literal -> . FLOATCONSTANT
    (89) literal -> . NULL
    (90) literal -> . TRUE
    (91) literal -> . FALSE
    (101) lhs -> . field_access
    (102) lhs -> . array_access
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN expr RPAREN
    (105) field_access -> . primary DOT IDENTIFIER
    (106) field_access -> . IDENTIFIER
    (107) array_access -> . primary LPAREN expr RPAREN

    PLUS            shift and go to state 92
    MINUS           shift and go to state 88
    NOT             shift and go to state 104
    THIS            shift and go to state 101
    SUPER           shift and go to state 105
    LPAREN          shift and go to state 97
    NEW             shift and go to state 85
    PLUSPLUS        shift and go to state 96
    MINUSMINUS      shift and go to state 98
    INTEGERCONSTANT shift and go to state 84
    FLOATCONSTANT   shift and go to state 99
    NULL            shift and go to state 86
    TRUE            shift and go to state 87
    FALSE           shift and go to state 100
    IDENTIFIER      shift and go to state 94

    new_array                      shift and go to state 82
    field_access                   shift and go to state 95
    expr                           shift and go to state 149
    primary                        shift and go to state 83
    array_access                   shift and go to state 90
    literal                        shift and go to state 91
    lhs                            shift and go to state 103
    method_invocation              shift and go to state 93
    assign                         shift and go to state 106

state 117

    (105) field_access -> primary DOT . IDENTIFIER

    IDENTIFIER      shift and go to state 150


state 118

    (96) primary -> NEW IDENTIFIER . LPAREN arguments RPAREN
    (19) type -> IDENTIFIER .

    LPAREN          shift and go to state 151
    LSQUARE         reduce using rule 19 (type -> IDENTIFIER .)


state 119

    (81) new_array -> NEW type . expr_array_helper1 expr_array_helper2
    (82) expr_array_helper1 -> . LSQUARE expr RSQUARE
    (83) expr_array_helper1 -> . LSQUARE expr RSQUARE expr_array_helper1

    LSQUARE         shift and go to state 152

    expr_array_helper1             shift and go to state 153

state 120

    (74) expr -> MINUS expr .
    (61) expr -> expr . PLUS expr
    (62) expr -> expr . MINUS expr
    (63) expr -> expr . MULT expr
    (64) expr -> expr . DIV expr
    (65) expr -> expr . OR expr
    (66) expr -> expr . AND expr
    (67) expr -> expr . EQUALS expr
    (68) expr -> expr . NOTEQUALS expr
    (69) expr -> expr . LT expr
    (70) expr -> expr . GT expr
    (71) expr -> expr . LEQ expr
    (72) expr -> expr . GEQ expr

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for NOTEQUALS resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LEQ resolved as shift
  ! shift/reduce conflict for GEQ resolved as shift
    RPAREN          reduce using rule 74 (expr -> MINUS expr .)
    SEMICOLON       reduce using rule 74 (expr -> MINUS expr .)
    RSQUARE         reduce using rule 74 (expr -> MINUS expr .)
    PLUS            shift and go to state 137
    MINUS           shift and go to state 139
    MULT            shift and go to state 140
    DIV             shift and go to state 138
    OR              shift and go to state 134
    AND             shift and go to state 128
    EQUALS          shift and go to state 133
    NOTEQUALS       shift and go to state 129
    LT              shift and go to state 136
    GT              shift and go to state 131
    LEQ             shift and go to state 135
    GEQ             shift and go to state 130

  ! PLUS            [ reduce using rule 74 (expr -> MINUS expr .) ]
  ! MINUS           [ reduce using rule 74 (expr -> MINUS expr .) ]
  ! MULT            [ reduce using rule 74 (expr -> MINUS expr .) ]
  ! DIV             [ reduce using rule 74 (expr -> MINUS expr .) ]
  ! OR              [ reduce using rule 74 (expr -> MINUS expr .) ]
  ! AND             [ reduce using rule 74 (expr -> MINUS expr .) ]
  ! EQUALS          [ reduce using rule 74 (expr -> MINUS expr .) ]
  ! NOTEQUALS       [ reduce using rule 74 (expr -> MINUS expr .) ]
  ! LT              [ reduce using rule 74 (expr -> MINUS expr .) ]
  ! GT              [ reduce using rule 74 (expr -> MINUS expr .) ]
  ! LEQ             [ reduce using rule 74 (expr -> MINUS expr .) ]
  ! GEQ             [ reduce using rule 74 (expr -> MINUS expr .) ]


state 121

    (73) expr -> PLUS expr .
    (61) expr -> expr . PLUS expr
    (62) expr -> expr . MINUS expr
    (63) expr -> expr . MULT expr
    (64) expr -> expr . DIV expr
    (65) expr -> expr . OR expr
    (66) expr -> expr . AND expr
    (67) expr -> expr . EQUALS expr
    (68) expr -> expr . NOTEQUALS expr
    (69) expr -> expr . LT expr
    (70) expr -> expr . GT expr
    (71) expr -> expr . LEQ expr
    (72) expr -> expr . GEQ expr

    RPAREN          reduce using rule 73 (expr -> PLUS expr .)
    PLUS            reduce using rule 73 (expr -> PLUS expr .)
    MINUS           reduce using rule 73 (expr -> PLUS expr .)
    OR              reduce using rule 73 (expr -> PLUS expr .)
    AND             reduce using rule 73 (expr -> PLUS expr .)
    EQUALS          reduce using rule 73 (expr -> PLUS expr .)
    NOTEQUALS       reduce using rule 73 (expr -> PLUS expr .)
    LT              reduce using rule 73 (expr -> PLUS expr .)
    GT              reduce using rule 73 (expr -> PLUS expr .)
    LEQ             reduce using rule 73 (expr -> PLUS expr .)
    GEQ             reduce using rule 73 (expr -> PLUS expr .)
    SEMICOLON       reduce using rule 73 (expr -> PLUS expr .)
    RSQUARE         reduce using rule 73 (expr -> PLUS expr .)
    MULT            shift and go to state 140
    DIV             shift and go to state 138

  ! MULT            [ reduce using rule 73 (expr -> PLUS expr .) ]
  ! DIV             [ reduce using rule 73 (expr -> PLUS expr .) ]
  ! PLUS            [ shift and go to state 137 ]
  ! MINUS           [ shift and go to state 139 ]
  ! OR              [ shift and go to state 134 ]
  ! AND             [ shift and go to state 128 ]
  ! EQUALS          [ shift and go to state 133 ]
  ! NOTEQUALS       [ shift and go to state 129 ]
  ! LT              [ shift and go to state 136 ]
  ! GT              [ shift and go to state 131 ]
  ! LEQ             [ shift and go to state 135 ]
  ! GEQ             [ shift and go to state 130 ]


state 122

    (103) method_invocation -> field_access LPAREN . RPAREN
    (104) method_invocation -> field_access LPAREN . expr RPAREN
    (58) expr -> . primary
    (59) expr -> . assign
    (60) expr -> . new_array
    (61) expr -> . expr PLUS expr
    (62) expr -> . expr MINUS expr
    (63) expr -> . expr MULT expr
    (64) expr -> . expr DIV expr
    (65) expr -> . expr OR expr
    (66) expr -> . expr AND expr
    (67) expr -> . expr EQUALS expr
    (68) expr -> . expr NOTEQUALS expr
    (69) expr -> . expr LT expr
    (70) expr -> . expr GT expr
    (71) expr -> . expr LEQ expr
    (72) expr -> . expr GEQ expr
    (73) expr -> . PLUS expr
    (74) expr -> . MINUS expr
    (75) expr -> . NOT expr
    (92) primary -> . literal
    (93) primary -> . THIS
    (94) primary -> . SUPER
    (95) primary -> . LPAREN expr RPAREN
    (96) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (97) primary -> . lhs
    (98) primary -> . method_invocation
    (76) assign -> . lhs ASSIGN expr
    (77) assign -> . lhs PLUSPLUS
    (78) assign -> . PLUSPLUS lhs
    (79) assign -> . lhs MINUSMINUS
    (80) assign -> . MINUSMINUS lhs
    (81) new_array -> . NEW type expr_array_helper1 expr_array_helper2
    (87) literal -> . INTEGERCONSTANT
    (88) literal -> . FLOATCONSTANT
    (89) literal -> . NULL
    (90) literal -> . TRUE
    (91) literal -> . FALSE
    (101) lhs -> . field_access
    (102) lhs -> . array_access
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN expr RPAREN
    (105) field_access -> . primary DOT IDENTIFIER
    (106) field_access -> . IDENTIFIER
    (107) array_access -> . primary LPAREN expr RPAREN

    RPAREN          shift and go to state 154
    PLUS            shift and go to state 92
    MINUS           shift and go to state 88
    NOT             shift and go to state 104
    THIS            shift and go to state 101
    SUPER           shift and go to state 105
    LPAREN          shift and go to state 97
    NEW             shift and go to state 85
    PLUSPLUS        shift and go to state 96
    MINUSMINUS      shift and go to state 98
    INTEGERCONSTANT shift and go to state 84
    FLOATCONSTANT   shift and go to state 99
    NULL            shift and go to state 86
    TRUE            shift and go to state 87
    FALSE           shift and go to state 100
    IDENTIFIER      shift and go to state 94

    field_access                   shift and go to state 95
    new_array                      shift and go to state 82
    expr                           shift and go to state 155
    primary                        shift and go to state 83
    array_access                   shift and go to state 90
    literal                        shift and go to state 91
    lhs                            shift and go to state 103
    method_invocation              shift and go to state 93
    assign                         shift and go to state 106

state 123

    (105) field_access -> primary . DOT IDENTIFIER
    (107) array_access -> primary . LPAREN expr RPAREN

    DOT             shift and go to state 117
    LPAREN          shift and go to state 116


state 124

    (78) assign -> PLUSPLUS lhs .
    (97) primary -> lhs .

    RSQUARE         reduce using rule 78 (assign -> PLUSPLUS lhs .)
    PLUS            reduce using rule 78 (assign -> PLUSPLUS lhs .)
    MINUS           reduce using rule 78 (assign -> PLUSPLUS lhs .)
    MULT            reduce using rule 78 (assign -> PLUSPLUS lhs .)
    DIV             reduce using rule 78 (assign -> PLUSPLUS lhs .)
    OR              reduce using rule 78 (assign -> PLUSPLUS lhs .)
    AND             reduce using rule 78 (assign -> PLUSPLUS lhs .)
    EQUALS          reduce using rule 78 (assign -> PLUSPLUS lhs .)
    NOTEQUALS       reduce using rule 78 (assign -> PLUSPLUS lhs .)
    LT              reduce using rule 78 (assign -> PLUSPLUS lhs .)
    GT              reduce using rule 78 (assign -> PLUSPLUS lhs .)
    LEQ             reduce using rule 78 (assign -> PLUSPLUS lhs .)
    GEQ             reduce using rule 78 (assign -> PLUSPLUS lhs .)
    RPAREN          reduce using rule 78 (assign -> PLUSPLUS lhs .)
    SEMICOLON       reduce using rule 78 (assign -> PLUSPLUS lhs .)
    DOT             reduce using rule 97 (primary -> lhs .)
    LPAREN          reduce using rule 97 (primary -> lhs .)


state 125

    (96) primary -> NEW . IDENTIFIER LPAREN arguments RPAREN

    IDENTIFIER      shift and go to state 156


state 126

    (95) primary -> LPAREN expr . RPAREN
    (61) expr -> expr . PLUS expr
    (62) expr -> expr . MINUS expr
    (63) expr -> expr . MULT expr
    (64) expr -> expr . DIV expr
    (65) expr -> expr . OR expr
    (66) expr -> expr . AND expr
    (67) expr -> expr . EQUALS expr
    (68) expr -> expr . NOTEQUALS expr
    (69) expr -> expr . LT expr
    (70) expr -> expr . GT expr
    (71) expr -> expr . LEQ expr
    (72) expr -> expr . GEQ expr

    RPAREN          shift and go to state 157
    PLUS            shift and go to state 137
    MINUS           shift and go to state 139
    MULT            shift and go to state 140
    DIV             shift and go to state 138
    OR              shift and go to state 134
    AND             shift and go to state 128
    EQUALS          shift and go to state 133
    NOTEQUALS       shift and go to state 129
    LT              shift and go to state 136
    GT              shift and go to state 131
    LEQ             shift and go to state 135
    GEQ             shift and go to state 130


state 127

    (80) assign -> MINUSMINUS lhs .
    (97) primary -> lhs .

    RSQUARE         reduce using rule 80 (assign -> MINUSMINUS lhs .)
    PLUS            reduce using rule 80 (assign -> MINUSMINUS lhs .)
    MINUS           reduce using rule 80 (assign -> MINUSMINUS lhs .)
    MULT            reduce using rule 80 (assign -> MINUSMINUS lhs .)
    DIV             reduce using rule 80 (assign -> MINUSMINUS lhs .)
    OR              reduce using rule 80 (assign -> MINUSMINUS lhs .)
    AND             reduce using rule 80 (assign -> MINUSMINUS lhs .)
    EQUALS          reduce using rule 80 (assign -> MINUSMINUS lhs .)
    NOTEQUALS       reduce using rule 80 (assign -> MINUSMINUS lhs .)
    LT              reduce using rule 80 (assign -> MINUSMINUS lhs .)
    GT              reduce using rule 80 (assign -> MINUSMINUS lhs .)
    LEQ             reduce using rule 80 (assign -> MINUSMINUS lhs .)
    GEQ             reduce using rule 80 (assign -> MINUSMINUS lhs .)
    RPAREN          reduce using rule 80 (assign -> MINUSMINUS lhs .)
    SEMICOLON       reduce using rule 80 (assign -> MINUSMINUS lhs .)
    DOT             reduce using rule 97 (primary -> lhs .)
    LPAREN          reduce using rule 97 (primary -> lhs .)


state 128

    (66) expr -> expr AND . expr
    (58) expr -> . primary
    (59) expr -> . assign
    (60) expr -> . new_array
    (61) expr -> . expr PLUS expr
    (62) expr -> . expr MINUS expr
    (63) expr -> . expr MULT expr
    (64) expr -> . expr DIV expr
    (65) expr -> . expr OR expr
    (66) expr -> . expr AND expr
    (67) expr -> . expr EQUALS expr
    (68) expr -> . expr NOTEQUALS expr
    (69) expr -> . expr LT expr
    (70) expr -> . expr GT expr
    (71) expr -> . expr LEQ expr
    (72) expr -> . expr GEQ expr
    (73) expr -> . PLUS expr
    (74) expr -> . MINUS expr
    (75) expr -> . NOT expr
    (92) primary -> . literal
    (93) primary -> . THIS
    (94) primary -> . SUPER
    (95) primary -> . LPAREN expr RPAREN
    (96) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (97) primary -> . lhs
    (98) primary -> . method_invocation
    (76) assign -> . lhs ASSIGN expr
    (77) assign -> . lhs PLUSPLUS
    (78) assign -> . PLUSPLUS lhs
    (79) assign -> . lhs MINUSMINUS
    (80) assign -> . MINUSMINUS lhs
    (81) new_array -> . NEW type expr_array_helper1 expr_array_helper2
    (87) literal -> . INTEGERCONSTANT
    (88) literal -> . FLOATCONSTANT
    (89) literal -> . NULL
    (90) literal -> . TRUE
    (91) literal -> . FALSE
    (101) lhs -> . field_access
    (102) lhs -> . array_access
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN expr RPAREN
    (105) field_access -> . primary DOT IDENTIFIER
    (106) field_access -> . IDENTIFIER
    (107) array_access -> . primary LPAREN expr RPAREN

    PLUS            shift and go to state 92
    MINUS           shift and go to state 88
    NOT             shift and go to state 104
    THIS            shift and go to state 101
    SUPER           shift and go to state 105
    LPAREN          shift and go to state 97
    NEW             shift and go to state 85
    PLUSPLUS        shift and go to state 96
    MINUSMINUS      shift and go to state 98
    INTEGERCONSTANT shift and go to state 84
    FLOATCONSTANT   shift and go to state 99
    NULL            shift and go to state 86
    TRUE            shift and go to state 87
    FALSE           shift and go to state 100
    IDENTIFIER      shift and go to state 94

    new_array                      shift and go to state 82
    field_access                   shift and go to state 95
    expr                           shift and go to state 158
    primary                        shift and go to state 83
    array_access                   shift and go to state 90
    literal                        shift and go to state 91
    lhs                            shift and go to state 103
    method_invocation              shift and go to state 93
    assign                         shift and go to state 106

state 129

    (68) expr -> expr NOTEQUALS . expr
    (58) expr -> . primary
    (59) expr -> . assign
    (60) expr -> . new_array
    (61) expr -> . expr PLUS expr
    (62) expr -> . expr MINUS expr
    (63) expr -> . expr MULT expr
    (64) expr -> . expr DIV expr
    (65) expr -> . expr OR expr
    (66) expr -> . expr AND expr
    (67) expr -> . expr EQUALS expr
    (68) expr -> . expr NOTEQUALS expr
    (69) expr -> . expr LT expr
    (70) expr -> . expr GT expr
    (71) expr -> . expr LEQ expr
    (72) expr -> . expr GEQ expr
    (73) expr -> . PLUS expr
    (74) expr -> . MINUS expr
    (75) expr -> . NOT expr
    (92) primary -> . literal
    (93) primary -> . THIS
    (94) primary -> . SUPER
    (95) primary -> . LPAREN expr RPAREN
    (96) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (97) primary -> . lhs
    (98) primary -> . method_invocation
    (76) assign -> . lhs ASSIGN expr
    (77) assign -> . lhs PLUSPLUS
    (78) assign -> . PLUSPLUS lhs
    (79) assign -> . lhs MINUSMINUS
    (80) assign -> . MINUSMINUS lhs
    (81) new_array -> . NEW type expr_array_helper1 expr_array_helper2
    (87) literal -> . INTEGERCONSTANT
    (88) literal -> . FLOATCONSTANT
    (89) literal -> . NULL
    (90) literal -> . TRUE
    (91) literal -> . FALSE
    (101) lhs -> . field_access
    (102) lhs -> . array_access
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN expr RPAREN
    (105) field_access -> . primary DOT IDENTIFIER
    (106) field_access -> . IDENTIFIER
    (107) array_access -> . primary LPAREN expr RPAREN

    PLUS            shift and go to state 92
    MINUS           shift and go to state 88
    NOT             shift and go to state 104
    THIS            shift and go to state 101
    SUPER           shift and go to state 105
    LPAREN          shift and go to state 97
    NEW             shift and go to state 85
    PLUSPLUS        shift and go to state 96
    MINUSMINUS      shift and go to state 98
    INTEGERCONSTANT shift and go to state 84
    FLOATCONSTANT   shift and go to state 99
    NULL            shift and go to state 86
    TRUE            shift and go to state 87
    FALSE           shift and go to state 100
    IDENTIFIER      shift and go to state 94

    new_array                      shift and go to state 82
    field_access                   shift and go to state 95
    expr                           shift and go to state 159
    primary                        shift and go to state 83
    array_access                   shift and go to state 90
    literal                        shift and go to state 91
    lhs                            shift and go to state 103
    method_invocation              shift and go to state 93
    assign                         shift and go to state 106

state 130

    (72) expr -> expr GEQ . expr
    (58) expr -> . primary
    (59) expr -> . assign
    (60) expr -> . new_array
    (61) expr -> . expr PLUS expr
    (62) expr -> . expr MINUS expr
    (63) expr -> . expr MULT expr
    (64) expr -> . expr DIV expr
    (65) expr -> . expr OR expr
    (66) expr -> . expr AND expr
    (67) expr -> . expr EQUALS expr
    (68) expr -> . expr NOTEQUALS expr
    (69) expr -> . expr LT expr
    (70) expr -> . expr GT expr
    (71) expr -> . expr LEQ expr
    (72) expr -> . expr GEQ expr
    (73) expr -> . PLUS expr
    (74) expr -> . MINUS expr
    (75) expr -> . NOT expr
    (92) primary -> . literal
    (93) primary -> . THIS
    (94) primary -> . SUPER
    (95) primary -> . LPAREN expr RPAREN
    (96) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (97) primary -> . lhs
    (98) primary -> . method_invocation
    (76) assign -> . lhs ASSIGN expr
    (77) assign -> . lhs PLUSPLUS
    (78) assign -> . PLUSPLUS lhs
    (79) assign -> . lhs MINUSMINUS
    (80) assign -> . MINUSMINUS lhs
    (81) new_array -> . NEW type expr_array_helper1 expr_array_helper2
    (87) literal -> . INTEGERCONSTANT
    (88) literal -> . FLOATCONSTANT
    (89) literal -> . NULL
    (90) literal -> . TRUE
    (91) literal -> . FALSE
    (101) lhs -> . field_access
    (102) lhs -> . array_access
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN expr RPAREN
    (105) field_access -> . primary DOT IDENTIFIER
    (106) field_access -> . IDENTIFIER
    (107) array_access -> . primary LPAREN expr RPAREN

    PLUS            shift and go to state 92
    MINUS           shift and go to state 88
    NOT             shift and go to state 104
    THIS            shift and go to state 101
    SUPER           shift and go to state 105
    LPAREN          shift and go to state 97
    NEW             shift and go to state 85
    PLUSPLUS        shift and go to state 96
    MINUSMINUS      shift and go to state 98
    INTEGERCONSTANT shift and go to state 84
    FLOATCONSTANT   shift and go to state 99
    NULL            shift and go to state 86
    TRUE            shift and go to state 87
    FALSE           shift and go to state 100
    IDENTIFIER      shift and go to state 94

    new_array                      shift and go to state 82
    field_access                   shift and go to state 95
    expr                           shift and go to state 160
    primary                        shift and go to state 83
    array_access                   shift and go to state 90
    literal                        shift and go to state 91
    lhs                            shift and go to state 103
    method_invocation              shift and go to state 93
    assign                         shift and go to state 106

state 131

    (70) expr -> expr GT . expr
    (58) expr -> . primary
    (59) expr -> . assign
    (60) expr -> . new_array
    (61) expr -> . expr PLUS expr
    (62) expr -> . expr MINUS expr
    (63) expr -> . expr MULT expr
    (64) expr -> . expr DIV expr
    (65) expr -> . expr OR expr
    (66) expr -> . expr AND expr
    (67) expr -> . expr EQUALS expr
    (68) expr -> . expr NOTEQUALS expr
    (69) expr -> . expr LT expr
    (70) expr -> . expr GT expr
    (71) expr -> . expr LEQ expr
    (72) expr -> . expr GEQ expr
    (73) expr -> . PLUS expr
    (74) expr -> . MINUS expr
    (75) expr -> . NOT expr
    (92) primary -> . literal
    (93) primary -> . THIS
    (94) primary -> . SUPER
    (95) primary -> . LPAREN expr RPAREN
    (96) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (97) primary -> . lhs
    (98) primary -> . method_invocation
    (76) assign -> . lhs ASSIGN expr
    (77) assign -> . lhs PLUSPLUS
    (78) assign -> . PLUSPLUS lhs
    (79) assign -> . lhs MINUSMINUS
    (80) assign -> . MINUSMINUS lhs
    (81) new_array -> . NEW type expr_array_helper1 expr_array_helper2
    (87) literal -> . INTEGERCONSTANT
    (88) literal -> . FLOATCONSTANT
    (89) literal -> . NULL
    (90) literal -> . TRUE
    (91) literal -> . FALSE
    (101) lhs -> . field_access
    (102) lhs -> . array_access
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN expr RPAREN
    (105) field_access -> . primary DOT IDENTIFIER
    (106) field_access -> . IDENTIFIER
    (107) array_access -> . primary LPAREN expr RPAREN

    PLUS            shift and go to state 92
    MINUS           shift and go to state 88
    NOT             shift and go to state 104
    THIS            shift and go to state 101
    SUPER           shift and go to state 105
    LPAREN          shift and go to state 97
    NEW             shift and go to state 85
    PLUSPLUS        shift and go to state 96
    MINUSMINUS      shift and go to state 98
    INTEGERCONSTANT shift and go to state 84
    FLOATCONSTANT   shift and go to state 99
    NULL            shift and go to state 86
    TRUE            shift and go to state 87
    FALSE           shift and go to state 100
    IDENTIFIER      shift and go to state 94

    new_array                      shift and go to state 82
    field_access                   shift and go to state 95
    expr                           shift and go to state 161
    primary                        shift and go to state 83
    array_access                   shift and go to state 90
    literal                        shift and go to state 91
    lhs                            shift and go to state 103
    method_invocation              shift and go to state 93
    assign                         shift and go to state 106

state 132

    (51) stmt -> RETURN expr SEMICOLON .

    IF              reduce using rule 51 (stmt -> RETURN expr SEMICOLON .)
    WHILE           reduce using rule 51 (stmt -> RETURN expr SEMICOLON .)
    FOR             reduce using rule 51 (stmt -> RETURN expr SEMICOLON .)
    RETURN          reduce using rule 51 (stmt -> RETURN expr SEMICOLON .)
    BREAK           reduce using rule 51 (stmt -> RETURN expr SEMICOLON .)
    CONTINUE        reduce using rule 51 (stmt -> RETURN expr SEMICOLON .)
    SEMICOLON       reduce using rule 51 (stmt -> RETURN expr SEMICOLON .)
    LCURLY          reduce using rule 51 (stmt -> RETURN expr SEMICOLON .)
    INT             reduce using rule 51 (stmt -> RETURN expr SEMICOLON .)
    FLOAT           reduce using rule 51 (stmt -> RETURN expr SEMICOLON .)
    BOOLEAN         reduce using rule 51 (stmt -> RETURN expr SEMICOLON .)
    IDENTIFIER      reduce using rule 51 (stmt -> RETURN expr SEMICOLON .)
    RCURLY          reduce using rule 51 (stmt -> RETURN expr SEMICOLON .)
    ELSE            reduce using rule 51 (stmt -> RETURN expr SEMICOLON .)


state 133

    (67) expr -> expr EQUALS . expr
    (58) expr -> . primary
    (59) expr -> . assign
    (60) expr -> . new_array
    (61) expr -> . expr PLUS expr
    (62) expr -> . expr MINUS expr
    (63) expr -> . expr MULT expr
    (64) expr -> . expr DIV expr
    (65) expr -> . expr OR expr
    (66) expr -> . expr AND expr
    (67) expr -> . expr EQUALS expr
    (68) expr -> . expr NOTEQUALS expr
    (69) expr -> . expr LT expr
    (70) expr -> . expr GT expr
    (71) expr -> . expr LEQ expr
    (72) expr -> . expr GEQ expr
    (73) expr -> . PLUS expr
    (74) expr -> . MINUS expr
    (75) expr -> . NOT expr
    (92) primary -> . literal
    (93) primary -> . THIS
    (94) primary -> . SUPER
    (95) primary -> . LPAREN expr RPAREN
    (96) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (97) primary -> . lhs
    (98) primary -> . method_invocation
    (76) assign -> . lhs ASSIGN expr
    (77) assign -> . lhs PLUSPLUS
    (78) assign -> . PLUSPLUS lhs
    (79) assign -> . lhs MINUSMINUS
    (80) assign -> . MINUSMINUS lhs
    (81) new_array -> . NEW type expr_array_helper1 expr_array_helper2
    (87) literal -> . INTEGERCONSTANT
    (88) literal -> . FLOATCONSTANT
    (89) literal -> . NULL
    (90) literal -> . TRUE
    (91) literal -> . FALSE
    (101) lhs -> . field_access
    (102) lhs -> . array_access
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN expr RPAREN
    (105) field_access -> . primary DOT IDENTIFIER
    (106) field_access -> . IDENTIFIER
    (107) array_access -> . primary LPAREN expr RPAREN

    PLUS            shift and go to state 92
    MINUS           shift and go to state 88
    NOT             shift and go to state 104
    THIS            shift and go to state 101
    SUPER           shift and go to state 105
    LPAREN          shift and go to state 97
    NEW             shift and go to state 85
    PLUSPLUS        shift and go to state 96
    MINUSMINUS      shift and go to state 98
    INTEGERCONSTANT shift and go to state 84
    FLOATCONSTANT   shift and go to state 99
    NULL            shift and go to state 86
    TRUE            shift and go to state 87
    FALSE           shift and go to state 100
    IDENTIFIER      shift and go to state 94

    new_array                      shift and go to state 82
    field_access                   shift and go to state 95
    expr                           shift and go to state 162
    primary                        shift and go to state 83
    array_access                   shift and go to state 90
    literal                        shift and go to state 91
    lhs                            shift and go to state 103
    method_invocation              shift and go to state 93
    assign                         shift and go to state 106

state 134

    (65) expr -> expr OR . expr
    (58) expr -> . primary
    (59) expr -> . assign
    (60) expr -> . new_array
    (61) expr -> . expr PLUS expr
    (62) expr -> . expr MINUS expr
    (63) expr -> . expr MULT expr
    (64) expr -> . expr DIV expr
    (65) expr -> . expr OR expr
    (66) expr -> . expr AND expr
    (67) expr -> . expr EQUALS expr
    (68) expr -> . expr NOTEQUALS expr
    (69) expr -> . expr LT expr
    (70) expr -> . expr GT expr
    (71) expr -> . expr LEQ expr
    (72) expr -> . expr GEQ expr
    (73) expr -> . PLUS expr
    (74) expr -> . MINUS expr
    (75) expr -> . NOT expr
    (92) primary -> . literal
    (93) primary -> . THIS
    (94) primary -> . SUPER
    (95) primary -> . LPAREN expr RPAREN
    (96) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (97) primary -> . lhs
    (98) primary -> . method_invocation
    (76) assign -> . lhs ASSIGN expr
    (77) assign -> . lhs PLUSPLUS
    (78) assign -> . PLUSPLUS lhs
    (79) assign -> . lhs MINUSMINUS
    (80) assign -> . MINUSMINUS lhs
    (81) new_array -> . NEW type expr_array_helper1 expr_array_helper2
    (87) literal -> . INTEGERCONSTANT
    (88) literal -> . FLOATCONSTANT
    (89) literal -> . NULL
    (90) literal -> . TRUE
    (91) literal -> . FALSE
    (101) lhs -> . field_access
    (102) lhs -> . array_access
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN expr RPAREN
    (105) field_access -> . primary DOT IDENTIFIER
    (106) field_access -> . IDENTIFIER
    (107) array_access -> . primary LPAREN expr RPAREN

    PLUS            shift and go to state 92
    MINUS           shift and go to state 88
    NOT             shift and go to state 104
    THIS            shift and go to state 101
    SUPER           shift and go to state 105
    LPAREN          shift and go to state 97
    NEW             shift and go to state 85
    PLUSPLUS        shift and go to state 96
    MINUSMINUS      shift and go to state 98
    INTEGERCONSTANT shift and go to state 84
    FLOATCONSTANT   shift and go to state 99
    NULL            shift and go to state 86
    TRUE            shift and go to state 87
    FALSE           shift and go to state 100
    IDENTIFIER      shift and go to state 94

    new_array                      shift and go to state 82
    field_access                   shift and go to state 95
    expr                           shift and go to state 163
    primary                        shift and go to state 83
    array_access                   shift and go to state 90
    literal                        shift and go to state 91
    lhs                            shift and go to state 103
    method_invocation              shift and go to state 93
    assign                         shift and go to state 106

state 135

    (71) expr -> expr LEQ . expr
    (58) expr -> . primary
    (59) expr -> . assign
    (60) expr -> . new_array
    (61) expr -> . expr PLUS expr
    (62) expr -> . expr MINUS expr
    (63) expr -> . expr MULT expr
    (64) expr -> . expr DIV expr
    (65) expr -> . expr OR expr
    (66) expr -> . expr AND expr
    (67) expr -> . expr EQUALS expr
    (68) expr -> . expr NOTEQUALS expr
    (69) expr -> . expr LT expr
    (70) expr -> . expr GT expr
    (71) expr -> . expr LEQ expr
    (72) expr -> . expr GEQ expr
    (73) expr -> . PLUS expr
    (74) expr -> . MINUS expr
    (75) expr -> . NOT expr
    (92) primary -> . literal
    (93) primary -> . THIS
    (94) primary -> . SUPER
    (95) primary -> . LPAREN expr RPAREN
    (96) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (97) primary -> . lhs
    (98) primary -> . method_invocation
    (76) assign -> . lhs ASSIGN expr
    (77) assign -> . lhs PLUSPLUS
    (78) assign -> . PLUSPLUS lhs
    (79) assign -> . lhs MINUSMINUS
    (80) assign -> . MINUSMINUS lhs
    (81) new_array -> . NEW type expr_array_helper1 expr_array_helper2
    (87) literal -> . INTEGERCONSTANT
    (88) literal -> . FLOATCONSTANT
    (89) literal -> . NULL
    (90) literal -> . TRUE
    (91) literal -> . FALSE
    (101) lhs -> . field_access
    (102) lhs -> . array_access
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN expr RPAREN
    (105) field_access -> . primary DOT IDENTIFIER
    (106) field_access -> . IDENTIFIER
    (107) array_access -> . primary LPAREN expr RPAREN

    PLUS            shift and go to state 92
    MINUS           shift and go to state 88
    NOT             shift and go to state 104
    THIS            shift and go to state 101
    SUPER           shift and go to state 105
    LPAREN          shift and go to state 97
    NEW             shift and go to state 85
    PLUSPLUS        shift and go to state 96
    MINUSMINUS      shift and go to state 98
    INTEGERCONSTANT shift and go to state 84
    FLOATCONSTANT   shift and go to state 99
    NULL            shift and go to state 86
    TRUE            shift and go to state 87
    FALSE           shift and go to state 100
    IDENTIFIER      shift and go to state 94

    new_array                      shift and go to state 82
    field_access                   shift and go to state 95
    expr                           shift and go to state 164
    primary                        shift and go to state 83
    array_access                   shift and go to state 90
    literal                        shift and go to state 91
    lhs                            shift and go to state 103
    method_invocation              shift and go to state 93
    assign                         shift and go to state 106

state 136

    (69) expr -> expr LT . expr
    (58) expr -> . primary
    (59) expr -> . assign
    (60) expr -> . new_array
    (61) expr -> . expr PLUS expr
    (62) expr -> . expr MINUS expr
    (63) expr -> . expr MULT expr
    (64) expr -> . expr DIV expr
    (65) expr -> . expr OR expr
    (66) expr -> . expr AND expr
    (67) expr -> . expr EQUALS expr
    (68) expr -> . expr NOTEQUALS expr
    (69) expr -> . expr LT expr
    (70) expr -> . expr GT expr
    (71) expr -> . expr LEQ expr
    (72) expr -> . expr GEQ expr
    (73) expr -> . PLUS expr
    (74) expr -> . MINUS expr
    (75) expr -> . NOT expr
    (92) primary -> . literal
    (93) primary -> . THIS
    (94) primary -> . SUPER
    (95) primary -> . LPAREN expr RPAREN
    (96) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (97) primary -> . lhs
    (98) primary -> . method_invocation
    (76) assign -> . lhs ASSIGN expr
    (77) assign -> . lhs PLUSPLUS
    (78) assign -> . PLUSPLUS lhs
    (79) assign -> . lhs MINUSMINUS
    (80) assign -> . MINUSMINUS lhs
    (81) new_array -> . NEW type expr_array_helper1 expr_array_helper2
    (87) literal -> . INTEGERCONSTANT
    (88) literal -> . FLOATCONSTANT
    (89) literal -> . NULL
    (90) literal -> . TRUE
    (91) literal -> . FALSE
    (101) lhs -> . field_access
    (102) lhs -> . array_access
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN expr RPAREN
    (105) field_access -> . primary DOT IDENTIFIER
    (106) field_access -> . IDENTIFIER
    (107) array_access -> . primary LPAREN expr RPAREN

    PLUS            shift and go to state 92
    MINUS           shift and go to state 88
    NOT             shift and go to state 104
    THIS            shift and go to state 101
    SUPER           shift and go to state 105
    LPAREN          shift and go to state 97
    NEW             shift and go to state 85
    PLUSPLUS        shift and go to state 96
    MINUSMINUS      shift and go to state 98
    INTEGERCONSTANT shift and go to state 84
    FLOATCONSTANT   shift and go to state 99
    NULL            shift and go to state 86
    TRUE            shift and go to state 87
    FALSE           shift and go to state 100
    IDENTIFIER      shift and go to state 94

    new_array                      shift and go to state 82
    field_access                   shift and go to state 95
    expr                           shift and go to state 165
    primary                        shift and go to state 83
    array_access                   shift and go to state 90
    literal                        shift and go to state 91
    lhs                            shift and go to state 103
    method_invocation              shift and go to state 93
    assign                         shift and go to state 106

state 137

    (61) expr -> expr PLUS . expr
    (58) expr -> . primary
    (59) expr -> . assign
    (60) expr -> . new_array
    (61) expr -> . expr PLUS expr
    (62) expr -> . expr MINUS expr
    (63) expr -> . expr MULT expr
    (64) expr -> . expr DIV expr
    (65) expr -> . expr OR expr
    (66) expr -> . expr AND expr
    (67) expr -> . expr EQUALS expr
    (68) expr -> . expr NOTEQUALS expr
    (69) expr -> . expr LT expr
    (70) expr -> . expr GT expr
    (71) expr -> . expr LEQ expr
    (72) expr -> . expr GEQ expr
    (73) expr -> . PLUS expr
    (74) expr -> . MINUS expr
    (75) expr -> . NOT expr
    (92) primary -> . literal
    (93) primary -> . THIS
    (94) primary -> . SUPER
    (95) primary -> . LPAREN expr RPAREN
    (96) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (97) primary -> . lhs
    (98) primary -> . method_invocation
    (76) assign -> . lhs ASSIGN expr
    (77) assign -> . lhs PLUSPLUS
    (78) assign -> . PLUSPLUS lhs
    (79) assign -> . lhs MINUSMINUS
    (80) assign -> . MINUSMINUS lhs
    (81) new_array -> . NEW type expr_array_helper1 expr_array_helper2
    (87) literal -> . INTEGERCONSTANT
    (88) literal -> . FLOATCONSTANT
    (89) literal -> . NULL
    (90) literal -> . TRUE
    (91) literal -> . FALSE
    (101) lhs -> . field_access
    (102) lhs -> . array_access
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN expr RPAREN
    (105) field_access -> . primary DOT IDENTIFIER
    (106) field_access -> . IDENTIFIER
    (107) array_access -> . primary LPAREN expr RPAREN

    PLUS            shift and go to state 92
    MINUS           shift and go to state 88
    NOT             shift and go to state 104
    THIS            shift and go to state 101
    SUPER           shift and go to state 105
    LPAREN          shift and go to state 97
    NEW             shift and go to state 85
    PLUSPLUS        shift and go to state 96
    MINUSMINUS      shift and go to state 98
    INTEGERCONSTANT shift and go to state 84
    FLOATCONSTANT   shift and go to state 99
    NULL            shift and go to state 86
    TRUE            shift and go to state 87
    FALSE           shift and go to state 100
    IDENTIFIER      shift and go to state 94

    new_array                      shift and go to state 82
    field_access                   shift and go to state 95
    expr                           shift and go to state 166
    primary                        shift and go to state 83
    array_access                   shift and go to state 90
    literal                        shift and go to state 91
    lhs                            shift and go to state 103
    method_invocation              shift and go to state 93
    assign                         shift and go to state 106

state 138

    (64) expr -> expr DIV . expr
    (58) expr -> . primary
    (59) expr -> . assign
    (60) expr -> . new_array
    (61) expr -> . expr PLUS expr
    (62) expr -> . expr MINUS expr
    (63) expr -> . expr MULT expr
    (64) expr -> . expr DIV expr
    (65) expr -> . expr OR expr
    (66) expr -> . expr AND expr
    (67) expr -> . expr EQUALS expr
    (68) expr -> . expr NOTEQUALS expr
    (69) expr -> . expr LT expr
    (70) expr -> . expr GT expr
    (71) expr -> . expr LEQ expr
    (72) expr -> . expr GEQ expr
    (73) expr -> . PLUS expr
    (74) expr -> . MINUS expr
    (75) expr -> . NOT expr
    (92) primary -> . literal
    (93) primary -> . THIS
    (94) primary -> . SUPER
    (95) primary -> . LPAREN expr RPAREN
    (96) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (97) primary -> . lhs
    (98) primary -> . method_invocation
    (76) assign -> . lhs ASSIGN expr
    (77) assign -> . lhs PLUSPLUS
    (78) assign -> . PLUSPLUS lhs
    (79) assign -> . lhs MINUSMINUS
    (80) assign -> . MINUSMINUS lhs
    (81) new_array -> . NEW type expr_array_helper1 expr_array_helper2
    (87) literal -> . INTEGERCONSTANT
    (88) literal -> . FLOATCONSTANT
    (89) literal -> . NULL
    (90) literal -> . TRUE
    (91) literal -> . FALSE
    (101) lhs -> . field_access
    (102) lhs -> . array_access
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN expr RPAREN
    (105) field_access -> . primary DOT IDENTIFIER
    (106) field_access -> . IDENTIFIER
    (107) array_access -> . primary LPAREN expr RPAREN

    PLUS            shift and go to state 92
    MINUS           shift and go to state 88
    NOT             shift and go to state 104
    THIS            shift and go to state 101
    SUPER           shift and go to state 105
    LPAREN          shift and go to state 97
    NEW             shift and go to state 85
    PLUSPLUS        shift and go to state 96
    MINUSMINUS      shift and go to state 98
    INTEGERCONSTANT shift and go to state 84
    FLOATCONSTANT   shift and go to state 99
    NULL            shift and go to state 86
    TRUE            shift and go to state 87
    FALSE           shift and go to state 100
    IDENTIFIER      shift and go to state 94

    new_array                      shift and go to state 82
    field_access                   shift and go to state 95
    expr                           shift and go to state 167
    primary                        shift and go to state 83
    array_access                   shift and go to state 90
    literal                        shift and go to state 91
    lhs                            shift and go to state 103
    method_invocation              shift and go to state 93
    assign                         shift and go to state 106

state 139

    (62) expr -> expr MINUS . expr
    (58) expr -> . primary
    (59) expr -> . assign
    (60) expr -> . new_array
    (61) expr -> . expr PLUS expr
    (62) expr -> . expr MINUS expr
    (63) expr -> . expr MULT expr
    (64) expr -> . expr DIV expr
    (65) expr -> . expr OR expr
    (66) expr -> . expr AND expr
    (67) expr -> . expr EQUALS expr
    (68) expr -> . expr NOTEQUALS expr
    (69) expr -> . expr LT expr
    (70) expr -> . expr GT expr
    (71) expr -> . expr LEQ expr
    (72) expr -> . expr GEQ expr
    (73) expr -> . PLUS expr
    (74) expr -> . MINUS expr
    (75) expr -> . NOT expr
    (92) primary -> . literal
    (93) primary -> . THIS
    (94) primary -> . SUPER
    (95) primary -> . LPAREN expr RPAREN
    (96) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (97) primary -> . lhs
    (98) primary -> . method_invocation
    (76) assign -> . lhs ASSIGN expr
    (77) assign -> . lhs PLUSPLUS
    (78) assign -> . PLUSPLUS lhs
    (79) assign -> . lhs MINUSMINUS
    (80) assign -> . MINUSMINUS lhs
    (81) new_array -> . NEW type expr_array_helper1 expr_array_helper2
    (87) literal -> . INTEGERCONSTANT
    (88) literal -> . FLOATCONSTANT
    (89) literal -> . NULL
    (90) literal -> . TRUE
    (91) literal -> . FALSE
    (101) lhs -> . field_access
    (102) lhs -> . array_access
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN expr RPAREN
    (105) field_access -> . primary DOT IDENTIFIER
    (106) field_access -> . IDENTIFIER
    (107) array_access -> . primary LPAREN expr RPAREN

    PLUS            shift and go to state 92
    MINUS           shift and go to state 88
    NOT             shift and go to state 104
    THIS            shift and go to state 101
    SUPER           shift and go to state 105
    LPAREN          shift and go to state 97
    NEW             shift and go to state 85
    PLUSPLUS        shift and go to state 96
    MINUSMINUS      shift and go to state 98
    INTEGERCONSTANT shift and go to state 84
    FLOATCONSTANT   shift and go to state 99
    NULL            shift and go to state 86
    TRUE            shift and go to state 87
    FALSE           shift and go to state 100
    IDENTIFIER      shift and go to state 94

    new_array                      shift and go to state 82
    field_access                   shift and go to state 95
    expr                           shift and go to state 168
    primary                        shift and go to state 83
    array_access                   shift and go to state 90
    literal                        shift and go to state 91
    lhs                            shift and go to state 103
    method_invocation              shift and go to state 93
    assign                         shift and go to state 106

state 140

    (63) expr -> expr MULT . expr
    (58) expr -> . primary
    (59) expr -> . assign
    (60) expr -> . new_array
    (61) expr -> . expr PLUS expr
    (62) expr -> . expr MINUS expr
    (63) expr -> . expr MULT expr
    (64) expr -> . expr DIV expr
    (65) expr -> . expr OR expr
    (66) expr -> . expr AND expr
    (67) expr -> . expr EQUALS expr
    (68) expr -> . expr NOTEQUALS expr
    (69) expr -> . expr LT expr
    (70) expr -> . expr GT expr
    (71) expr -> . expr LEQ expr
    (72) expr -> . expr GEQ expr
    (73) expr -> . PLUS expr
    (74) expr -> . MINUS expr
    (75) expr -> . NOT expr
    (92) primary -> . literal
    (93) primary -> . THIS
    (94) primary -> . SUPER
    (95) primary -> . LPAREN expr RPAREN
    (96) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (97) primary -> . lhs
    (98) primary -> . method_invocation
    (76) assign -> . lhs ASSIGN expr
    (77) assign -> . lhs PLUSPLUS
    (78) assign -> . PLUSPLUS lhs
    (79) assign -> . lhs MINUSMINUS
    (80) assign -> . MINUSMINUS lhs
    (81) new_array -> . NEW type expr_array_helper1 expr_array_helper2
    (87) literal -> . INTEGERCONSTANT
    (88) literal -> . FLOATCONSTANT
    (89) literal -> . NULL
    (90) literal -> . TRUE
    (91) literal -> . FALSE
    (101) lhs -> . field_access
    (102) lhs -> . array_access
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN expr RPAREN
    (105) field_access -> . primary DOT IDENTIFIER
    (106) field_access -> . IDENTIFIER
    (107) array_access -> . primary LPAREN expr RPAREN

    PLUS            shift and go to state 92
    MINUS           shift and go to state 88
    NOT             shift and go to state 104
    THIS            shift and go to state 101
    SUPER           shift and go to state 105
    LPAREN          shift and go to state 97
    NEW             shift and go to state 85
    PLUSPLUS        shift and go to state 96
    MINUSMINUS      shift and go to state 98
    INTEGERCONSTANT shift and go to state 84
    FLOATCONSTANT   shift and go to state 99
    NULL            shift and go to state 86
    TRUE            shift and go to state 87
    FALSE           shift and go to state 100
    IDENTIFIER      shift and go to state 94

    new_array                      shift and go to state 82
    field_access                   shift and go to state 95
    expr                           shift and go to state 169
    primary                        shift and go to state 83
    array_access                   shift and go to state 90
    literal                        shift and go to state 91
    lhs                            shift and go to state 103
    method_invocation              shift and go to state 93
    assign                         shift and go to state 106

state 141

    (77) assign -> lhs PLUSPLUS .

    RSQUARE         reduce using rule 77 (assign -> lhs PLUSPLUS .)
    PLUS            reduce using rule 77 (assign -> lhs PLUSPLUS .)
    MINUS           reduce using rule 77 (assign -> lhs PLUSPLUS .)
    MULT            reduce using rule 77 (assign -> lhs PLUSPLUS .)
    DIV             reduce using rule 77 (assign -> lhs PLUSPLUS .)
    OR              reduce using rule 77 (assign -> lhs PLUSPLUS .)
    AND             reduce using rule 77 (assign -> lhs PLUSPLUS .)
    EQUALS          reduce using rule 77 (assign -> lhs PLUSPLUS .)
    NOTEQUALS       reduce using rule 77 (assign -> lhs PLUSPLUS .)
    LT              reduce using rule 77 (assign -> lhs PLUSPLUS .)
    GT              reduce using rule 77 (assign -> lhs PLUSPLUS .)
    LEQ             reduce using rule 77 (assign -> lhs PLUSPLUS .)
    GEQ             reduce using rule 77 (assign -> lhs PLUSPLUS .)
    RPAREN          reduce using rule 77 (assign -> lhs PLUSPLUS .)
    SEMICOLON       reduce using rule 77 (assign -> lhs PLUSPLUS .)


state 142

    (79) assign -> lhs MINUSMINUS .

    RSQUARE         reduce using rule 79 (assign -> lhs MINUSMINUS .)
    PLUS            reduce using rule 79 (assign -> lhs MINUSMINUS .)
    MINUS           reduce using rule 79 (assign -> lhs MINUSMINUS .)
    MULT            reduce using rule 79 (assign -> lhs MINUSMINUS .)
    DIV             reduce using rule 79 (assign -> lhs MINUSMINUS .)
    OR              reduce using rule 79 (assign -> lhs MINUSMINUS .)
    AND             reduce using rule 79 (assign -> lhs MINUSMINUS .)
    EQUALS          reduce using rule 79 (assign -> lhs MINUSMINUS .)
    NOTEQUALS       reduce using rule 79 (assign -> lhs MINUSMINUS .)
    LT              reduce using rule 79 (assign -> lhs MINUSMINUS .)
    GT              reduce using rule 79 (assign -> lhs MINUSMINUS .)
    LEQ             reduce using rule 79 (assign -> lhs MINUSMINUS .)
    GEQ             reduce using rule 79 (assign -> lhs MINUSMINUS .)
    RPAREN          reduce using rule 79 (assign -> lhs MINUSMINUS .)
    SEMICOLON       reduce using rule 79 (assign -> lhs MINUSMINUS .)


state 143

    (76) assign -> lhs ASSIGN . expr
    (58) expr -> . primary
    (59) expr -> . assign
    (60) expr -> . new_array
    (61) expr -> . expr PLUS expr
    (62) expr -> . expr MINUS expr
    (63) expr -> . expr MULT expr
    (64) expr -> . expr DIV expr
    (65) expr -> . expr OR expr
    (66) expr -> . expr AND expr
    (67) expr -> . expr EQUALS expr
    (68) expr -> . expr NOTEQUALS expr
    (69) expr -> . expr LT expr
    (70) expr -> . expr GT expr
    (71) expr -> . expr LEQ expr
    (72) expr -> . expr GEQ expr
    (73) expr -> . PLUS expr
    (74) expr -> . MINUS expr
    (75) expr -> . NOT expr
    (92) primary -> . literal
    (93) primary -> . THIS
    (94) primary -> . SUPER
    (95) primary -> . LPAREN expr RPAREN
    (96) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (97) primary -> . lhs
    (98) primary -> . method_invocation
    (76) assign -> . lhs ASSIGN expr
    (77) assign -> . lhs PLUSPLUS
    (78) assign -> . PLUSPLUS lhs
    (79) assign -> . lhs MINUSMINUS
    (80) assign -> . MINUSMINUS lhs
    (81) new_array -> . NEW type expr_array_helper1 expr_array_helper2
    (87) literal -> . INTEGERCONSTANT
    (88) literal -> . FLOATCONSTANT
    (89) literal -> . NULL
    (90) literal -> . TRUE
    (91) literal -> . FALSE
    (101) lhs -> . field_access
    (102) lhs -> . array_access
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN expr RPAREN
    (105) field_access -> . primary DOT IDENTIFIER
    (106) field_access -> . IDENTIFIER
    (107) array_access -> . primary LPAREN expr RPAREN

    PLUS            shift and go to state 92
    MINUS           shift and go to state 88
    NOT             shift and go to state 104
    THIS            shift and go to state 101
    SUPER           shift and go to state 105
    LPAREN          shift and go to state 97
    NEW             shift and go to state 85
    PLUSPLUS        shift and go to state 96
    MINUSMINUS      shift and go to state 98
    INTEGERCONSTANT shift and go to state 84
    FLOATCONSTANT   shift and go to state 99
    NULL            shift and go to state 86
    TRUE            shift and go to state 87
    FALSE           shift and go to state 100
    IDENTIFIER      shift and go to state 94

    new_array                      shift and go to state 82
    field_access                   shift and go to state 95
    expr                           shift and go to state 170
    primary                        shift and go to state 83
    array_access                   shift and go to state 90
    literal                        shift and go to state 91
    lhs                            shift and go to state 103
    method_invocation              shift and go to state 93
    assign                         shift and go to state 106

state 144

    (75) expr -> NOT expr .
    (61) expr -> expr . PLUS expr
    (62) expr -> expr . MINUS expr
    (63) expr -> expr . MULT expr
    (64) expr -> expr . DIV expr
    (65) expr -> expr . OR expr
    (66) expr -> expr . AND expr
    (67) expr -> expr . EQUALS expr
    (68) expr -> expr . NOTEQUALS expr
    (69) expr -> expr . LT expr
    (70) expr -> expr . GT expr
    (71) expr -> expr . LEQ expr
    (72) expr -> expr . GEQ expr

    RPAREN          reduce using rule 75 (expr -> NOT expr .)
    PLUS            reduce using rule 75 (expr -> NOT expr .)
    MINUS           reduce using rule 75 (expr -> NOT expr .)
    MULT            reduce using rule 75 (expr -> NOT expr .)
    DIV             reduce using rule 75 (expr -> NOT expr .)
    OR              reduce using rule 75 (expr -> NOT expr .)
    AND             reduce using rule 75 (expr -> NOT expr .)
    EQUALS          reduce using rule 75 (expr -> NOT expr .)
    NOTEQUALS       reduce using rule 75 (expr -> NOT expr .)
    LT              reduce using rule 75 (expr -> NOT expr .)
    GT              reduce using rule 75 (expr -> NOT expr .)
    LEQ             reduce using rule 75 (expr -> NOT expr .)
    GEQ             reduce using rule 75 (expr -> NOT expr .)
    SEMICOLON       reduce using rule 75 (expr -> NOT expr .)
    RSQUARE         reduce using rule 75 (expr -> NOT expr .)

  ! PLUS            [ shift and go to state 137 ]
  ! MINUS           [ shift and go to state 139 ]
  ! MULT            [ shift and go to state 140 ]
  ! DIV             [ shift and go to state 138 ]
  ! OR              [ shift and go to state 134 ]
  ! AND             [ shift and go to state 128 ]
  ! EQUALS          [ shift and go to state 133 ]
  ! NOTEQUALS       [ shift and go to state 129 ]
  ! LT              [ shift and go to state 136 ]
  ! GT              [ shift and go to state 131 ]
  ! LEQ             [ shift and go to state 135 ]
  ! GEQ             [ shift and go to state 130 ]


state 145

    (41) stmt -> WHILE LPAREN expr . RPAREN stmt
    (61) expr -> expr . PLUS expr
    (62) expr -> expr . MINUS expr
    (63) expr -> expr . MULT expr
    (64) expr -> expr . DIV expr
    (65) expr -> expr . OR expr
    (66) expr -> expr . AND expr
    (67) expr -> expr . EQUALS expr
    (68) expr -> expr . NOTEQUALS expr
    (69) expr -> expr . LT expr
    (70) expr -> expr . GT expr
    (71) expr -> expr . LEQ expr
    (72) expr -> expr . GEQ expr

    RPAREN          shift and go to state 171
    PLUS            shift and go to state 137
    MINUS           shift and go to state 139
    MULT            shift and go to state 140
    DIV             shift and go to state 138
    OR              shift and go to state 134
    AND             shift and go to state 128
    EQUALS          shift and go to state 133
    NOTEQUALS       shift and go to state 129
    LT              shift and go to state 136
    GT              shift and go to state 131
    LEQ             shift and go to state 135
    GEQ             shift and go to state 130


state 146

    (42) stmt -> FOR LPAREN SEMICOLON . SEMICOLON RPAREN stmt
    (47) stmt -> FOR LPAREN SEMICOLON . expr SEMICOLON RPAREN stmt
    (48) stmt -> FOR LPAREN SEMICOLON . expr SEMICOLON stmt_expr RPAREN stmt
    (49) stmt -> FOR LPAREN SEMICOLON . SEMICOLON stmt_expr RPAREN stmt
    (58) expr -> . primary
    (59) expr -> . assign
    (60) expr -> . new_array
    (61) expr -> . expr PLUS expr
    (62) expr -> . expr MINUS expr
    (63) expr -> . expr MULT expr
    (64) expr -> . expr DIV expr
    (65) expr -> . expr OR expr
    (66) expr -> . expr AND expr
    (67) expr -> . expr EQUALS expr
    (68) expr -> . expr NOTEQUALS expr
    (69) expr -> . expr LT expr
    (70) expr -> . expr GT expr
    (71) expr -> . expr LEQ expr
    (72) expr -> . expr GEQ expr
    (73) expr -> . PLUS expr
    (74) expr -> . MINUS expr
    (75) expr -> . NOT expr
    (92) primary -> . literal
    (93) primary -> . THIS
    (94) primary -> . SUPER
    (95) primary -> . LPAREN expr RPAREN
    (96) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (97) primary -> . lhs
    (98) primary -> . method_invocation
    (76) assign -> . lhs ASSIGN expr
    (77) assign -> . lhs PLUSPLUS
    (78) assign -> . PLUSPLUS lhs
    (79) assign -> . lhs MINUSMINUS
    (80) assign -> . MINUSMINUS lhs
    (81) new_array -> . NEW type expr_array_helper1 expr_array_helper2
    (87) literal -> . INTEGERCONSTANT
    (88) literal -> . FLOATCONSTANT
    (89) literal -> . NULL
    (90) literal -> . TRUE
    (91) literal -> . FALSE
    (101) lhs -> . field_access
    (102) lhs -> . array_access
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN expr RPAREN
    (105) field_access -> . primary DOT IDENTIFIER
    (106) field_access -> . IDENTIFIER
    (107) array_access -> . primary LPAREN expr RPAREN

    SEMICOLON       shift and go to state 172
    PLUS            shift and go to state 92
    MINUS           shift and go to state 88
    NOT             shift and go to state 104
    THIS            shift and go to state 101
    SUPER           shift and go to state 105
    LPAREN          shift and go to state 97
    NEW             shift and go to state 85
    PLUSPLUS        shift and go to state 96
    MINUSMINUS      shift and go to state 98
    INTEGERCONSTANT shift and go to state 84
    FLOATCONSTANT   shift and go to state 99
    NULL            shift and go to state 86
    TRUE            shift and go to state 87
    FALSE           shift and go to state 100
    IDENTIFIER      shift and go to state 94

    new_array                      shift and go to state 82
    field_access                   shift and go to state 95
    expr                           shift and go to state 173
    primary                        shift and go to state 83
    literal                        shift and go to state 91
    array_access                   shift and go to state 90
    lhs                            shift and go to state 103
    method_invocation              shift and go to state 93
    assign                         shift and go to state 106

state 147

    (43) stmt -> FOR LPAREN stmt_expr . SEMICOLON SEMICOLON RPAREN stmt
    (44) stmt -> FOR LPAREN stmt_expr . SEMICOLON expr SEMICOLON RPAREN stmt
    (45) stmt -> FOR LPAREN stmt_expr . SEMICOLON SEMICOLON stmt_expr RPAREN stmt
    (46) stmt -> FOR LPAREN stmt_expr . SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt

    SEMICOLON       shift and go to state 174


state 148

    (39) stmt -> IF LPAREN expr . RPAREN stmt
    (40) stmt -> IF LPAREN expr . RPAREN stmt ELSE stmt
    (61) expr -> expr . PLUS expr
    (62) expr -> expr . MINUS expr
    (63) expr -> expr . MULT expr
    (64) expr -> expr . DIV expr
    (65) expr -> expr . OR expr
    (66) expr -> expr . AND expr
    (67) expr -> expr . EQUALS expr
    (68) expr -> expr . NOTEQUALS expr
    (69) expr -> expr . LT expr
    (70) expr -> expr . GT expr
    (71) expr -> expr . LEQ expr
    (72) expr -> expr . GEQ expr

    RPAREN          shift and go to state 175
    PLUS            shift and go to state 137
    MINUS           shift and go to state 139
    MULT            shift and go to state 140
    DIV             shift and go to state 138
    OR              shift and go to state 134
    AND             shift and go to state 128
    EQUALS          shift and go to state 133
    NOTEQUALS       shift and go to state 129
    LT              shift and go to state 136
    GT              shift and go to state 131
    LEQ             shift and go to state 135
    GEQ             shift and go to state 130


state 149

    (107) array_access -> primary LPAREN expr . RPAREN
    (61) expr -> expr . PLUS expr
    (62) expr -> expr . MINUS expr
    (63) expr -> expr . MULT expr
    (64) expr -> expr . DIV expr
    (65) expr -> expr . OR expr
    (66) expr -> expr . AND expr
    (67) expr -> expr . EQUALS expr
    (68) expr -> expr . NOTEQUALS expr
    (69) expr -> expr . LT expr
    (70) expr -> expr . GT expr
    (71) expr -> expr . LEQ expr
    (72) expr -> expr . GEQ expr

    RPAREN          shift and go to state 176
    PLUS            shift and go to state 137
    MINUS           shift and go to state 139
    MULT            shift and go to state 140
    DIV             shift and go to state 138
    OR              shift and go to state 134
    AND             shift and go to state 128
    EQUALS          shift and go to state 133
    NOTEQUALS       shift and go to state 129
    LT              shift and go to state 136
    GT              shift and go to state 131
    LEQ             shift and go to state 135
    GEQ             shift and go to state 130


state 150

    (105) field_access -> primary DOT IDENTIFIER .

    LPAREN          reduce using rule 105 (field_access -> primary DOT IDENTIFIER .)
    ASSIGN          reduce using rule 105 (field_access -> primary DOT IDENTIFIER .)
    PLUSPLUS        reduce using rule 105 (field_access -> primary DOT IDENTIFIER .)
    MINUSMINUS      reduce using rule 105 (field_access -> primary DOT IDENTIFIER .)
    DOT             reduce using rule 105 (field_access -> primary DOT IDENTIFIER .)
    PLUS            reduce using rule 105 (field_access -> primary DOT IDENTIFIER .)
    MINUS           reduce using rule 105 (field_access -> primary DOT IDENTIFIER .)
    MULT            reduce using rule 105 (field_access -> primary DOT IDENTIFIER .)
    DIV             reduce using rule 105 (field_access -> primary DOT IDENTIFIER .)
    OR              reduce using rule 105 (field_access -> primary DOT IDENTIFIER .)
    AND             reduce using rule 105 (field_access -> primary DOT IDENTIFIER .)
    EQUALS          reduce using rule 105 (field_access -> primary DOT IDENTIFIER .)
    NOTEQUALS       reduce using rule 105 (field_access -> primary DOT IDENTIFIER .)
    LT              reduce using rule 105 (field_access -> primary DOT IDENTIFIER .)
    GT              reduce using rule 105 (field_access -> primary DOT IDENTIFIER .)
    LEQ             reduce using rule 105 (field_access -> primary DOT IDENTIFIER .)
    GEQ             reduce using rule 105 (field_access -> primary DOT IDENTIFIER .)
    SEMICOLON       reduce using rule 105 (field_access -> primary DOT IDENTIFIER .)
    RPAREN          reduce using rule 105 (field_access -> primary DOT IDENTIFIER .)
    RSQUARE         reduce using rule 105 (field_access -> primary DOT IDENTIFIER .)


state 151

    (96) primary -> NEW IDENTIFIER LPAREN . arguments RPAREN
    (99) arguments -> . expr
    (100) arguments -> . COMMA arguments
    (58) expr -> . primary
    (59) expr -> . assign
    (60) expr -> . new_array
    (61) expr -> . expr PLUS expr
    (62) expr -> . expr MINUS expr
    (63) expr -> . expr MULT expr
    (64) expr -> . expr DIV expr
    (65) expr -> . expr OR expr
    (66) expr -> . expr AND expr
    (67) expr -> . expr EQUALS expr
    (68) expr -> . expr NOTEQUALS expr
    (69) expr -> . expr LT expr
    (70) expr -> . expr GT expr
    (71) expr -> . expr LEQ expr
    (72) expr -> . expr GEQ expr
    (73) expr -> . PLUS expr
    (74) expr -> . MINUS expr
    (75) expr -> . NOT expr
    (92) primary -> . literal
    (93) primary -> . THIS
    (94) primary -> . SUPER
    (95) primary -> . LPAREN expr RPAREN
    (96) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (97) primary -> . lhs
    (98) primary -> . method_invocation
    (76) assign -> . lhs ASSIGN expr
    (77) assign -> . lhs PLUSPLUS
    (78) assign -> . PLUSPLUS lhs
    (79) assign -> . lhs MINUSMINUS
    (80) assign -> . MINUSMINUS lhs
    (81) new_array -> . NEW type expr_array_helper1 expr_array_helper2
    (87) literal -> . INTEGERCONSTANT
    (88) literal -> . FLOATCONSTANT
    (89) literal -> . NULL
    (90) literal -> . TRUE
    (91) literal -> . FALSE
    (101) lhs -> . field_access
    (102) lhs -> . array_access
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN expr RPAREN
    (105) field_access -> . primary DOT IDENTIFIER
    (106) field_access -> . IDENTIFIER
    (107) array_access -> . primary LPAREN expr RPAREN

    COMMA           shift and go to state 178
    PLUS            shift and go to state 92
    MINUS           shift and go to state 88
    NOT             shift and go to state 104
    THIS            shift and go to state 101
    SUPER           shift and go to state 105
    LPAREN          shift and go to state 97
    NEW             shift and go to state 85
    PLUSPLUS        shift and go to state 96
    MINUSMINUS      shift and go to state 98
    INTEGERCONSTANT shift and go to state 84
    FLOATCONSTANT   shift and go to state 99
    NULL            shift and go to state 86
    TRUE            shift and go to state 87
    FALSE           shift and go to state 100
    IDENTIFIER      shift and go to state 94

    new_array                      shift and go to state 82
    field_access                   shift and go to state 95
    expr                           shift and go to state 179
    primary                        shift and go to state 83
    array_access                   shift and go to state 90
    literal                        shift and go to state 91
    lhs                            shift and go to state 103
    arguments                      shift and go to state 177
    method_invocation              shift and go to state 93
    assign                         shift and go to state 106

state 152

    (82) expr_array_helper1 -> LSQUARE . expr RSQUARE
    (83) expr_array_helper1 -> LSQUARE . expr RSQUARE expr_array_helper1
    (58) expr -> . primary
    (59) expr -> . assign
    (60) expr -> . new_array
    (61) expr -> . expr PLUS expr
    (62) expr -> . expr MINUS expr
    (63) expr -> . expr MULT expr
    (64) expr -> . expr DIV expr
    (65) expr -> . expr OR expr
    (66) expr -> . expr AND expr
    (67) expr -> . expr EQUALS expr
    (68) expr -> . expr NOTEQUALS expr
    (69) expr -> . expr LT expr
    (70) expr -> . expr GT expr
    (71) expr -> . expr LEQ expr
    (72) expr -> . expr GEQ expr
    (73) expr -> . PLUS expr
    (74) expr -> . MINUS expr
    (75) expr -> . NOT expr
    (92) primary -> . literal
    (93) primary -> . THIS
    (94) primary -> . SUPER
    (95) primary -> . LPAREN expr RPAREN
    (96) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (97) primary -> . lhs
    (98) primary -> . method_invocation
    (76) assign -> . lhs ASSIGN expr
    (77) assign -> . lhs PLUSPLUS
    (78) assign -> . PLUSPLUS lhs
    (79) assign -> . lhs MINUSMINUS
    (80) assign -> . MINUSMINUS lhs
    (81) new_array -> . NEW type expr_array_helper1 expr_array_helper2
    (87) literal -> . INTEGERCONSTANT
    (88) literal -> . FLOATCONSTANT
    (89) literal -> . NULL
    (90) literal -> . TRUE
    (91) literal -> . FALSE
    (101) lhs -> . field_access
    (102) lhs -> . array_access
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN expr RPAREN
    (105) field_access -> . primary DOT IDENTIFIER
    (106) field_access -> . IDENTIFIER
    (107) array_access -> . primary LPAREN expr RPAREN

    PLUS            shift and go to state 92
    MINUS           shift and go to state 88
    NOT             shift and go to state 104
    THIS            shift and go to state 101
    SUPER           shift and go to state 105
    LPAREN          shift and go to state 97
    NEW             shift and go to state 85
    PLUSPLUS        shift and go to state 96
    MINUSMINUS      shift and go to state 98
    INTEGERCONSTANT shift and go to state 84
    FLOATCONSTANT   shift and go to state 99
    NULL            shift and go to state 86
    TRUE            shift and go to state 87
    FALSE           shift and go to state 100
    IDENTIFIER      shift and go to state 94

    new_array                      shift and go to state 82
    field_access                   shift and go to state 95
    expr                           shift and go to state 180
    primary                        shift and go to state 83
    array_access                   shift and go to state 90
    literal                        shift and go to state 91
    lhs                            shift and go to state 103
    method_invocation              shift and go to state 93
    assign                         shift and go to state 106

state 153

    (81) new_array -> NEW type expr_array_helper1 . expr_array_helper2
    (84) expr_array_helper2 -> . empty
    (85) expr_array_helper2 -> . LSQUARE RSQUARE expr_array_helper2
    (108) empty -> .

    LSQUARE         shift and go to state 181
    SEMICOLON       reduce using rule 108 (empty -> .)
    PLUS            reduce using rule 108 (empty -> .)
    MINUS           reduce using rule 108 (empty -> .)
    MULT            reduce using rule 108 (empty -> .)
    DIV             reduce using rule 108 (empty -> .)
    OR              reduce using rule 108 (empty -> .)
    AND             reduce using rule 108 (empty -> .)
    EQUALS          reduce using rule 108 (empty -> .)
    NOTEQUALS       reduce using rule 108 (empty -> .)
    LT              reduce using rule 108 (empty -> .)
    GT              reduce using rule 108 (empty -> .)
    LEQ             reduce using rule 108 (empty -> .)
    GEQ             reduce using rule 108 (empty -> .)
    RPAREN          reduce using rule 108 (empty -> .)
    RSQUARE         reduce using rule 108 (empty -> .)

    expr_array_helper2             shift and go to state 182
    empty                          shift and go to state 183

state 154

    (103) method_invocation -> field_access LPAREN RPAREN .

    DOT             reduce using rule 103 (method_invocation -> field_access LPAREN RPAREN .)
    LPAREN          reduce using rule 103 (method_invocation -> field_access LPAREN RPAREN .)
    PLUS            reduce using rule 103 (method_invocation -> field_access LPAREN RPAREN .)
    MINUS           reduce using rule 103 (method_invocation -> field_access LPAREN RPAREN .)
    MULT            reduce using rule 103 (method_invocation -> field_access LPAREN RPAREN .)
    DIV             reduce using rule 103 (method_invocation -> field_access LPAREN RPAREN .)
    OR              reduce using rule 103 (method_invocation -> field_access LPAREN RPAREN .)
    AND             reduce using rule 103 (method_invocation -> field_access LPAREN RPAREN .)
    EQUALS          reduce using rule 103 (method_invocation -> field_access LPAREN RPAREN .)
    NOTEQUALS       reduce using rule 103 (method_invocation -> field_access LPAREN RPAREN .)
    LT              reduce using rule 103 (method_invocation -> field_access LPAREN RPAREN .)
    GT              reduce using rule 103 (method_invocation -> field_access LPAREN RPAREN .)
    LEQ             reduce using rule 103 (method_invocation -> field_access LPAREN RPAREN .)
    GEQ             reduce using rule 103 (method_invocation -> field_access LPAREN RPAREN .)
    SEMICOLON       reduce using rule 103 (method_invocation -> field_access LPAREN RPAREN .)
    RPAREN          reduce using rule 103 (method_invocation -> field_access LPAREN RPAREN .)
    RSQUARE         reduce using rule 103 (method_invocation -> field_access LPAREN RPAREN .)


state 155

    (104) method_invocation -> field_access LPAREN expr . RPAREN
    (61) expr -> expr . PLUS expr
    (62) expr -> expr . MINUS expr
    (63) expr -> expr . MULT expr
    (64) expr -> expr . DIV expr
    (65) expr -> expr . OR expr
    (66) expr -> expr . AND expr
    (67) expr -> expr . EQUALS expr
    (68) expr -> expr . NOTEQUALS expr
    (69) expr -> expr . LT expr
    (70) expr -> expr . GT expr
    (71) expr -> expr . LEQ expr
    (72) expr -> expr . GEQ expr

    RPAREN          shift and go to state 184
    PLUS            shift and go to state 137
    MINUS           shift and go to state 139
    MULT            shift and go to state 140
    DIV             shift and go to state 138
    OR              shift and go to state 134
    AND             shift and go to state 128
    EQUALS          shift and go to state 133
    NOTEQUALS       shift and go to state 129
    LT              shift and go to state 136
    GT              shift and go to state 131
    LEQ             shift and go to state 135
    GEQ             shift and go to state 130


state 156

    (96) primary -> NEW IDENTIFIER . LPAREN arguments RPAREN

    LPAREN          shift and go to state 151


state 157

    (95) primary -> LPAREN expr RPAREN .

    DOT             reduce using rule 95 (primary -> LPAREN expr RPAREN .)
    LPAREN          reduce using rule 95 (primary -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 95 (primary -> LPAREN expr RPAREN .)
    PLUS            reduce using rule 95 (primary -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 95 (primary -> LPAREN expr RPAREN .)
    MULT            reduce using rule 95 (primary -> LPAREN expr RPAREN .)
    DIV             reduce using rule 95 (primary -> LPAREN expr RPAREN .)
    OR              reduce using rule 95 (primary -> LPAREN expr RPAREN .)
    AND             reduce using rule 95 (primary -> LPAREN expr RPAREN .)
    EQUALS          reduce using rule 95 (primary -> LPAREN expr RPAREN .)
    NOTEQUALS       reduce using rule 95 (primary -> LPAREN expr RPAREN .)
    LT              reduce using rule 95 (primary -> LPAREN expr RPAREN .)
    GT              reduce using rule 95 (primary -> LPAREN expr RPAREN .)
    LEQ             reduce using rule 95 (primary -> LPAREN expr RPAREN .)
    GEQ             reduce using rule 95 (primary -> LPAREN expr RPAREN .)
    SEMICOLON       reduce using rule 95 (primary -> LPAREN expr RPAREN .)
    RSQUARE         reduce using rule 95 (primary -> LPAREN expr RPAREN .)


state 158

    (66) expr -> expr AND expr .
    (61) expr -> expr . PLUS expr
    (62) expr -> expr . MINUS expr
    (63) expr -> expr . MULT expr
    (64) expr -> expr . DIV expr
    (65) expr -> expr . OR expr
    (66) expr -> expr . AND expr
    (67) expr -> expr . EQUALS expr
    (68) expr -> expr . NOTEQUALS expr
    (69) expr -> expr . LT expr
    (70) expr -> expr . GT expr
    (71) expr -> expr . LEQ expr
    (72) expr -> expr . GEQ expr

    RPAREN          reduce using rule 66 (expr -> expr AND expr .)
    MINUS           reduce using rule 66 (expr -> expr AND expr .)
    OR              reduce using rule 66 (expr -> expr AND expr .)
    AND             reduce using rule 66 (expr -> expr AND expr .)
    SEMICOLON       reduce using rule 66 (expr -> expr AND expr .)
    RSQUARE         reduce using rule 66 (expr -> expr AND expr .)
    PLUS            shift and go to state 137
    MULT            shift and go to state 140
    DIV             shift and go to state 138
    EQUALS          shift and go to state 133
    NOTEQUALS       shift and go to state 129
    LT              shift and go to state 136
    GT              shift and go to state 131
    LEQ             shift and go to state 135
    GEQ             shift and go to state 130

  ! PLUS            [ reduce using rule 66 (expr -> expr AND expr .) ]
  ! MULT            [ reduce using rule 66 (expr -> expr AND expr .) ]
  ! DIV             [ reduce using rule 66 (expr -> expr AND expr .) ]
  ! EQUALS          [ reduce using rule 66 (expr -> expr AND expr .) ]
  ! NOTEQUALS       [ reduce using rule 66 (expr -> expr AND expr .) ]
  ! LT              [ reduce using rule 66 (expr -> expr AND expr .) ]
  ! GT              [ reduce using rule 66 (expr -> expr AND expr .) ]
  ! LEQ             [ reduce using rule 66 (expr -> expr AND expr .) ]
  ! GEQ             [ reduce using rule 66 (expr -> expr AND expr .) ]
  ! MINUS           [ shift and go to state 139 ]
  ! OR              [ shift and go to state 134 ]
  ! AND             [ shift and go to state 128 ]


state 159

    (68) expr -> expr NOTEQUALS expr .
    (61) expr -> expr . PLUS expr
    (62) expr -> expr . MINUS expr
    (63) expr -> expr . MULT expr
    (64) expr -> expr . DIV expr
    (65) expr -> expr . OR expr
    (66) expr -> expr . AND expr
    (67) expr -> expr . EQUALS expr
    (68) expr -> expr . NOTEQUALS expr
    (69) expr -> expr . LT expr
    (70) expr -> expr . GT expr
    (71) expr -> expr . LEQ expr
    (72) expr -> expr . GEQ expr

    RPAREN          reduce using rule 68 (expr -> expr NOTEQUALS expr .)
    MINUS           reduce using rule 68 (expr -> expr NOTEQUALS expr .)
    OR              reduce using rule 68 (expr -> expr NOTEQUALS expr .)
    AND             reduce using rule 68 (expr -> expr NOTEQUALS expr .)
    EQUALS          reduce using rule 68 (expr -> expr NOTEQUALS expr .)
    NOTEQUALS       reduce using rule 68 (expr -> expr NOTEQUALS expr .)
    SEMICOLON       reduce using rule 68 (expr -> expr NOTEQUALS expr .)
    RSQUARE         reduce using rule 68 (expr -> expr NOTEQUALS expr .)
    PLUS            shift and go to state 137
    MULT            shift and go to state 140
    DIV             shift and go to state 138
    LT              shift and go to state 136
    GT              shift and go to state 131
    LEQ             shift and go to state 135
    GEQ             shift and go to state 130

  ! PLUS            [ reduce using rule 68 (expr -> expr NOTEQUALS expr .) ]
  ! MULT            [ reduce using rule 68 (expr -> expr NOTEQUALS expr .) ]
  ! DIV             [ reduce using rule 68 (expr -> expr NOTEQUALS expr .) ]
  ! LT              [ reduce using rule 68 (expr -> expr NOTEQUALS expr .) ]
  ! GT              [ reduce using rule 68 (expr -> expr NOTEQUALS expr .) ]
  ! LEQ             [ reduce using rule 68 (expr -> expr NOTEQUALS expr .) ]
  ! GEQ             [ reduce using rule 68 (expr -> expr NOTEQUALS expr .) ]
  ! MINUS           [ shift and go to state 139 ]
  ! OR              [ shift and go to state 134 ]
  ! AND             [ shift and go to state 128 ]
  ! EQUALS          [ shift and go to state 133 ]
  ! NOTEQUALS       [ shift and go to state 129 ]


state 160

    (72) expr -> expr GEQ expr .
    (61) expr -> expr . PLUS expr
    (62) expr -> expr . MINUS expr
    (63) expr -> expr . MULT expr
    (64) expr -> expr . DIV expr
    (65) expr -> expr . OR expr
    (66) expr -> expr . AND expr
    (67) expr -> expr . EQUALS expr
    (68) expr -> expr . NOTEQUALS expr
    (69) expr -> expr . LT expr
    (70) expr -> expr . GT expr
    (71) expr -> expr . LEQ expr
    (72) expr -> expr . GEQ expr

    RPAREN          reduce using rule 72 (expr -> expr GEQ expr .)
    MINUS           reduce using rule 72 (expr -> expr GEQ expr .)
    OR              reduce using rule 72 (expr -> expr GEQ expr .)
    AND             reduce using rule 72 (expr -> expr GEQ expr .)
    EQUALS          reduce using rule 72 (expr -> expr GEQ expr .)
    NOTEQUALS       reduce using rule 72 (expr -> expr GEQ expr .)
    LT              reduce using rule 72 (expr -> expr GEQ expr .)
    GT              reduce using rule 72 (expr -> expr GEQ expr .)
    LEQ             reduce using rule 72 (expr -> expr GEQ expr .)
    GEQ             reduce using rule 72 (expr -> expr GEQ expr .)
    SEMICOLON       reduce using rule 72 (expr -> expr GEQ expr .)
    RSQUARE         reduce using rule 72 (expr -> expr GEQ expr .)
    PLUS            shift and go to state 137
    MULT            shift and go to state 140
    DIV             shift and go to state 138

  ! PLUS            [ reduce using rule 72 (expr -> expr GEQ expr .) ]
  ! MULT            [ reduce using rule 72 (expr -> expr GEQ expr .) ]
  ! DIV             [ reduce using rule 72 (expr -> expr GEQ expr .) ]
  ! MINUS           [ shift and go to state 139 ]
  ! OR              [ shift and go to state 134 ]
  ! AND             [ shift and go to state 128 ]
  ! EQUALS          [ shift and go to state 133 ]
  ! NOTEQUALS       [ shift and go to state 129 ]
  ! LT              [ shift and go to state 136 ]
  ! GT              [ shift and go to state 131 ]
  ! LEQ             [ shift and go to state 135 ]
  ! GEQ             [ shift and go to state 130 ]


state 161

    (70) expr -> expr GT expr .
    (61) expr -> expr . PLUS expr
    (62) expr -> expr . MINUS expr
    (63) expr -> expr . MULT expr
    (64) expr -> expr . DIV expr
    (65) expr -> expr . OR expr
    (66) expr -> expr . AND expr
    (67) expr -> expr . EQUALS expr
    (68) expr -> expr . NOTEQUALS expr
    (69) expr -> expr . LT expr
    (70) expr -> expr . GT expr
    (71) expr -> expr . LEQ expr
    (72) expr -> expr . GEQ expr

    RPAREN          reduce using rule 70 (expr -> expr GT expr .)
    MINUS           reduce using rule 70 (expr -> expr GT expr .)
    OR              reduce using rule 70 (expr -> expr GT expr .)
    AND             reduce using rule 70 (expr -> expr GT expr .)
    EQUALS          reduce using rule 70 (expr -> expr GT expr .)
    NOTEQUALS       reduce using rule 70 (expr -> expr GT expr .)
    LT              reduce using rule 70 (expr -> expr GT expr .)
    GT              reduce using rule 70 (expr -> expr GT expr .)
    LEQ             reduce using rule 70 (expr -> expr GT expr .)
    GEQ             reduce using rule 70 (expr -> expr GT expr .)
    SEMICOLON       reduce using rule 70 (expr -> expr GT expr .)
    RSQUARE         reduce using rule 70 (expr -> expr GT expr .)
    PLUS            shift and go to state 137
    MULT            shift and go to state 140
    DIV             shift and go to state 138

  ! PLUS            [ reduce using rule 70 (expr -> expr GT expr .) ]
  ! MULT            [ reduce using rule 70 (expr -> expr GT expr .) ]
  ! DIV             [ reduce using rule 70 (expr -> expr GT expr .) ]
  ! MINUS           [ shift and go to state 139 ]
  ! OR              [ shift and go to state 134 ]
  ! AND             [ shift and go to state 128 ]
  ! EQUALS          [ shift and go to state 133 ]
  ! NOTEQUALS       [ shift and go to state 129 ]
  ! LT              [ shift and go to state 136 ]
  ! GT              [ shift and go to state 131 ]
  ! LEQ             [ shift and go to state 135 ]
  ! GEQ             [ shift and go to state 130 ]


state 162

    (67) expr -> expr EQUALS expr .
    (61) expr -> expr . PLUS expr
    (62) expr -> expr . MINUS expr
    (63) expr -> expr . MULT expr
    (64) expr -> expr . DIV expr
    (65) expr -> expr . OR expr
    (66) expr -> expr . AND expr
    (67) expr -> expr . EQUALS expr
    (68) expr -> expr . NOTEQUALS expr
    (69) expr -> expr . LT expr
    (70) expr -> expr . GT expr
    (71) expr -> expr . LEQ expr
    (72) expr -> expr . GEQ expr

    RPAREN          reduce using rule 67 (expr -> expr EQUALS expr .)
    MINUS           reduce using rule 67 (expr -> expr EQUALS expr .)
    OR              reduce using rule 67 (expr -> expr EQUALS expr .)
    AND             reduce using rule 67 (expr -> expr EQUALS expr .)
    EQUALS          reduce using rule 67 (expr -> expr EQUALS expr .)
    NOTEQUALS       reduce using rule 67 (expr -> expr EQUALS expr .)
    SEMICOLON       reduce using rule 67 (expr -> expr EQUALS expr .)
    RSQUARE         reduce using rule 67 (expr -> expr EQUALS expr .)
    PLUS            shift and go to state 137
    MULT            shift and go to state 140
    DIV             shift and go to state 138
    LT              shift and go to state 136
    GT              shift and go to state 131
    LEQ             shift and go to state 135
    GEQ             shift and go to state 130

  ! PLUS            [ reduce using rule 67 (expr -> expr EQUALS expr .) ]
  ! MULT            [ reduce using rule 67 (expr -> expr EQUALS expr .) ]
  ! DIV             [ reduce using rule 67 (expr -> expr EQUALS expr .) ]
  ! LT              [ reduce using rule 67 (expr -> expr EQUALS expr .) ]
  ! GT              [ reduce using rule 67 (expr -> expr EQUALS expr .) ]
  ! LEQ             [ reduce using rule 67 (expr -> expr EQUALS expr .) ]
  ! GEQ             [ reduce using rule 67 (expr -> expr EQUALS expr .) ]
  ! MINUS           [ shift and go to state 139 ]
  ! OR              [ shift and go to state 134 ]
  ! AND             [ shift and go to state 128 ]
  ! EQUALS          [ shift and go to state 133 ]
  ! NOTEQUALS       [ shift and go to state 129 ]


state 163

    (65) expr -> expr OR expr .
    (61) expr -> expr . PLUS expr
    (62) expr -> expr . MINUS expr
    (63) expr -> expr . MULT expr
    (64) expr -> expr . DIV expr
    (65) expr -> expr . OR expr
    (66) expr -> expr . AND expr
    (67) expr -> expr . EQUALS expr
    (68) expr -> expr . NOTEQUALS expr
    (69) expr -> expr . LT expr
    (70) expr -> expr . GT expr
    (71) expr -> expr . LEQ expr
    (72) expr -> expr . GEQ expr

    RPAREN          reduce using rule 65 (expr -> expr OR expr .)
    MINUS           reduce using rule 65 (expr -> expr OR expr .)
    OR              reduce using rule 65 (expr -> expr OR expr .)
    SEMICOLON       reduce using rule 65 (expr -> expr OR expr .)
    RSQUARE         reduce using rule 65 (expr -> expr OR expr .)
    PLUS            shift and go to state 137
    MULT            shift and go to state 140
    DIV             shift and go to state 138
    AND             shift and go to state 128
    EQUALS          shift and go to state 133
    NOTEQUALS       shift and go to state 129
    LT              shift and go to state 136
    GT              shift and go to state 131
    LEQ             shift and go to state 135
    GEQ             shift and go to state 130

  ! PLUS            [ reduce using rule 65 (expr -> expr OR expr .) ]
  ! MULT            [ reduce using rule 65 (expr -> expr OR expr .) ]
  ! DIV             [ reduce using rule 65 (expr -> expr OR expr .) ]
  ! AND             [ reduce using rule 65 (expr -> expr OR expr .) ]
  ! EQUALS          [ reduce using rule 65 (expr -> expr OR expr .) ]
  ! NOTEQUALS       [ reduce using rule 65 (expr -> expr OR expr .) ]
  ! LT              [ reduce using rule 65 (expr -> expr OR expr .) ]
  ! GT              [ reduce using rule 65 (expr -> expr OR expr .) ]
  ! LEQ             [ reduce using rule 65 (expr -> expr OR expr .) ]
  ! GEQ             [ reduce using rule 65 (expr -> expr OR expr .) ]
  ! MINUS           [ shift and go to state 139 ]
  ! OR              [ shift and go to state 134 ]


state 164

    (71) expr -> expr LEQ expr .
    (61) expr -> expr . PLUS expr
    (62) expr -> expr . MINUS expr
    (63) expr -> expr . MULT expr
    (64) expr -> expr . DIV expr
    (65) expr -> expr . OR expr
    (66) expr -> expr . AND expr
    (67) expr -> expr . EQUALS expr
    (68) expr -> expr . NOTEQUALS expr
    (69) expr -> expr . LT expr
    (70) expr -> expr . GT expr
    (71) expr -> expr . LEQ expr
    (72) expr -> expr . GEQ expr

    RPAREN          reduce using rule 71 (expr -> expr LEQ expr .)
    MINUS           reduce using rule 71 (expr -> expr LEQ expr .)
    OR              reduce using rule 71 (expr -> expr LEQ expr .)
    AND             reduce using rule 71 (expr -> expr LEQ expr .)
    EQUALS          reduce using rule 71 (expr -> expr LEQ expr .)
    NOTEQUALS       reduce using rule 71 (expr -> expr LEQ expr .)
    LT              reduce using rule 71 (expr -> expr LEQ expr .)
    GT              reduce using rule 71 (expr -> expr LEQ expr .)
    LEQ             reduce using rule 71 (expr -> expr LEQ expr .)
    GEQ             reduce using rule 71 (expr -> expr LEQ expr .)
    SEMICOLON       reduce using rule 71 (expr -> expr LEQ expr .)
    RSQUARE         reduce using rule 71 (expr -> expr LEQ expr .)
    PLUS            shift and go to state 137
    MULT            shift and go to state 140
    DIV             shift and go to state 138

  ! PLUS            [ reduce using rule 71 (expr -> expr LEQ expr .) ]
  ! MULT            [ reduce using rule 71 (expr -> expr LEQ expr .) ]
  ! DIV             [ reduce using rule 71 (expr -> expr LEQ expr .) ]
  ! MINUS           [ shift and go to state 139 ]
  ! OR              [ shift and go to state 134 ]
  ! AND             [ shift and go to state 128 ]
  ! EQUALS          [ shift and go to state 133 ]
  ! NOTEQUALS       [ shift and go to state 129 ]
  ! LT              [ shift and go to state 136 ]
  ! GT              [ shift and go to state 131 ]
  ! LEQ             [ shift and go to state 135 ]
  ! GEQ             [ shift and go to state 130 ]


state 165

    (69) expr -> expr LT expr .
    (61) expr -> expr . PLUS expr
    (62) expr -> expr . MINUS expr
    (63) expr -> expr . MULT expr
    (64) expr -> expr . DIV expr
    (65) expr -> expr . OR expr
    (66) expr -> expr . AND expr
    (67) expr -> expr . EQUALS expr
    (68) expr -> expr . NOTEQUALS expr
    (69) expr -> expr . LT expr
    (70) expr -> expr . GT expr
    (71) expr -> expr . LEQ expr
    (72) expr -> expr . GEQ expr

    RPAREN          reduce using rule 69 (expr -> expr LT expr .)
    MINUS           reduce using rule 69 (expr -> expr LT expr .)
    OR              reduce using rule 69 (expr -> expr LT expr .)
    AND             reduce using rule 69 (expr -> expr LT expr .)
    EQUALS          reduce using rule 69 (expr -> expr LT expr .)
    NOTEQUALS       reduce using rule 69 (expr -> expr LT expr .)
    LT              reduce using rule 69 (expr -> expr LT expr .)
    GT              reduce using rule 69 (expr -> expr LT expr .)
    LEQ             reduce using rule 69 (expr -> expr LT expr .)
    GEQ             reduce using rule 69 (expr -> expr LT expr .)
    SEMICOLON       reduce using rule 69 (expr -> expr LT expr .)
    RSQUARE         reduce using rule 69 (expr -> expr LT expr .)
    PLUS            shift and go to state 137
    MULT            shift and go to state 140
    DIV             shift and go to state 138

  ! PLUS            [ reduce using rule 69 (expr -> expr LT expr .) ]
  ! MULT            [ reduce using rule 69 (expr -> expr LT expr .) ]
  ! DIV             [ reduce using rule 69 (expr -> expr LT expr .) ]
  ! MINUS           [ shift and go to state 139 ]
  ! OR              [ shift and go to state 134 ]
  ! AND             [ shift and go to state 128 ]
  ! EQUALS          [ shift and go to state 133 ]
  ! NOTEQUALS       [ shift and go to state 129 ]
  ! LT              [ shift and go to state 136 ]
  ! GT              [ shift and go to state 131 ]
  ! LEQ             [ shift and go to state 135 ]
  ! GEQ             [ shift and go to state 130 ]


state 166

    (61) expr -> expr PLUS expr .
    (61) expr -> expr . PLUS expr
    (62) expr -> expr . MINUS expr
    (63) expr -> expr . MULT expr
    (64) expr -> expr . DIV expr
    (65) expr -> expr . OR expr
    (66) expr -> expr . AND expr
    (67) expr -> expr . EQUALS expr
    (68) expr -> expr . NOTEQUALS expr
    (69) expr -> expr . LT expr
    (70) expr -> expr . GT expr
    (71) expr -> expr . LEQ expr
    (72) expr -> expr . GEQ expr

    RPAREN          reduce using rule 61 (expr -> expr PLUS expr .)
    PLUS            reduce using rule 61 (expr -> expr PLUS expr .)
    MINUS           reduce using rule 61 (expr -> expr PLUS expr .)
    OR              reduce using rule 61 (expr -> expr PLUS expr .)
    AND             reduce using rule 61 (expr -> expr PLUS expr .)
    EQUALS          reduce using rule 61 (expr -> expr PLUS expr .)
    NOTEQUALS       reduce using rule 61 (expr -> expr PLUS expr .)
    LT              reduce using rule 61 (expr -> expr PLUS expr .)
    GT              reduce using rule 61 (expr -> expr PLUS expr .)
    LEQ             reduce using rule 61 (expr -> expr PLUS expr .)
    GEQ             reduce using rule 61 (expr -> expr PLUS expr .)
    SEMICOLON       reduce using rule 61 (expr -> expr PLUS expr .)
    RSQUARE         reduce using rule 61 (expr -> expr PLUS expr .)
    MULT            shift and go to state 140
    DIV             shift and go to state 138

  ! MULT            [ reduce using rule 61 (expr -> expr PLUS expr .) ]
  ! DIV             [ reduce using rule 61 (expr -> expr PLUS expr .) ]
  ! PLUS            [ shift and go to state 137 ]
  ! MINUS           [ shift and go to state 139 ]
  ! OR              [ shift and go to state 134 ]
  ! AND             [ shift and go to state 128 ]
  ! EQUALS          [ shift and go to state 133 ]
  ! NOTEQUALS       [ shift and go to state 129 ]
  ! LT              [ shift and go to state 136 ]
  ! GT              [ shift and go to state 131 ]
  ! LEQ             [ shift and go to state 135 ]
  ! GEQ             [ shift and go to state 130 ]


state 167

    (64) expr -> expr DIV expr .
    (61) expr -> expr . PLUS expr
    (62) expr -> expr . MINUS expr
    (63) expr -> expr . MULT expr
    (64) expr -> expr . DIV expr
    (65) expr -> expr . OR expr
    (66) expr -> expr . AND expr
    (67) expr -> expr . EQUALS expr
    (68) expr -> expr . NOTEQUALS expr
    (69) expr -> expr . LT expr
    (70) expr -> expr . GT expr
    (71) expr -> expr . LEQ expr
    (72) expr -> expr . GEQ expr

    RPAREN          reduce using rule 64 (expr -> expr DIV expr .)
    PLUS            reduce using rule 64 (expr -> expr DIV expr .)
    MINUS           reduce using rule 64 (expr -> expr DIV expr .)
    MULT            reduce using rule 64 (expr -> expr DIV expr .)
    DIV             reduce using rule 64 (expr -> expr DIV expr .)
    OR              reduce using rule 64 (expr -> expr DIV expr .)
    AND             reduce using rule 64 (expr -> expr DIV expr .)
    EQUALS          reduce using rule 64 (expr -> expr DIV expr .)
    NOTEQUALS       reduce using rule 64 (expr -> expr DIV expr .)
    LT              reduce using rule 64 (expr -> expr DIV expr .)
    GT              reduce using rule 64 (expr -> expr DIV expr .)
    LEQ             reduce using rule 64 (expr -> expr DIV expr .)
    GEQ             reduce using rule 64 (expr -> expr DIV expr .)
    SEMICOLON       reduce using rule 64 (expr -> expr DIV expr .)
    RSQUARE         reduce using rule 64 (expr -> expr DIV expr .)

  ! PLUS            [ shift and go to state 137 ]
  ! MINUS           [ shift and go to state 139 ]
  ! MULT            [ shift and go to state 140 ]
  ! DIV             [ shift and go to state 138 ]
  ! OR              [ shift and go to state 134 ]
  ! AND             [ shift and go to state 128 ]
  ! EQUALS          [ shift and go to state 133 ]
  ! NOTEQUALS       [ shift and go to state 129 ]
  ! LT              [ shift and go to state 136 ]
  ! GT              [ shift and go to state 131 ]
  ! LEQ             [ shift and go to state 135 ]
  ! GEQ             [ shift and go to state 130 ]


state 168

    (62) expr -> expr MINUS expr .
    (61) expr -> expr . PLUS expr
    (62) expr -> expr . MINUS expr
    (63) expr -> expr . MULT expr
    (64) expr -> expr . DIV expr
    (65) expr -> expr . OR expr
    (66) expr -> expr . AND expr
    (67) expr -> expr . EQUALS expr
    (68) expr -> expr . NOTEQUALS expr
    (69) expr -> expr . LT expr
    (70) expr -> expr . GT expr
    (71) expr -> expr . LEQ expr
    (72) expr -> expr . GEQ expr

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for NOTEQUALS resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LEQ resolved as shift
  ! shift/reduce conflict for GEQ resolved as shift
    RPAREN          reduce using rule 62 (expr -> expr MINUS expr .)
    SEMICOLON       reduce using rule 62 (expr -> expr MINUS expr .)
    RSQUARE         reduce using rule 62 (expr -> expr MINUS expr .)
    PLUS            shift and go to state 137
    MINUS           shift and go to state 139
    MULT            shift and go to state 140
    DIV             shift and go to state 138
    OR              shift and go to state 134
    AND             shift and go to state 128
    EQUALS          shift and go to state 133
    NOTEQUALS       shift and go to state 129
    LT              shift and go to state 136
    GT              shift and go to state 131
    LEQ             shift and go to state 135
    GEQ             shift and go to state 130

  ! PLUS            [ reduce using rule 62 (expr -> expr MINUS expr .) ]
  ! MINUS           [ reduce using rule 62 (expr -> expr MINUS expr .) ]
  ! MULT            [ reduce using rule 62 (expr -> expr MINUS expr .) ]
  ! DIV             [ reduce using rule 62 (expr -> expr MINUS expr .) ]
  ! OR              [ reduce using rule 62 (expr -> expr MINUS expr .) ]
  ! AND             [ reduce using rule 62 (expr -> expr MINUS expr .) ]
  ! EQUALS          [ reduce using rule 62 (expr -> expr MINUS expr .) ]
  ! NOTEQUALS       [ reduce using rule 62 (expr -> expr MINUS expr .) ]
  ! LT              [ reduce using rule 62 (expr -> expr MINUS expr .) ]
  ! GT              [ reduce using rule 62 (expr -> expr MINUS expr .) ]
  ! LEQ             [ reduce using rule 62 (expr -> expr MINUS expr .) ]
  ! GEQ             [ reduce using rule 62 (expr -> expr MINUS expr .) ]


state 169

    (63) expr -> expr MULT expr .
    (61) expr -> expr . PLUS expr
    (62) expr -> expr . MINUS expr
    (63) expr -> expr . MULT expr
    (64) expr -> expr . DIV expr
    (65) expr -> expr . OR expr
    (66) expr -> expr . AND expr
    (67) expr -> expr . EQUALS expr
    (68) expr -> expr . NOTEQUALS expr
    (69) expr -> expr . LT expr
    (70) expr -> expr . GT expr
    (71) expr -> expr . LEQ expr
    (72) expr -> expr . GEQ expr

    RPAREN          reduce using rule 63 (expr -> expr MULT expr .)
    PLUS            reduce using rule 63 (expr -> expr MULT expr .)
    MINUS           reduce using rule 63 (expr -> expr MULT expr .)
    MULT            reduce using rule 63 (expr -> expr MULT expr .)
    DIV             reduce using rule 63 (expr -> expr MULT expr .)
    OR              reduce using rule 63 (expr -> expr MULT expr .)
    AND             reduce using rule 63 (expr -> expr MULT expr .)
    EQUALS          reduce using rule 63 (expr -> expr MULT expr .)
    NOTEQUALS       reduce using rule 63 (expr -> expr MULT expr .)
    LT              reduce using rule 63 (expr -> expr MULT expr .)
    GT              reduce using rule 63 (expr -> expr MULT expr .)
    LEQ             reduce using rule 63 (expr -> expr MULT expr .)
    GEQ             reduce using rule 63 (expr -> expr MULT expr .)
    SEMICOLON       reduce using rule 63 (expr -> expr MULT expr .)
    RSQUARE         reduce using rule 63 (expr -> expr MULT expr .)

  ! PLUS            [ shift and go to state 137 ]
  ! MINUS           [ shift and go to state 139 ]
  ! MULT            [ shift and go to state 140 ]
  ! DIV             [ shift and go to state 138 ]
  ! OR              [ shift and go to state 134 ]
  ! AND             [ shift and go to state 128 ]
  ! EQUALS          [ shift and go to state 133 ]
  ! NOTEQUALS       [ shift and go to state 129 ]
  ! LT              [ shift and go to state 136 ]
  ! GT              [ shift and go to state 131 ]
  ! LEQ             [ shift and go to state 135 ]
  ! GEQ             [ shift and go to state 130 ]


state 170

    (76) assign -> lhs ASSIGN expr .
    (61) expr -> expr . PLUS expr
    (62) expr -> expr . MINUS expr
    (63) expr -> expr . MULT expr
    (64) expr -> expr . DIV expr
    (65) expr -> expr . OR expr
    (66) expr -> expr . AND expr
    (67) expr -> expr . EQUALS expr
    (68) expr -> expr . NOTEQUALS expr
    (69) expr -> expr . LT expr
    (70) expr -> expr . GT expr
    (71) expr -> expr . LEQ expr
    (72) expr -> expr . GEQ expr

    RSQUARE         reduce using rule 76 (assign -> lhs ASSIGN expr .)
    MINUS           reduce using rule 76 (assign -> lhs ASSIGN expr .)
    RPAREN          reduce using rule 76 (assign -> lhs ASSIGN expr .)
    SEMICOLON       reduce using rule 76 (assign -> lhs ASSIGN expr .)
    PLUS            shift and go to state 137
    MULT            shift and go to state 140
    DIV             shift and go to state 138
    OR              shift and go to state 134
    AND             shift and go to state 128
    EQUALS          shift and go to state 133
    NOTEQUALS       shift and go to state 129
    LT              shift and go to state 136
    GT              shift and go to state 131
    LEQ             shift and go to state 135
    GEQ             shift and go to state 130

  ! PLUS            [ reduce using rule 76 (assign -> lhs ASSIGN expr .) ]
  ! MULT            [ reduce using rule 76 (assign -> lhs ASSIGN expr .) ]
  ! DIV             [ reduce using rule 76 (assign -> lhs ASSIGN expr .) ]
  ! OR              [ reduce using rule 76 (assign -> lhs ASSIGN expr .) ]
  ! AND             [ reduce using rule 76 (assign -> lhs ASSIGN expr .) ]
  ! EQUALS          [ reduce using rule 76 (assign -> lhs ASSIGN expr .) ]
  ! NOTEQUALS       [ reduce using rule 76 (assign -> lhs ASSIGN expr .) ]
  ! LT              [ reduce using rule 76 (assign -> lhs ASSIGN expr .) ]
  ! GT              [ reduce using rule 76 (assign -> lhs ASSIGN expr .) ]
  ! LEQ             [ reduce using rule 76 (assign -> lhs ASSIGN expr .) ]
  ! GEQ             [ reduce using rule 76 (assign -> lhs ASSIGN expr .) ]
  ! MINUS           [ shift and go to state 139 ]


state 171

    (41) stmt -> WHILE LPAREN expr RPAREN . stmt
    (39) stmt -> . IF LPAREN expr RPAREN stmt
    (40) stmt -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (41) stmt -> . WHILE LPAREN expr RPAREN stmt
    (42) stmt -> . FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt
    (43) stmt -> . FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt
    (44) stmt -> . FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt
    (45) stmt -> . FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt
    (46) stmt -> . FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (47) stmt -> . FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt
    (48) stmt -> . FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (49) stmt -> . FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt
    (50) stmt -> . RETURN SEMICOLON
    (51) stmt -> . RETURN expr SEMICOLON
    (52) stmt -> . stmt_expr SEMICOLON
    (53) stmt -> . BREAK SEMICOLON
    (54) stmt -> . CONTINUE SEMICOLON
    (55) stmt -> . block
    (56) stmt -> . var_decl
    (57) stmt -> . SEMICOLON
    (86) stmt_expr -> . empty
    (35) block -> . LCURLY stmthelper RCURLY
    (36) block -> . LCURLY RCURLY
    (15) var_decl -> . type variables SEMICOLON
    (108) empty -> .
    (16) type -> . INT
    (17) type -> . FLOAT
    (18) type -> . BOOLEAN
    (19) type -> . IDENTIFIER

  ! shift/reduce conflict for SEMICOLON resolved as shift
    IF              shift and go to state 70
    WHILE           shift and go to state 62
    FOR             shift and go to state 68
    RETURN          shift and go to state 61
    BREAK           shift and go to state 73
    CONTINUE        shift and go to state 74
    SEMICOLON       shift and go to state 63
    LCURLY          shift and go to state 49
    INT             shift and go to state 17
    FLOAT           shift and go to state 19
    BOOLEAN         shift and go to state 21
    IDENTIFIER      shift and go to state 38

  ! SEMICOLON       [ reduce using rule 108 (empty -> .) ]

    var_decl                       shift and go to state 72
    stmt                           shift and go to state 185
    stmt_expr                      shift and go to state 65
    block                          shift and go to state 75
    type                           shift and go to state 66
    empty                          shift and go to state 67

state 172

    (42) stmt -> FOR LPAREN SEMICOLON SEMICOLON . RPAREN stmt
    (49) stmt -> FOR LPAREN SEMICOLON SEMICOLON . stmt_expr RPAREN stmt
    (86) stmt_expr -> . empty
    (108) empty -> .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 186

  ! RPAREN          [ reduce using rule 108 (empty -> .) ]

    stmt_expr                      shift and go to state 187
    empty                          shift and go to state 67

state 173

    (47) stmt -> FOR LPAREN SEMICOLON expr . SEMICOLON RPAREN stmt
    (48) stmt -> FOR LPAREN SEMICOLON expr . SEMICOLON stmt_expr RPAREN stmt
    (61) expr -> expr . PLUS expr
    (62) expr -> expr . MINUS expr
    (63) expr -> expr . MULT expr
    (64) expr -> expr . DIV expr
    (65) expr -> expr . OR expr
    (66) expr -> expr . AND expr
    (67) expr -> expr . EQUALS expr
    (68) expr -> expr . NOTEQUALS expr
    (69) expr -> expr . LT expr
    (70) expr -> expr . GT expr
    (71) expr -> expr . LEQ expr
    (72) expr -> expr . GEQ expr

    SEMICOLON       shift and go to state 188
    PLUS            shift and go to state 137
    MINUS           shift and go to state 139
    MULT            shift and go to state 140
    DIV             shift and go to state 138
    OR              shift and go to state 134
    AND             shift and go to state 128
    EQUALS          shift and go to state 133
    NOTEQUALS       shift and go to state 129
    LT              shift and go to state 136
    GT              shift and go to state 131
    LEQ             shift and go to state 135
    GEQ             shift and go to state 130


state 174

    (43) stmt -> FOR LPAREN stmt_expr SEMICOLON . SEMICOLON RPAREN stmt
    (44) stmt -> FOR LPAREN stmt_expr SEMICOLON . expr SEMICOLON RPAREN stmt
    (45) stmt -> FOR LPAREN stmt_expr SEMICOLON . SEMICOLON stmt_expr RPAREN stmt
    (46) stmt -> FOR LPAREN stmt_expr SEMICOLON . expr SEMICOLON stmt_expr RPAREN stmt
    (58) expr -> . primary
    (59) expr -> . assign
    (60) expr -> . new_array
    (61) expr -> . expr PLUS expr
    (62) expr -> . expr MINUS expr
    (63) expr -> . expr MULT expr
    (64) expr -> . expr DIV expr
    (65) expr -> . expr OR expr
    (66) expr -> . expr AND expr
    (67) expr -> . expr EQUALS expr
    (68) expr -> . expr NOTEQUALS expr
    (69) expr -> . expr LT expr
    (70) expr -> . expr GT expr
    (71) expr -> . expr LEQ expr
    (72) expr -> . expr GEQ expr
    (73) expr -> . PLUS expr
    (74) expr -> . MINUS expr
    (75) expr -> . NOT expr
    (92) primary -> . literal
    (93) primary -> . THIS
    (94) primary -> . SUPER
    (95) primary -> . LPAREN expr RPAREN
    (96) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (97) primary -> . lhs
    (98) primary -> . method_invocation
    (76) assign -> . lhs ASSIGN expr
    (77) assign -> . lhs PLUSPLUS
    (78) assign -> . PLUSPLUS lhs
    (79) assign -> . lhs MINUSMINUS
    (80) assign -> . MINUSMINUS lhs
    (81) new_array -> . NEW type expr_array_helper1 expr_array_helper2
    (87) literal -> . INTEGERCONSTANT
    (88) literal -> . FLOATCONSTANT
    (89) literal -> . NULL
    (90) literal -> . TRUE
    (91) literal -> . FALSE
    (101) lhs -> . field_access
    (102) lhs -> . array_access
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN expr RPAREN
    (105) field_access -> . primary DOT IDENTIFIER
    (106) field_access -> . IDENTIFIER
    (107) array_access -> . primary LPAREN expr RPAREN

    SEMICOLON       shift and go to state 189
    PLUS            shift and go to state 92
    MINUS           shift and go to state 88
    NOT             shift and go to state 104
    THIS            shift and go to state 101
    SUPER           shift and go to state 105
    LPAREN          shift and go to state 97
    NEW             shift and go to state 85
    PLUSPLUS        shift and go to state 96
    MINUSMINUS      shift and go to state 98
    INTEGERCONSTANT shift and go to state 84
    FLOATCONSTANT   shift and go to state 99
    NULL            shift and go to state 86
    TRUE            shift and go to state 87
    FALSE           shift and go to state 100
    IDENTIFIER      shift and go to state 94

    new_array                      shift and go to state 82
    field_access                   shift and go to state 95
    expr                           shift and go to state 190
    primary                        shift and go to state 83
    literal                        shift and go to state 91
    array_access                   shift and go to state 90
    lhs                            shift and go to state 103
    method_invocation              shift and go to state 93
    assign                         shift and go to state 106

state 175

    (39) stmt -> IF LPAREN expr RPAREN . stmt
    (40) stmt -> IF LPAREN expr RPAREN . stmt ELSE stmt
    (39) stmt -> . IF LPAREN expr RPAREN stmt
    (40) stmt -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (41) stmt -> . WHILE LPAREN expr RPAREN stmt
    (42) stmt -> . FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt
    (43) stmt -> . FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt
    (44) stmt -> . FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt
    (45) stmt -> . FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt
    (46) stmt -> . FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (47) stmt -> . FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt
    (48) stmt -> . FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (49) stmt -> . FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt
    (50) stmt -> . RETURN SEMICOLON
    (51) stmt -> . RETURN expr SEMICOLON
    (52) stmt -> . stmt_expr SEMICOLON
    (53) stmt -> . BREAK SEMICOLON
    (54) stmt -> . CONTINUE SEMICOLON
    (55) stmt -> . block
    (56) stmt -> . var_decl
    (57) stmt -> . SEMICOLON
    (86) stmt_expr -> . empty
    (35) block -> . LCURLY stmthelper RCURLY
    (36) block -> . LCURLY RCURLY
    (15) var_decl -> . type variables SEMICOLON
    (108) empty -> .
    (16) type -> . INT
    (17) type -> . FLOAT
    (18) type -> . BOOLEAN
    (19) type -> . IDENTIFIER

  ! shift/reduce conflict for SEMICOLON resolved as shift
    IF              shift and go to state 70
    WHILE           shift and go to state 62
    FOR             shift and go to state 68
    RETURN          shift and go to state 61
    BREAK           shift and go to state 73
    CONTINUE        shift and go to state 74
    SEMICOLON       shift and go to state 63
    LCURLY          shift and go to state 49
    INT             shift and go to state 17
    FLOAT           shift and go to state 19
    BOOLEAN         shift and go to state 21
    IDENTIFIER      shift and go to state 38

  ! SEMICOLON       [ reduce using rule 108 (empty -> .) ]

    var_decl                       shift and go to state 72
    stmt                           shift and go to state 191
    stmt_expr                      shift and go to state 65
    block                          shift and go to state 75
    type                           shift and go to state 66
    empty                          shift and go to state 67

state 176

    (107) array_access -> primary LPAREN expr RPAREN .

    ASSIGN          reduce using rule 107 (array_access -> primary LPAREN expr RPAREN .)
    PLUSPLUS        reduce using rule 107 (array_access -> primary LPAREN expr RPAREN .)
    MINUSMINUS      reduce using rule 107 (array_access -> primary LPAREN expr RPAREN .)
    DOT             reduce using rule 107 (array_access -> primary LPAREN expr RPAREN .)
    LPAREN          reduce using rule 107 (array_access -> primary LPAREN expr RPAREN .)
    PLUS            reduce using rule 107 (array_access -> primary LPAREN expr RPAREN .)
    MINUS           reduce using rule 107 (array_access -> primary LPAREN expr RPAREN .)
    MULT            reduce using rule 107 (array_access -> primary LPAREN expr RPAREN .)
    DIV             reduce using rule 107 (array_access -> primary LPAREN expr RPAREN .)
    OR              reduce using rule 107 (array_access -> primary LPAREN expr RPAREN .)
    AND             reduce using rule 107 (array_access -> primary LPAREN expr RPAREN .)
    EQUALS          reduce using rule 107 (array_access -> primary LPAREN expr RPAREN .)
    NOTEQUALS       reduce using rule 107 (array_access -> primary LPAREN expr RPAREN .)
    LT              reduce using rule 107 (array_access -> primary LPAREN expr RPAREN .)
    GT              reduce using rule 107 (array_access -> primary LPAREN expr RPAREN .)
    LEQ             reduce using rule 107 (array_access -> primary LPAREN expr RPAREN .)
    GEQ             reduce using rule 107 (array_access -> primary LPAREN expr RPAREN .)
    SEMICOLON       reduce using rule 107 (array_access -> primary LPAREN expr RPAREN .)
    RPAREN          reduce using rule 107 (array_access -> primary LPAREN expr RPAREN .)
    RSQUARE         reduce using rule 107 (array_access -> primary LPAREN expr RPAREN .)


state 177

    (96) primary -> NEW IDENTIFIER LPAREN arguments . RPAREN

    RPAREN          shift and go to state 192


state 178

    (100) arguments -> COMMA . arguments
    (99) arguments -> . expr
    (100) arguments -> . COMMA arguments
    (58) expr -> . primary
    (59) expr -> . assign
    (60) expr -> . new_array
    (61) expr -> . expr PLUS expr
    (62) expr -> . expr MINUS expr
    (63) expr -> . expr MULT expr
    (64) expr -> . expr DIV expr
    (65) expr -> . expr OR expr
    (66) expr -> . expr AND expr
    (67) expr -> . expr EQUALS expr
    (68) expr -> . expr NOTEQUALS expr
    (69) expr -> . expr LT expr
    (70) expr -> . expr GT expr
    (71) expr -> . expr LEQ expr
    (72) expr -> . expr GEQ expr
    (73) expr -> . PLUS expr
    (74) expr -> . MINUS expr
    (75) expr -> . NOT expr
    (92) primary -> . literal
    (93) primary -> . THIS
    (94) primary -> . SUPER
    (95) primary -> . LPAREN expr RPAREN
    (96) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (97) primary -> . lhs
    (98) primary -> . method_invocation
    (76) assign -> . lhs ASSIGN expr
    (77) assign -> . lhs PLUSPLUS
    (78) assign -> . PLUSPLUS lhs
    (79) assign -> . lhs MINUSMINUS
    (80) assign -> . MINUSMINUS lhs
    (81) new_array -> . NEW type expr_array_helper1 expr_array_helper2
    (87) literal -> . INTEGERCONSTANT
    (88) literal -> . FLOATCONSTANT
    (89) literal -> . NULL
    (90) literal -> . TRUE
    (91) literal -> . FALSE
    (101) lhs -> . field_access
    (102) lhs -> . array_access
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN expr RPAREN
    (105) field_access -> . primary DOT IDENTIFIER
    (106) field_access -> . IDENTIFIER
    (107) array_access -> . primary LPAREN expr RPAREN

    COMMA           shift and go to state 178
    PLUS            shift and go to state 92
    MINUS           shift and go to state 88
    NOT             shift and go to state 104
    THIS            shift and go to state 101
    SUPER           shift and go to state 105
    LPAREN          shift and go to state 97
    NEW             shift and go to state 85
    PLUSPLUS        shift and go to state 96
    MINUSMINUS      shift and go to state 98
    INTEGERCONSTANT shift and go to state 84
    FLOATCONSTANT   shift and go to state 99
    NULL            shift and go to state 86
    TRUE            shift and go to state 87
    FALSE           shift and go to state 100
    IDENTIFIER      shift and go to state 94

    new_array                      shift and go to state 82
    field_access                   shift and go to state 95
    expr                           shift and go to state 179
    primary                        shift and go to state 83
    array_access                   shift and go to state 90
    literal                        shift and go to state 91
    lhs                            shift and go to state 103
    arguments                      shift and go to state 193
    method_invocation              shift and go to state 93
    assign                         shift and go to state 106

state 179

    (99) arguments -> expr .
    (61) expr -> expr . PLUS expr
    (62) expr -> expr . MINUS expr
    (63) expr -> expr . MULT expr
    (64) expr -> expr . DIV expr
    (65) expr -> expr . OR expr
    (66) expr -> expr . AND expr
    (67) expr -> expr . EQUALS expr
    (68) expr -> expr . NOTEQUALS expr
    (69) expr -> expr . LT expr
    (70) expr -> expr . GT expr
    (71) expr -> expr . LEQ expr
    (72) expr -> expr . GEQ expr

    RPAREN          reduce using rule 99 (arguments -> expr .)
    PLUS            shift and go to state 137
    MINUS           shift and go to state 139
    MULT            shift and go to state 140
    DIV             shift and go to state 138
    OR              shift and go to state 134
    AND             shift and go to state 128
    EQUALS          shift and go to state 133
    NOTEQUALS       shift and go to state 129
    LT              shift and go to state 136
    GT              shift and go to state 131
    LEQ             shift and go to state 135
    GEQ             shift and go to state 130


state 180

    (82) expr_array_helper1 -> LSQUARE expr . RSQUARE
    (83) expr_array_helper1 -> LSQUARE expr . RSQUARE expr_array_helper1
    (61) expr -> expr . PLUS expr
    (62) expr -> expr . MINUS expr
    (63) expr -> expr . MULT expr
    (64) expr -> expr . DIV expr
    (65) expr -> expr . OR expr
    (66) expr -> expr . AND expr
    (67) expr -> expr . EQUALS expr
    (68) expr -> expr . NOTEQUALS expr
    (69) expr -> expr . LT expr
    (70) expr -> expr . GT expr
    (71) expr -> expr . LEQ expr
    (72) expr -> expr . GEQ expr

    RSQUARE         shift and go to state 194
    PLUS            shift and go to state 137
    MINUS           shift and go to state 139
    MULT            shift and go to state 140
    DIV             shift and go to state 138
    OR              shift and go to state 134
    AND             shift and go to state 128
    EQUALS          shift and go to state 133
    NOTEQUALS       shift and go to state 129
    LT              shift and go to state 136
    GT              shift and go to state 131
    LEQ             shift and go to state 135
    GEQ             shift and go to state 130


state 181

    (85) expr_array_helper2 -> LSQUARE . RSQUARE expr_array_helper2

    RSQUARE         shift and go to state 195


state 182

    (81) new_array -> NEW type expr_array_helper1 expr_array_helper2 .

    PLUS            reduce using rule 81 (new_array -> NEW type expr_array_helper1 expr_array_helper2 .)
    MINUS           reduce using rule 81 (new_array -> NEW type expr_array_helper1 expr_array_helper2 .)
    MULT            reduce using rule 81 (new_array -> NEW type expr_array_helper1 expr_array_helper2 .)
    DIV             reduce using rule 81 (new_array -> NEW type expr_array_helper1 expr_array_helper2 .)
    OR              reduce using rule 81 (new_array -> NEW type expr_array_helper1 expr_array_helper2 .)
    AND             reduce using rule 81 (new_array -> NEW type expr_array_helper1 expr_array_helper2 .)
    EQUALS          reduce using rule 81 (new_array -> NEW type expr_array_helper1 expr_array_helper2 .)
    NOTEQUALS       reduce using rule 81 (new_array -> NEW type expr_array_helper1 expr_array_helper2 .)
    LT              reduce using rule 81 (new_array -> NEW type expr_array_helper1 expr_array_helper2 .)
    GT              reduce using rule 81 (new_array -> NEW type expr_array_helper1 expr_array_helper2 .)
    LEQ             reduce using rule 81 (new_array -> NEW type expr_array_helper1 expr_array_helper2 .)
    GEQ             reduce using rule 81 (new_array -> NEW type expr_array_helper1 expr_array_helper2 .)
    SEMICOLON       reduce using rule 81 (new_array -> NEW type expr_array_helper1 expr_array_helper2 .)
    RPAREN          reduce using rule 81 (new_array -> NEW type expr_array_helper1 expr_array_helper2 .)
    RSQUARE         reduce using rule 81 (new_array -> NEW type expr_array_helper1 expr_array_helper2 .)


state 183

    (84) expr_array_helper2 -> empty .

    SEMICOLON       reduce using rule 84 (expr_array_helper2 -> empty .)
    PLUS            reduce using rule 84 (expr_array_helper2 -> empty .)
    MINUS           reduce using rule 84 (expr_array_helper2 -> empty .)
    MULT            reduce using rule 84 (expr_array_helper2 -> empty .)
    DIV             reduce using rule 84 (expr_array_helper2 -> empty .)
    OR              reduce using rule 84 (expr_array_helper2 -> empty .)
    AND             reduce using rule 84 (expr_array_helper2 -> empty .)
    EQUALS          reduce using rule 84 (expr_array_helper2 -> empty .)
    NOTEQUALS       reduce using rule 84 (expr_array_helper2 -> empty .)
    LT              reduce using rule 84 (expr_array_helper2 -> empty .)
    GT              reduce using rule 84 (expr_array_helper2 -> empty .)
    LEQ             reduce using rule 84 (expr_array_helper2 -> empty .)
    GEQ             reduce using rule 84 (expr_array_helper2 -> empty .)
    RPAREN          reduce using rule 84 (expr_array_helper2 -> empty .)
    RSQUARE         reduce using rule 84 (expr_array_helper2 -> empty .)


state 184

    (104) method_invocation -> field_access LPAREN expr RPAREN .

    DOT             reduce using rule 104 (method_invocation -> field_access LPAREN expr RPAREN .)
    LPAREN          reduce using rule 104 (method_invocation -> field_access LPAREN expr RPAREN .)
    PLUS            reduce using rule 104 (method_invocation -> field_access LPAREN expr RPAREN .)
    MINUS           reduce using rule 104 (method_invocation -> field_access LPAREN expr RPAREN .)
    MULT            reduce using rule 104 (method_invocation -> field_access LPAREN expr RPAREN .)
    DIV             reduce using rule 104 (method_invocation -> field_access LPAREN expr RPAREN .)
    OR              reduce using rule 104 (method_invocation -> field_access LPAREN expr RPAREN .)
    AND             reduce using rule 104 (method_invocation -> field_access LPAREN expr RPAREN .)
    EQUALS          reduce using rule 104 (method_invocation -> field_access LPAREN expr RPAREN .)
    NOTEQUALS       reduce using rule 104 (method_invocation -> field_access LPAREN expr RPAREN .)
    LT              reduce using rule 104 (method_invocation -> field_access LPAREN expr RPAREN .)
    GT              reduce using rule 104 (method_invocation -> field_access LPAREN expr RPAREN .)
    LEQ             reduce using rule 104 (method_invocation -> field_access LPAREN expr RPAREN .)
    GEQ             reduce using rule 104 (method_invocation -> field_access LPAREN expr RPAREN .)
    SEMICOLON       reduce using rule 104 (method_invocation -> field_access LPAREN expr RPAREN .)
    RPAREN          reduce using rule 104 (method_invocation -> field_access LPAREN expr RPAREN .)
    RSQUARE         reduce using rule 104 (method_invocation -> field_access LPAREN expr RPAREN .)


state 185

    (41) stmt -> WHILE LPAREN expr RPAREN stmt .

    IF              reduce using rule 41 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    WHILE           reduce using rule 41 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    FOR             reduce using rule 41 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    RETURN          reduce using rule 41 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    BREAK           reduce using rule 41 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    CONTINUE        reduce using rule 41 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    SEMICOLON       reduce using rule 41 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    LCURLY          reduce using rule 41 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    INT             reduce using rule 41 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    FLOAT           reduce using rule 41 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    BOOLEAN         reduce using rule 41 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    IDENTIFIER      reduce using rule 41 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    RCURLY          reduce using rule 41 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    ELSE            reduce using rule 41 (stmt -> WHILE LPAREN expr RPAREN stmt .)


state 186

    (42) stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN . stmt
    (39) stmt -> . IF LPAREN expr RPAREN stmt
    (40) stmt -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (41) stmt -> . WHILE LPAREN expr RPAREN stmt
    (42) stmt -> . FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt
    (43) stmt -> . FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt
    (44) stmt -> . FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt
    (45) stmt -> . FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt
    (46) stmt -> . FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (47) stmt -> . FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt
    (48) stmt -> . FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (49) stmt -> . FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt
    (50) stmt -> . RETURN SEMICOLON
    (51) stmt -> . RETURN expr SEMICOLON
    (52) stmt -> . stmt_expr SEMICOLON
    (53) stmt -> . BREAK SEMICOLON
    (54) stmt -> . CONTINUE SEMICOLON
    (55) stmt -> . block
    (56) stmt -> . var_decl
    (57) stmt -> . SEMICOLON
    (86) stmt_expr -> . empty
    (35) block -> . LCURLY stmthelper RCURLY
    (36) block -> . LCURLY RCURLY
    (15) var_decl -> . type variables SEMICOLON
    (108) empty -> .
    (16) type -> . INT
    (17) type -> . FLOAT
    (18) type -> . BOOLEAN
    (19) type -> . IDENTIFIER

  ! shift/reduce conflict for SEMICOLON resolved as shift
    IF              shift and go to state 70
    WHILE           shift and go to state 62
    FOR             shift and go to state 68
    RETURN          shift and go to state 61
    BREAK           shift and go to state 73
    CONTINUE        shift and go to state 74
    SEMICOLON       shift and go to state 63
    LCURLY          shift and go to state 49
    INT             shift and go to state 17
    FLOAT           shift and go to state 19
    BOOLEAN         shift and go to state 21
    IDENTIFIER      shift and go to state 38

  ! SEMICOLON       [ reduce using rule 108 (empty -> .) ]

    var_decl                       shift and go to state 72
    stmt                           shift and go to state 196
    stmt_expr                      shift and go to state 65
    block                          shift and go to state 75
    type                           shift and go to state 66
    empty                          shift and go to state 67

state 187

    (49) stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expr . RPAREN stmt

    RPAREN          shift and go to state 197


state 188

    (47) stmt -> FOR LPAREN SEMICOLON expr SEMICOLON . RPAREN stmt
    (48) stmt -> FOR LPAREN SEMICOLON expr SEMICOLON . stmt_expr RPAREN stmt
    (86) stmt_expr -> . empty
    (108) empty -> .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 198

  ! RPAREN          [ reduce using rule 108 (empty -> .) ]

    empty                          shift and go to state 67
    stmt_expr                      shift and go to state 199

state 189

    (43) stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON . RPAREN stmt
    (45) stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON . stmt_expr RPAREN stmt
    (86) stmt_expr -> . empty
    (108) empty -> .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 200

  ! RPAREN          [ reduce using rule 108 (empty -> .) ]

    stmt_expr                      shift and go to state 201
    empty                          shift and go to state 67

state 190

    (44) stmt -> FOR LPAREN stmt_expr SEMICOLON expr . SEMICOLON RPAREN stmt
    (46) stmt -> FOR LPAREN stmt_expr SEMICOLON expr . SEMICOLON stmt_expr RPAREN stmt
    (61) expr -> expr . PLUS expr
    (62) expr -> expr . MINUS expr
    (63) expr -> expr . MULT expr
    (64) expr -> expr . DIV expr
    (65) expr -> expr . OR expr
    (66) expr -> expr . AND expr
    (67) expr -> expr . EQUALS expr
    (68) expr -> expr . NOTEQUALS expr
    (69) expr -> expr . LT expr
    (70) expr -> expr . GT expr
    (71) expr -> expr . LEQ expr
    (72) expr -> expr . GEQ expr

    SEMICOLON       shift and go to state 202
    PLUS            shift and go to state 137
    MINUS           shift and go to state 139
    MULT            shift and go to state 140
    DIV             shift and go to state 138
    OR              shift and go to state 134
    AND             shift and go to state 128
    EQUALS          shift and go to state 133
    NOTEQUALS       shift and go to state 129
    LT              shift and go to state 136
    GT              shift and go to state 131
    LEQ             shift and go to state 135
    GEQ             shift and go to state 130


state 191

    (39) stmt -> IF LPAREN expr RPAREN stmt .
    (40) stmt -> IF LPAREN expr RPAREN stmt . ELSE stmt

  ! shift/reduce conflict for ELSE resolved as shift
    IF              reduce using rule 39 (stmt -> IF LPAREN expr RPAREN stmt .)
    WHILE           reduce using rule 39 (stmt -> IF LPAREN expr RPAREN stmt .)
    FOR             reduce using rule 39 (stmt -> IF LPAREN expr RPAREN stmt .)
    RETURN          reduce using rule 39 (stmt -> IF LPAREN expr RPAREN stmt .)
    BREAK           reduce using rule 39 (stmt -> IF LPAREN expr RPAREN stmt .)
    CONTINUE        reduce using rule 39 (stmt -> IF LPAREN expr RPAREN stmt .)
    SEMICOLON       reduce using rule 39 (stmt -> IF LPAREN expr RPAREN stmt .)
    LCURLY          reduce using rule 39 (stmt -> IF LPAREN expr RPAREN stmt .)
    INT             reduce using rule 39 (stmt -> IF LPAREN expr RPAREN stmt .)
    FLOAT           reduce using rule 39 (stmt -> IF LPAREN expr RPAREN stmt .)
    BOOLEAN         reduce using rule 39 (stmt -> IF LPAREN expr RPAREN stmt .)
    IDENTIFIER      reduce using rule 39 (stmt -> IF LPAREN expr RPAREN stmt .)
    RCURLY          reduce using rule 39 (stmt -> IF LPAREN expr RPAREN stmt .)
    ELSE            shift and go to state 203

  ! ELSE            [ reduce using rule 39 (stmt -> IF LPAREN expr RPAREN stmt .) ]


state 192

    (96) primary -> NEW IDENTIFIER LPAREN arguments RPAREN .

    DOT             reduce using rule 96 (primary -> NEW IDENTIFIER LPAREN arguments RPAREN .)
    LPAREN          reduce using rule 96 (primary -> NEW IDENTIFIER LPAREN arguments RPAREN .)
    RPAREN          reduce using rule 96 (primary -> NEW IDENTIFIER LPAREN arguments RPAREN .)
    PLUS            reduce using rule 96 (primary -> NEW IDENTIFIER LPAREN arguments RPAREN .)
    MINUS           reduce using rule 96 (primary -> NEW IDENTIFIER LPAREN arguments RPAREN .)
    MULT            reduce using rule 96 (primary -> NEW IDENTIFIER LPAREN arguments RPAREN .)
    DIV             reduce using rule 96 (primary -> NEW IDENTIFIER LPAREN arguments RPAREN .)
    OR              reduce using rule 96 (primary -> NEW IDENTIFIER LPAREN arguments RPAREN .)
    AND             reduce using rule 96 (primary -> NEW IDENTIFIER LPAREN arguments RPAREN .)
    EQUALS          reduce using rule 96 (primary -> NEW IDENTIFIER LPAREN arguments RPAREN .)
    NOTEQUALS       reduce using rule 96 (primary -> NEW IDENTIFIER LPAREN arguments RPAREN .)
    LT              reduce using rule 96 (primary -> NEW IDENTIFIER LPAREN arguments RPAREN .)
    GT              reduce using rule 96 (primary -> NEW IDENTIFIER LPAREN arguments RPAREN .)
    LEQ             reduce using rule 96 (primary -> NEW IDENTIFIER LPAREN arguments RPAREN .)
    GEQ             reduce using rule 96 (primary -> NEW IDENTIFIER LPAREN arguments RPAREN .)
    SEMICOLON       reduce using rule 96 (primary -> NEW IDENTIFIER LPAREN arguments RPAREN .)
    RSQUARE         reduce using rule 96 (primary -> NEW IDENTIFIER LPAREN arguments RPAREN .)


state 193

    (100) arguments -> COMMA arguments .

    RPAREN          reduce using rule 100 (arguments -> COMMA arguments .)


state 194

    (82) expr_array_helper1 -> LSQUARE expr RSQUARE .
    (83) expr_array_helper1 -> LSQUARE expr RSQUARE . expr_array_helper1
    (82) expr_array_helper1 -> . LSQUARE expr RSQUARE
    (83) expr_array_helper1 -> . LSQUARE expr RSQUARE expr_array_helper1

  ! shift/reduce conflict for LSQUARE resolved as shift
    SEMICOLON       reduce using rule 82 (expr_array_helper1 -> LSQUARE expr RSQUARE .)
    PLUS            reduce using rule 82 (expr_array_helper1 -> LSQUARE expr RSQUARE .)
    MINUS           reduce using rule 82 (expr_array_helper1 -> LSQUARE expr RSQUARE .)
    MULT            reduce using rule 82 (expr_array_helper1 -> LSQUARE expr RSQUARE .)
    DIV             reduce using rule 82 (expr_array_helper1 -> LSQUARE expr RSQUARE .)
    OR              reduce using rule 82 (expr_array_helper1 -> LSQUARE expr RSQUARE .)
    AND             reduce using rule 82 (expr_array_helper1 -> LSQUARE expr RSQUARE .)
    EQUALS          reduce using rule 82 (expr_array_helper1 -> LSQUARE expr RSQUARE .)
    NOTEQUALS       reduce using rule 82 (expr_array_helper1 -> LSQUARE expr RSQUARE .)
    LT              reduce using rule 82 (expr_array_helper1 -> LSQUARE expr RSQUARE .)
    GT              reduce using rule 82 (expr_array_helper1 -> LSQUARE expr RSQUARE .)
    LEQ             reduce using rule 82 (expr_array_helper1 -> LSQUARE expr RSQUARE .)
    GEQ             reduce using rule 82 (expr_array_helper1 -> LSQUARE expr RSQUARE .)
    RPAREN          reduce using rule 82 (expr_array_helper1 -> LSQUARE expr RSQUARE .)
    RSQUARE         reduce using rule 82 (expr_array_helper1 -> LSQUARE expr RSQUARE .)
    LSQUARE         shift and go to state 152

  ! LSQUARE         [ reduce using rule 82 (expr_array_helper1 -> LSQUARE expr RSQUARE .) ]

    expr_array_helper1             shift and go to state 204

state 195

    (85) expr_array_helper2 -> LSQUARE RSQUARE . expr_array_helper2
    (84) expr_array_helper2 -> . empty
    (85) expr_array_helper2 -> . LSQUARE RSQUARE expr_array_helper2
    (108) empty -> .

    LSQUARE         shift and go to state 181
    SEMICOLON       reduce using rule 108 (empty -> .)
    PLUS            reduce using rule 108 (empty -> .)
    MINUS           reduce using rule 108 (empty -> .)
    MULT            reduce using rule 108 (empty -> .)
    DIV             reduce using rule 108 (empty -> .)
    OR              reduce using rule 108 (empty -> .)
    AND             reduce using rule 108 (empty -> .)
    EQUALS          reduce using rule 108 (empty -> .)
    NOTEQUALS       reduce using rule 108 (empty -> .)
    LT              reduce using rule 108 (empty -> .)
    GT              reduce using rule 108 (empty -> .)
    LEQ             reduce using rule 108 (empty -> .)
    GEQ             reduce using rule 108 (empty -> .)
    RPAREN          reduce using rule 108 (empty -> .)
    RSQUARE         reduce using rule 108 (empty -> .)

    expr_array_helper2             shift and go to state 205
    empty                          shift and go to state 183

state 196

    (42) stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .

    IF              reduce using rule 42 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    WHILE           reduce using rule 42 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    FOR             reduce using rule 42 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    RETURN          reduce using rule 42 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    BREAK           reduce using rule 42 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    CONTINUE        reduce using rule 42 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    SEMICOLON       reduce using rule 42 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    LCURLY          reduce using rule 42 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    INT             reduce using rule 42 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    FLOAT           reduce using rule 42 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    BOOLEAN         reduce using rule 42 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    IDENTIFIER      reduce using rule 42 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    RCURLY          reduce using rule 42 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    ELSE            reduce using rule 42 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)


state 197

    (49) stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN . stmt
    (39) stmt -> . IF LPAREN expr RPAREN stmt
    (40) stmt -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (41) stmt -> . WHILE LPAREN expr RPAREN stmt
    (42) stmt -> . FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt
    (43) stmt -> . FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt
    (44) stmt -> . FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt
    (45) stmt -> . FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt
    (46) stmt -> . FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (47) stmt -> . FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt
    (48) stmt -> . FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (49) stmt -> . FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt
    (50) stmt -> . RETURN SEMICOLON
    (51) stmt -> . RETURN expr SEMICOLON
    (52) stmt -> . stmt_expr SEMICOLON
    (53) stmt -> . BREAK SEMICOLON
    (54) stmt -> . CONTINUE SEMICOLON
    (55) stmt -> . block
    (56) stmt -> . var_decl
    (57) stmt -> . SEMICOLON
    (86) stmt_expr -> . empty
    (35) block -> . LCURLY stmthelper RCURLY
    (36) block -> . LCURLY RCURLY
    (15) var_decl -> . type variables SEMICOLON
    (108) empty -> .
    (16) type -> . INT
    (17) type -> . FLOAT
    (18) type -> . BOOLEAN
    (19) type -> . IDENTIFIER

  ! shift/reduce conflict for SEMICOLON resolved as shift
    IF              shift and go to state 70
    WHILE           shift and go to state 62
    FOR             shift and go to state 68
    RETURN          shift and go to state 61
    BREAK           shift and go to state 73
    CONTINUE        shift and go to state 74
    SEMICOLON       shift and go to state 63
    LCURLY          shift and go to state 49
    INT             shift and go to state 17
    FLOAT           shift and go to state 19
    BOOLEAN         shift and go to state 21
    IDENTIFIER      shift and go to state 38

  ! SEMICOLON       [ reduce using rule 108 (empty -> .) ]

    var_decl                       shift and go to state 72
    stmt                           shift and go to state 206
    stmt_expr                      shift and go to state 65
    block                          shift and go to state 75
    type                           shift and go to state 66
    empty                          shift and go to state 67

state 198

    (47) stmt -> FOR LPAREN SEMICOLON expr SEMICOLON RPAREN . stmt
    (39) stmt -> . IF LPAREN expr RPAREN stmt
    (40) stmt -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (41) stmt -> . WHILE LPAREN expr RPAREN stmt
    (42) stmt -> . FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt
    (43) stmt -> . FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt
    (44) stmt -> . FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt
    (45) stmt -> . FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt
    (46) stmt -> . FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (47) stmt -> . FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt
    (48) stmt -> . FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (49) stmt -> . FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt
    (50) stmt -> . RETURN SEMICOLON
    (51) stmt -> . RETURN expr SEMICOLON
    (52) stmt -> . stmt_expr SEMICOLON
    (53) stmt -> . BREAK SEMICOLON
    (54) stmt -> . CONTINUE SEMICOLON
    (55) stmt -> . block
    (56) stmt -> . var_decl
    (57) stmt -> . SEMICOLON
    (86) stmt_expr -> . empty
    (35) block -> . LCURLY stmthelper RCURLY
    (36) block -> . LCURLY RCURLY
    (15) var_decl -> . type variables SEMICOLON
    (108) empty -> .
    (16) type -> . INT
    (17) type -> . FLOAT
    (18) type -> . BOOLEAN
    (19) type -> . IDENTIFIER

  ! shift/reduce conflict for SEMICOLON resolved as shift
    IF              shift and go to state 70
    WHILE           shift and go to state 62
    FOR             shift and go to state 68
    RETURN          shift and go to state 61
    BREAK           shift and go to state 73
    CONTINUE        shift and go to state 74
    SEMICOLON       shift and go to state 63
    LCURLY          shift and go to state 49
    INT             shift and go to state 17
    FLOAT           shift and go to state 19
    BOOLEAN         shift and go to state 21
    IDENTIFIER      shift and go to state 38

  ! SEMICOLON       [ reduce using rule 108 (empty -> .) ]

    var_decl                       shift and go to state 72
    stmt                           shift and go to state 207
    stmt_expr                      shift and go to state 65
    block                          shift and go to state 75
    type                           shift and go to state 66
    empty                          shift and go to state 67

state 199

    (48) stmt -> FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr . RPAREN stmt

    RPAREN          shift and go to state 208


state 200

    (43) stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN . stmt
    (39) stmt -> . IF LPAREN expr RPAREN stmt
    (40) stmt -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (41) stmt -> . WHILE LPAREN expr RPAREN stmt
    (42) stmt -> . FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt
    (43) stmt -> . FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt
    (44) stmt -> . FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt
    (45) stmt -> . FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt
    (46) stmt -> . FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (47) stmt -> . FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt
    (48) stmt -> . FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (49) stmt -> . FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt
    (50) stmt -> . RETURN SEMICOLON
    (51) stmt -> . RETURN expr SEMICOLON
    (52) stmt -> . stmt_expr SEMICOLON
    (53) stmt -> . BREAK SEMICOLON
    (54) stmt -> . CONTINUE SEMICOLON
    (55) stmt -> . block
    (56) stmt -> . var_decl
    (57) stmt -> . SEMICOLON
    (86) stmt_expr -> . empty
    (35) block -> . LCURLY stmthelper RCURLY
    (36) block -> . LCURLY RCURLY
    (15) var_decl -> . type variables SEMICOLON
    (108) empty -> .
    (16) type -> . INT
    (17) type -> . FLOAT
    (18) type -> . BOOLEAN
    (19) type -> . IDENTIFIER

  ! shift/reduce conflict for SEMICOLON resolved as shift
    IF              shift and go to state 70
    WHILE           shift and go to state 62
    FOR             shift and go to state 68
    RETURN          shift and go to state 61
    BREAK           shift and go to state 73
    CONTINUE        shift and go to state 74
    SEMICOLON       shift and go to state 63
    LCURLY          shift and go to state 49
    INT             shift and go to state 17
    FLOAT           shift and go to state 19
    BOOLEAN         shift and go to state 21
    IDENTIFIER      shift and go to state 38

  ! SEMICOLON       [ reduce using rule 108 (empty -> .) ]

    var_decl                       shift and go to state 72
    stmt                           shift and go to state 209
    stmt_expr                      shift and go to state 65
    block                          shift and go to state 75
    type                           shift and go to state 66
    empty                          shift and go to state 67

state 201

    (45) stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr . RPAREN stmt

    RPAREN          shift and go to state 210


state 202

    (44) stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON . RPAREN stmt
    (46) stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON . stmt_expr RPAREN stmt
    (86) stmt_expr -> . empty
    (108) empty -> .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 211

  ! RPAREN          [ reduce using rule 108 (empty -> .) ]

    stmt_expr                      shift and go to state 212
    empty                          shift and go to state 67

state 203

    (40) stmt -> IF LPAREN expr RPAREN stmt ELSE . stmt
    (39) stmt -> . IF LPAREN expr RPAREN stmt
    (40) stmt -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (41) stmt -> . WHILE LPAREN expr RPAREN stmt
    (42) stmt -> . FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt
    (43) stmt -> . FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt
    (44) stmt -> . FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt
    (45) stmt -> . FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt
    (46) stmt -> . FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (47) stmt -> . FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt
    (48) stmt -> . FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (49) stmt -> . FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt
    (50) stmt -> . RETURN SEMICOLON
    (51) stmt -> . RETURN expr SEMICOLON
    (52) stmt -> . stmt_expr SEMICOLON
    (53) stmt -> . BREAK SEMICOLON
    (54) stmt -> . CONTINUE SEMICOLON
    (55) stmt -> . block
    (56) stmt -> . var_decl
    (57) stmt -> . SEMICOLON
    (86) stmt_expr -> . empty
    (35) block -> . LCURLY stmthelper RCURLY
    (36) block -> . LCURLY RCURLY
    (15) var_decl -> . type variables SEMICOLON
    (108) empty -> .
    (16) type -> . INT
    (17) type -> . FLOAT
    (18) type -> . BOOLEAN
    (19) type -> . IDENTIFIER

  ! shift/reduce conflict for SEMICOLON resolved as shift
    IF              shift and go to state 70
    WHILE           shift and go to state 62
    FOR             shift and go to state 68
    RETURN          shift and go to state 61
    BREAK           shift and go to state 73
    CONTINUE        shift and go to state 74
    SEMICOLON       shift and go to state 63
    LCURLY          shift and go to state 49
    INT             shift and go to state 17
    FLOAT           shift and go to state 19
    BOOLEAN         shift and go to state 21
    IDENTIFIER      shift and go to state 38

  ! SEMICOLON       [ reduce using rule 108 (empty -> .) ]

    var_decl                       shift and go to state 72
    stmt                           shift and go to state 213
    stmt_expr                      shift and go to state 65
    block                          shift and go to state 75
    type                           shift and go to state 66
    empty                          shift and go to state 67

state 204

    (83) expr_array_helper1 -> LSQUARE expr RSQUARE expr_array_helper1 .

    LSQUARE         reduce using rule 83 (expr_array_helper1 -> LSQUARE expr RSQUARE expr_array_helper1 .)
    SEMICOLON       reduce using rule 83 (expr_array_helper1 -> LSQUARE expr RSQUARE expr_array_helper1 .)
    PLUS            reduce using rule 83 (expr_array_helper1 -> LSQUARE expr RSQUARE expr_array_helper1 .)
    MINUS           reduce using rule 83 (expr_array_helper1 -> LSQUARE expr RSQUARE expr_array_helper1 .)
    MULT            reduce using rule 83 (expr_array_helper1 -> LSQUARE expr RSQUARE expr_array_helper1 .)
    DIV             reduce using rule 83 (expr_array_helper1 -> LSQUARE expr RSQUARE expr_array_helper1 .)
    OR              reduce using rule 83 (expr_array_helper1 -> LSQUARE expr RSQUARE expr_array_helper1 .)
    AND             reduce using rule 83 (expr_array_helper1 -> LSQUARE expr RSQUARE expr_array_helper1 .)
    EQUALS          reduce using rule 83 (expr_array_helper1 -> LSQUARE expr RSQUARE expr_array_helper1 .)
    NOTEQUALS       reduce using rule 83 (expr_array_helper1 -> LSQUARE expr RSQUARE expr_array_helper1 .)
    LT              reduce using rule 83 (expr_array_helper1 -> LSQUARE expr RSQUARE expr_array_helper1 .)
    GT              reduce using rule 83 (expr_array_helper1 -> LSQUARE expr RSQUARE expr_array_helper1 .)
    LEQ             reduce using rule 83 (expr_array_helper1 -> LSQUARE expr RSQUARE expr_array_helper1 .)
    GEQ             reduce using rule 83 (expr_array_helper1 -> LSQUARE expr RSQUARE expr_array_helper1 .)
    RPAREN          reduce using rule 83 (expr_array_helper1 -> LSQUARE expr RSQUARE expr_array_helper1 .)
    RSQUARE         reduce using rule 83 (expr_array_helper1 -> LSQUARE expr RSQUARE expr_array_helper1 .)


state 205

    (85) expr_array_helper2 -> LSQUARE RSQUARE expr_array_helper2 .

    SEMICOLON       reduce using rule 85 (expr_array_helper2 -> LSQUARE RSQUARE expr_array_helper2 .)
    PLUS            reduce using rule 85 (expr_array_helper2 -> LSQUARE RSQUARE expr_array_helper2 .)
    MINUS           reduce using rule 85 (expr_array_helper2 -> LSQUARE RSQUARE expr_array_helper2 .)
    MULT            reduce using rule 85 (expr_array_helper2 -> LSQUARE RSQUARE expr_array_helper2 .)
    DIV             reduce using rule 85 (expr_array_helper2 -> LSQUARE RSQUARE expr_array_helper2 .)
    OR              reduce using rule 85 (expr_array_helper2 -> LSQUARE RSQUARE expr_array_helper2 .)
    AND             reduce using rule 85 (expr_array_helper2 -> LSQUARE RSQUARE expr_array_helper2 .)
    EQUALS          reduce using rule 85 (expr_array_helper2 -> LSQUARE RSQUARE expr_array_helper2 .)
    NOTEQUALS       reduce using rule 85 (expr_array_helper2 -> LSQUARE RSQUARE expr_array_helper2 .)
    LT              reduce using rule 85 (expr_array_helper2 -> LSQUARE RSQUARE expr_array_helper2 .)
    GT              reduce using rule 85 (expr_array_helper2 -> LSQUARE RSQUARE expr_array_helper2 .)
    LEQ             reduce using rule 85 (expr_array_helper2 -> LSQUARE RSQUARE expr_array_helper2 .)
    GEQ             reduce using rule 85 (expr_array_helper2 -> LSQUARE RSQUARE expr_array_helper2 .)
    RPAREN          reduce using rule 85 (expr_array_helper2 -> LSQUARE RSQUARE expr_array_helper2 .)
    RSQUARE         reduce using rule 85 (expr_array_helper2 -> LSQUARE RSQUARE expr_array_helper2 .)


state 206

    (49) stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt .

    IF              reduce using rule 49 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    WHILE           reduce using rule 49 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    FOR             reduce using rule 49 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    RETURN          reduce using rule 49 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    BREAK           reduce using rule 49 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    CONTINUE        reduce using rule 49 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    SEMICOLON       reduce using rule 49 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    LCURLY          reduce using rule 49 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    INT             reduce using rule 49 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    FLOAT           reduce using rule 49 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    BOOLEAN         reduce using rule 49 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    IDENTIFIER      reduce using rule 49 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    RCURLY          reduce using rule 49 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    ELSE            reduce using rule 49 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)


state 207

    (47) stmt -> FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt .

    IF              reduce using rule 47 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt .)
    WHILE           reduce using rule 47 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt .)
    FOR             reduce using rule 47 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt .)
    RETURN          reduce using rule 47 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt .)
    BREAK           reduce using rule 47 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt .)
    CONTINUE        reduce using rule 47 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt .)
    SEMICOLON       reduce using rule 47 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt .)
    LCURLY          reduce using rule 47 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt .)
    INT             reduce using rule 47 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt .)
    FLOAT           reduce using rule 47 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt .)
    BOOLEAN         reduce using rule 47 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt .)
    IDENTIFIER      reduce using rule 47 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt .)
    RCURLY          reduce using rule 47 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt .)
    ELSE            reduce using rule 47 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt .)


state 208

    (48) stmt -> FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN . stmt
    (39) stmt -> . IF LPAREN expr RPAREN stmt
    (40) stmt -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (41) stmt -> . WHILE LPAREN expr RPAREN stmt
    (42) stmt -> . FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt
    (43) stmt -> . FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt
    (44) stmt -> . FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt
    (45) stmt -> . FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt
    (46) stmt -> . FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (47) stmt -> . FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt
    (48) stmt -> . FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (49) stmt -> . FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt
    (50) stmt -> . RETURN SEMICOLON
    (51) stmt -> . RETURN expr SEMICOLON
    (52) stmt -> . stmt_expr SEMICOLON
    (53) stmt -> . BREAK SEMICOLON
    (54) stmt -> . CONTINUE SEMICOLON
    (55) stmt -> . block
    (56) stmt -> . var_decl
    (57) stmt -> . SEMICOLON
    (86) stmt_expr -> . empty
    (35) block -> . LCURLY stmthelper RCURLY
    (36) block -> . LCURLY RCURLY
    (15) var_decl -> . type variables SEMICOLON
    (108) empty -> .
    (16) type -> . INT
    (17) type -> . FLOAT
    (18) type -> . BOOLEAN
    (19) type -> . IDENTIFIER

  ! shift/reduce conflict for SEMICOLON resolved as shift
    IF              shift and go to state 70
    WHILE           shift and go to state 62
    FOR             shift and go to state 68
    RETURN          shift and go to state 61
    BREAK           shift and go to state 73
    CONTINUE        shift and go to state 74
    SEMICOLON       shift and go to state 63
    LCURLY          shift and go to state 49
    INT             shift and go to state 17
    FLOAT           shift and go to state 19
    BOOLEAN         shift and go to state 21
    IDENTIFIER      shift and go to state 38

  ! SEMICOLON       [ reduce using rule 108 (empty -> .) ]

    var_decl                       shift and go to state 72
    stmt                           shift and go to state 214
    stmt_expr                      shift and go to state 65
    block                          shift and go to state 75
    type                           shift and go to state 66
    empty                          shift and go to state 67

state 209

    (43) stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt .

    IF              reduce using rule 43 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt .)
    WHILE           reduce using rule 43 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt .)
    FOR             reduce using rule 43 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt .)
    RETURN          reduce using rule 43 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt .)
    BREAK           reduce using rule 43 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt .)
    CONTINUE        reduce using rule 43 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt .)
    SEMICOLON       reduce using rule 43 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt .)
    LCURLY          reduce using rule 43 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt .)
    INT             reduce using rule 43 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt .)
    FLOAT           reduce using rule 43 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt .)
    BOOLEAN         reduce using rule 43 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt .)
    IDENTIFIER      reduce using rule 43 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt .)
    RCURLY          reduce using rule 43 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt .)
    ELSE            reduce using rule 43 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt .)


state 210

    (45) stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN . stmt
    (39) stmt -> . IF LPAREN expr RPAREN stmt
    (40) stmt -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (41) stmt -> . WHILE LPAREN expr RPAREN stmt
    (42) stmt -> . FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt
    (43) stmt -> . FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt
    (44) stmt -> . FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt
    (45) stmt -> . FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt
    (46) stmt -> . FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (47) stmt -> . FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt
    (48) stmt -> . FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (49) stmt -> . FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt
    (50) stmt -> . RETURN SEMICOLON
    (51) stmt -> . RETURN expr SEMICOLON
    (52) stmt -> . stmt_expr SEMICOLON
    (53) stmt -> . BREAK SEMICOLON
    (54) stmt -> . CONTINUE SEMICOLON
    (55) stmt -> . block
    (56) stmt -> . var_decl
    (57) stmt -> . SEMICOLON
    (86) stmt_expr -> . empty
    (35) block -> . LCURLY stmthelper RCURLY
    (36) block -> . LCURLY RCURLY
    (15) var_decl -> . type variables SEMICOLON
    (108) empty -> .
    (16) type -> . INT
    (17) type -> . FLOAT
    (18) type -> . BOOLEAN
    (19) type -> . IDENTIFIER

  ! shift/reduce conflict for SEMICOLON resolved as shift
    IF              shift and go to state 70
    WHILE           shift and go to state 62
    FOR             shift and go to state 68
    RETURN          shift and go to state 61
    BREAK           shift and go to state 73
    CONTINUE        shift and go to state 74
    SEMICOLON       shift and go to state 63
    LCURLY          shift and go to state 49
    INT             shift and go to state 17
    FLOAT           shift and go to state 19
    BOOLEAN         shift and go to state 21
    IDENTIFIER      shift and go to state 38

  ! SEMICOLON       [ reduce using rule 108 (empty -> .) ]

    var_decl                       shift and go to state 72
    stmt                           shift and go to state 215
    stmt_expr                      shift and go to state 65
    block                          shift and go to state 75
    type                           shift and go to state 66
    empty                          shift and go to state 67

state 211

    (44) stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN . stmt
    (39) stmt -> . IF LPAREN expr RPAREN stmt
    (40) stmt -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (41) stmt -> . WHILE LPAREN expr RPAREN stmt
    (42) stmt -> . FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt
    (43) stmt -> . FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt
    (44) stmt -> . FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt
    (45) stmt -> . FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt
    (46) stmt -> . FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (47) stmt -> . FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt
    (48) stmt -> . FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (49) stmt -> . FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt
    (50) stmt -> . RETURN SEMICOLON
    (51) stmt -> . RETURN expr SEMICOLON
    (52) stmt -> . stmt_expr SEMICOLON
    (53) stmt -> . BREAK SEMICOLON
    (54) stmt -> . CONTINUE SEMICOLON
    (55) stmt -> . block
    (56) stmt -> . var_decl
    (57) stmt -> . SEMICOLON
    (86) stmt_expr -> . empty
    (35) block -> . LCURLY stmthelper RCURLY
    (36) block -> . LCURLY RCURLY
    (15) var_decl -> . type variables SEMICOLON
    (108) empty -> .
    (16) type -> . INT
    (17) type -> . FLOAT
    (18) type -> . BOOLEAN
    (19) type -> . IDENTIFIER

  ! shift/reduce conflict for SEMICOLON resolved as shift
    IF              shift and go to state 70
    WHILE           shift and go to state 62
    FOR             shift and go to state 68
    RETURN          shift and go to state 61
    BREAK           shift and go to state 73
    CONTINUE        shift and go to state 74
    SEMICOLON       shift and go to state 63
    LCURLY          shift and go to state 49
    INT             shift and go to state 17
    FLOAT           shift and go to state 19
    BOOLEAN         shift and go to state 21
    IDENTIFIER      shift and go to state 38

  ! SEMICOLON       [ reduce using rule 108 (empty -> .) ]

    var_decl                       shift and go to state 72
    stmt                           shift and go to state 216
    stmt_expr                      shift and go to state 65
    block                          shift and go to state 75
    type                           shift and go to state 66
    empty                          shift and go to state 67

state 212

    (46) stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr . RPAREN stmt

    RPAREN          shift and go to state 217


state 213

    (40) stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .

    IF              reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    WHILE           reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    FOR             reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    RETURN          reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    BREAK           reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    CONTINUE        reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    SEMICOLON       reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    LCURLY          reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    INT             reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    FLOAT           reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    BOOLEAN         reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    IDENTIFIER      reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    RCURLY          reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    ELSE            reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)


state 214

    (48) stmt -> FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .

    IF              reduce using rule 48 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    WHILE           reduce using rule 48 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    FOR             reduce using rule 48 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    RETURN          reduce using rule 48 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    BREAK           reduce using rule 48 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    CONTINUE        reduce using rule 48 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    SEMICOLON       reduce using rule 48 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    LCURLY          reduce using rule 48 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    INT             reduce using rule 48 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    FLOAT           reduce using rule 48 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    BOOLEAN         reduce using rule 48 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    IDENTIFIER      reduce using rule 48 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    RCURLY          reduce using rule 48 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    ELSE            reduce using rule 48 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)


state 215

    (45) stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt .

    IF              reduce using rule 45 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    WHILE           reduce using rule 45 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    FOR             reduce using rule 45 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    RETURN          reduce using rule 45 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    BREAK           reduce using rule 45 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    CONTINUE        reduce using rule 45 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    SEMICOLON       reduce using rule 45 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    LCURLY          reduce using rule 45 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    INT             reduce using rule 45 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    FLOAT           reduce using rule 45 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    BOOLEAN         reduce using rule 45 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    IDENTIFIER      reduce using rule 45 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    RCURLY          reduce using rule 45 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    ELSE            reduce using rule 45 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)


state 216

    (44) stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt .

    IF              reduce using rule 44 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt .)
    WHILE           reduce using rule 44 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt .)
    FOR             reduce using rule 44 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt .)
    RETURN          reduce using rule 44 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt .)
    BREAK           reduce using rule 44 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt .)
    CONTINUE        reduce using rule 44 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt .)
    SEMICOLON       reduce using rule 44 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt .)
    LCURLY          reduce using rule 44 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt .)
    INT             reduce using rule 44 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt .)
    FLOAT           reduce using rule 44 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt .)
    BOOLEAN         reduce using rule 44 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt .)
    IDENTIFIER      reduce using rule 44 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt .)
    RCURLY          reduce using rule 44 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt .)
    ELSE            reduce using rule 44 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt .)


state 217

    (46) stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN . stmt
    (39) stmt -> . IF LPAREN expr RPAREN stmt
    (40) stmt -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (41) stmt -> . WHILE LPAREN expr RPAREN stmt
    (42) stmt -> . FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt
    (43) stmt -> . FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt
    (44) stmt -> . FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt
    (45) stmt -> . FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt
    (46) stmt -> . FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (47) stmt -> . FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt
    (48) stmt -> . FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (49) stmt -> . FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt
    (50) stmt -> . RETURN SEMICOLON
    (51) stmt -> . RETURN expr SEMICOLON
    (52) stmt -> . stmt_expr SEMICOLON
    (53) stmt -> . BREAK SEMICOLON
    (54) stmt -> . CONTINUE SEMICOLON
    (55) stmt -> . block
    (56) stmt -> . var_decl
    (57) stmt -> . SEMICOLON
    (86) stmt_expr -> . empty
    (35) block -> . LCURLY stmthelper RCURLY
    (36) block -> . LCURLY RCURLY
    (15) var_decl -> . type variables SEMICOLON
    (108) empty -> .
    (16) type -> . INT
    (17) type -> . FLOAT
    (18) type -> . BOOLEAN
    (19) type -> . IDENTIFIER

  ! shift/reduce conflict for SEMICOLON resolved as shift
    IF              shift and go to state 70
    WHILE           shift and go to state 62
    FOR             shift and go to state 68
    RETURN          shift and go to state 61
    BREAK           shift and go to state 73
    CONTINUE        shift and go to state 74
    SEMICOLON       shift and go to state 63
    LCURLY          shift and go to state 49
    INT             shift and go to state 17
    FLOAT           shift and go to state 19
    BOOLEAN         shift and go to state 21
    IDENTIFIER      shift and go to state 38

  ! SEMICOLON       [ reduce using rule 108 (empty -> .) ]

    var_decl                       shift and go to state 72
    stmt                           shift and go to state 218
    stmt_expr                      shift and go to state 65
    block                          shift and go to state 75
    type                           shift and go to state 66
    empty                          shift and go to state 67

state 218

    (46) stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .

    IF              reduce using rule 46 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    WHILE           reduce using rule 46 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    FOR             reduce using rule 46 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    RETURN          reduce using rule 46 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    BREAK           reduce using rule 46 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    CONTINUE        reduce using rule 46 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    SEMICOLON       reduce using rule 46 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    LCURLY          reduce using rule 46 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    INT             reduce using rule 46 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    FLOAT           reduce using rule 46 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    BOOLEAN         reduce using rule 46 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    IDENTIFIER      reduce using rule 46 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    RCURLY          reduce using rule 46 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    ELSE            reduce using rule 46 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for SEMICOLON in state 49 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 69 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 95 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 109 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 120 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 120 resolved as shift
WARNING: shift/reduce conflict for MULT in state 120 resolved as shift
WARNING: shift/reduce conflict for DIV in state 120 resolved as shift
WARNING: shift/reduce conflict for OR in state 120 resolved as shift
WARNING: shift/reduce conflict for AND in state 120 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 120 resolved as shift
WARNING: shift/reduce conflict for NOTEQUALS in state 120 resolved as shift
WARNING: shift/reduce conflict for LT in state 120 resolved as shift
WARNING: shift/reduce conflict for GT in state 120 resolved as shift
WARNING: shift/reduce conflict for LEQ in state 120 resolved as shift
WARNING: shift/reduce conflict for GEQ in state 120 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 168 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 168 resolved as shift
WARNING: shift/reduce conflict for MULT in state 168 resolved as shift
WARNING: shift/reduce conflict for DIV in state 168 resolved as shift
WARNING: shift/reduce conflict for OR in state 168 resolved as shift
WARNING: shift/reduce conflict for AND in state 168 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 168 resolved as shift
WARNING: shift/reduce conflict for NOTEQUALS in state 168 resolved as shift
WARNING: shift/reduce conflict for LT in state 168 resolved as shift
WARNING: shift/reduce conflict for GT in state 168 resolved as shift
WARNING: shift/reduce conflict for LEQ in state 168 resolved as shift
WARNING: shift/reduce conflict for GEQ in state 168 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 171 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 172 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 175 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 186 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 188 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 189 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 191 resolved as shift
WARNING: shift/reduce conflict for LSQUARE in state 194 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 197 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 198 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 200 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 202 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 203 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 208 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 210 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 211 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 217 resolved as shift
