Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Unused terminals:

    DO
    COMMENT
    COLON
    SPACE
    BLOCKCOMMENT

Grammar

Rule 0     S' -> classdecl
Rule 1     classdecl -> CLASS IDENTIFIER LCURLY RCURLY
Rule 2     classdecl -> CLASS IDENTIFIER LCURLY field_decl class_body_decl RCURLY
Rule 3     classdecl -> CLASS IDENTIFIER LCURLY method_decl class_body_decl RCURLY
Rule 4     classdecl -> CLASS IDENTIFIER LCURLY constructor_decl class_body_decl RCURLY
Rule 5     classdecl -> CLASS IDENTIFIER EXTENDS IDENTIFIER LCURLY field_decl class_body_decl RCURLY
Rule 6     classdecl -> CLASS IDENTIFIER EXTENDS IDENTIFIER LCURLY constructor_decl class_body_decl RCURLY
Rule 7     classdecl -> CLASS IDENTIFIER EXTENDS IDENTIFIER LCURLY method_decl class_body_decl RCURLY
Rule 8     class_body_decl -> field_decl class_body_decl
Rule 9     class_body_decl -> method_decl class_body_decl
Rule 10    class_body_decl -> constructor_decl class_body_decl
Rule 11    class_body_decl -> empty
Rule 12    field_decl -> modifier var_decl
Rule 13    modifier -> PUBLIC
Rule 14    modifier -> PRIVATE
Rule 15    modifier -> STATIC
Rule 16    modifier -> PUBLIC STATIC
Rule 17    modifier -> PRIVATE STATIC
Rule 18    modifier -> empty
Rule 19    var_decl -> type variables SEMICOLON
Rule 20    type -> INT
Rule 21    type -> FLOAT
Rule 22    type -> BOOLEAN
Rule 23    type -> IDENTIFIER
Rule 24    variables -> IDENTIFIER brackets
Rule 25    variables -> variables COMMA IDENTIFIER brackets
Rule 26    brackets -> LSQUARE RSQUARE brackets
Rule 27    brackets -> empty
Rule 28    method_decl -> modifier type IDENTIFIER LPAREN RPAREN block
Rule 29    method_decl -> modifier VOID IDENTIFIER LPAREN RPAREN block
Rule 30    method_decl -> modifier VOID IDENTIFIER LPAREN formals RPAREN block
Rule 31    method_decl -> modifier type IDENTIFIER LPAREN formals RPAREN block
Rule 32    constructor_decl -> modifier IDENTIFIER LPAREN RPAREN block
Rule 33    constructor_decl -> modifier IDENTIFIER LPAREN formals RPAREN block
Rule 34    formals -> type variables
Rule 35    formals -> type variables COMMA formals
Rule 36    block -> LCURLY empty RCURLY
Rule 37    block -> LCURLY stmthelper RCURLY
Rule 38    stmthelper -> stmt
Rule 39    stmthelper -> stmthelper stmt
Rule 40    stmt -> IF LPAREN expr RPAREN stmt ELSE stmt
Rule 41    stmt -> IF LPAREN expr RPAREN stmt
Rule 42    stmt -> WHILE LPAREN expr RPAREN stmt
Rule 43    stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt
Rule 44    stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt
Rule 45    stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt
Rule 46    stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt
Rule 47    stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
Rule 48    stmt -> FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt
Rule 49    stmt -> FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
Rule 50    stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt
Rule 51    stmt -> block
Rule 52    stmt -> var_decl
Rule 53    stmt -> stmt_expr SEMICOLON
Rule 54    stmt -> RETURN expr SEMICOLON
Rule 55    stmt -> RETURN SEMICOLON
Rule 56    stmt -> BREAK SEMICOLON
Rule 57    stmt -> CONTINUE SEMICOLON
Rule 58    stmt -> SEMICOLON
Rule 59    expr -> primary
Rule 60    expr -> assign
Rule 61    expr -> new_array
Rule 62    expr -> expr OR expr
Rule 63    expr -> expr AND expr
Rule 64    expr -> expr EQUALS expr
Rule 65    expr -> expr NOTEQUALS expr
Rule 66    expr -> expr LT expr
Rule 67    expr -> expr GT expr
Rule 68    expr -> expr LEQ expr
Rule 69    expr -> expr GEQ expr
Rule 70    expr -> expr PLUS expr
Rule 71    expr -> expr MINUS expr
Rule 72    expr -> expr MULT expr
Rule 73    expr -> expr DIV expr
Rule 74    expr -> NOT expr
Rule 75    expr -> MINUS expr
Rule 76    expr -> PLUS expr
Rule 77    assign -> lhs ASSIGN expr
Rule 78    assign -> lhs PLUSPLUS
Rule 79    assign -> PLUSPLUS lhs
Rule 80    assign -> lhs MINUSMINUS
Rule 81    assign -> MINUSMINUS lhs
Rule 82    new_array -> NEW type expr_array_helper
Rule 83    expr_array_helper -> LSQUARE expr RSQUARE
Rule 84    expr_array_helper -> LSQUARE expr RSQUARE expr_array_helper
Rule 85    expr_array_helper -> LSQUARE expr RSQUARE expr_array_helper2
Rule 86    expr_array_helper2 -> LSQUARE RSQUARE
Rule 87    expr_array_helper2 -> LSQUARE RSQUARE expr_array_helper2
Rule 88    stmt_expr -> assign
Rule 89    stmt_expr -> method_invocation
Rule 90    literal -> INTEGERCONSTANT
Rule 91    literal -> FLOATCONSTANT
Rule 92    literal -> STRINGCONSTANT
Rule 93    literal -> NULL
Rule 94    literal -> TRUE
Rule 95    literal -> FALSE
Rule 96    primary -> literal
Rule 97    primary -> THIS
Rule 98    primary -> SUPER
Rule 99    primary -> LPAREN expr RPAREN
Rule 100   primary -> NEW IDENTIFIER LPAREN RPAREN
Rule 101   primary -> NEW IDENTIFIER LPAREN arguments RPAREN
Rule 102   primary -> lhs
Rule 103   primary -> method_invocation
Rule 104   arguments -> expr
Rule 105   arguments -> arguments COMMA expr
Rule 106   lhs -> field_access
Rule 107   lhs -> array_access
Rule 108   field_access -> primary DOT IDENTIFIER
Rule 109   field_access -> IDENTIFIER
Rule 110   array_access -> primary LSQUARE expr RSQUARE
Rule 111   method_invocation -> field_access LPAREN RPAREN
Rule 112   method_invocation -> field_access LPAREN arguments RPAREN
Rule 113   empty -> <empty>

Terminals, with rules where they appear

AND                  : 63
ASSIGN               : 77
BLOCKCOMMENT         : 
BOOLEAN              : 22
BREAK                : 56
CLASS                : 1 2 3 4 5 6 7
COLON                : 
COMMA                : 25 35 105
COMMENT              : 
CONTINUE             : 57
DIV                  : 73
DO                   : 
DOT                  : 108
ELSE                 : 40
EQUALS               : 64
EXTENDS              : 5 6 7
FALSE                : 95
FLOAT                : 21
FLOATCONSTANT        : 91
FOR                  : 43 44 45 46 47 48 49 50
GEQ                  : 69
GT                   : 67
IDENTIFIER           : 1 2 3 4 5 5 6 6 7 7 23 24 25 28 29 30 31 32 33 100 101 108 109
IF                   : 40 41
INT                  : 20
INTEGERCONSTANT      : 90
LCURLY               : 1 2 3 4 5 6 7 36 37
LEQ                  : 68
LPAREN               : 28 29 30 31 32 33 40 41 42 43 44 45 46 47 48 49 50 99 100 101 111 112
LSQUARE              : 26 83 84 85 86 87 110
LT                   : 66
MINUS                : 71 75
MINUSMINUS           : 80 81
MULT                 : 72
NEW                  : 82 100 101
NOT                  : 74
NOTEQUALS            : 65
NULL                 : 93
OR                   : 62
PLUS                 : 70 76
PLUSPLUS             : 78 79
PRIVATE              : 14 17
PUBLIC               : 13 16
RCURLY               : 1 2 3 4 5 6 7 36 37
RETURN               : 54 55
RPAREN               : 28 29 30 31 32 33 40 41 42 43 44 45 46 47 48 49 50 99 100 101 111 112
RSQUARE              : 26 83 84 85 86 87 110
SEMICOLON            : 19 43 43 44 44 45 45 46 46 47 47 48 48 49 49 50 50 53 54 55 56 57 58
SPACE                : 
STATIC               : 15 16 17
STRINGCONSTANT       : 92
SUPER                : 98
THIS                 : 97
TRUE                 : 94
VOID                 : 29 30
WHILE                : 42
error                : 

Nonterminals, with rules where they appear

arguments            : 101 105 112
array_access         : 107
assign               : 60 88
block                : 28 29 30 31 32 33 51
brackets             : 24 25 26
class_body_decl      : 2 3 4 5 6 7 8 9 10
classdecl            : 0
constructor_decl     : 4 6 10
empty                : 11 18 27 36
expr                 : 40 41 42 45 47 48 49 54 62 62 63 63 64 64 65 65 66 66 67 67 68 68 69 69 70 70 71 71 72 72 73 73 74 75 76 77 83 84 85 99 104 105 110
expr_array_helper    : 82 84
expr_array_helper2   : 85 87
field_access         : 106 111 112
field_decl           : 2 5 8
formals              : 30 31 33 35
lhs                  : 77 78 79 80 81 102
literal              : 96
method_decl          : 3 7 9
method_invocation    : 89 103
modifier             : 12 28 29 30 31 32 33
new_array            : 61
primary              : 59 108 110
stmt                 : 38 39 40 40 41 42 43 44 45 46 47 48 49 50
stmt_expr            : 44 45 46 46 47 47 49 50 53
stmthelper           : 37 39
type                 : 19 28 31 34 35 82
var_decl             : 12 52
variables            : 19 25 34 35

Parsing method: LALR

state 0

    (0) S' -> . classdecl
    (1) classdecl -> . CLASS IDENTIFIER LCURLY RCURLY
    (2) classdecl -> . CLASS IDENTIFIER LCURLY field_decl class_body_decl RCURLY
    (3) classdecl -> . CLASS IDENTIFIER LCURLY method_decl class_body_decl RCURLY
    (4) classdecl -> . CLASS IDENTIFIER LCURLY constructor_decl class_body_decl RCURLY
    (5) classdecl -> . CLASS IDENTIFIER EXTENDS IDENTIFIER LCURLY field_decl class_body_decl RCURLY
    (6) classdecl -> . CLASS IDENTIFIER EXTENDS IDENTIFIER LCURLY constructor_decl class_body_decl RCURLY
    (7) classdecl -> . CLASS IDENTIFIER EXTENDS IDENTIFIER LCURLY method_decl class_body_decl RCURLY

    CLASS           shift and go to state 2

    classdecl                      shift and go to state 1

state 1

    (0) S' -> classdecl .



state 2

    (1) classdecl -> CLASS . IDENTIFIER LCURLY RCURLY
    (2) classdecl -> CLASS . IDENTIFIER LCURLY field_decl class_body_decl RCURLY
    (3) classdecl -> CLASS . IDENTIFIER LCURLY method_decl class_body_decl RCURLY
    (4) classdecl -> CLASS . IDENTIFIER LCURLY constructor_decl class_body_decl RCURLY
    (5) classdecl -> CLASS . IDENTIFIER EXTENDS IDENTIFIER LCURLY field_decl class_body_decl RCURLY
    (6) classdecl -> CLASS . IDENTIFIER EXTENDS IDENTIFIER LCURLY constructor_decl class_body_decl RCURLY
    (7) classdecl -> CLASS . IDENTIFIER EXTENDS IDENTIFIER LCURLY method_decl class_body_decl RCURLY

    IDENTIFIER      shift and go to state 3


state 3

    (1) classdecl -> CLASS IDENTIFIER . LCURLY RCURLY
    (2) classdecl -> CLASS IDENTIFIER . LCURLY field_decl class_body_decl RCURLY
    (3) classdecl -> CLASS IDENTIFIER . LCURLY method_decl class_body_decl RCURLY
    (4) classdecl -> CLASS IDENTIFIER . LCURLY constructor_decl class_body_decl RCURLY
    (5) classdecl -> CLASS IDENTIFIER . EXTENDS IDENTIFIER LCURLY field_decl class_body_decl RCURLY
    (6) classdecl -> CLASS IDENTIFIER . EXTENDS IDENTIFIER LCURLY constructor_decl class_body_decl RCURLY
    (7) classdecl -> CLASS IDENTIFIER . EXTENDS IDENTIFIER LCURLY method_decl class_body_decl RCURLY

    LCURLY          shift and go to state 4
    EXTENDS         shift and go to state 5


state 4

    (1) classdecl -> CLASS IDENTIFIER LCURLY . RCURLY
    (2) classdecl -> CLASS IDENTIFIER LCURLY . field_decl class_body_decl RCURLY
    (3) classdecl -> CLASS IDENTIFIER LCURLY . method_decl class_body_decl RCURLY
    (4) classdecl -> CLASS IDENTIFIER LCURLY . constructor_decl class_body_decl RCURLY
    (12) field_decl -> . modifier var_decl
    (28) method_decl -> . modifier type IDENTIFIER LPAREN RPAREN block
    (29) method_decl -> . modifier VOID IDENTIFIER LPAREN RPAREN block
    (30) method_decl -> . modifier VOID IDENTIFIER LPAREN formals RPAREN block
    (31) method_decl -> . modifier type IDENTIFIER LPAREN formals RPAREN block
    (32) constructor_decl -> . modifier IDENTIFIER LPAREN RPAREN block
    (33) constructor_decl -> . modifier IDENTIFIER LPAREN formals RPAREN block
    (13) modifier -> . PUBLIC
    (14) modifier -> . PRIVATE
    (15) modifier -> . STATIC
    (16) modifier -> . PUBLIC STATIC
    (17) modifier -> . PRIVATE STATIC
    (18) modifier -> . empty
    (113) empty -> .

    RCURLY          shift and go to state 7
    PUBLIC          shift and go to state 11
    PRIVATE         shift and go to state 14
    STATIC          shift and go to state 13
    VOID            reduce using rule 113 (empty -> .)
    IDENTIFIER      reduce using rule 113 (empty -> .)
    INT             reduce using rule 113 (empty -> .)
    FLOAT           reduce using rule 113 (empty -> .)
    BOOLEAN         reduce using rule 113 (empty -> .)

    field_decl                     shift and go to state 8
    constructor_decl               shift and go to state 9
    method_decl                    shift and go to state 10
    empty                          shift and go to state 12
    modifier                       shift and go to state 6

state 5

    (5) classdecl -> CLASS IDENTIFIER EXTENDS . IDENTIFIER LCURLY field_decl class_body_decl RCURLY
    (6) classdecl -> CLASS IDENTIFIER EXTENDS . IDENTIFIER LCURLY constructor_decl class_body_decl RCURLY
    (7) classdecl -> CLASS IDENTIFIER EXTENDS . IDENTIFIER LCURLY method_decl class_body_decl RCURLY

    IDENTIFIER      shift and go to state 15


state 6

    (12) field_decl -> modifier . var_decl
    (28) method_decl -> modifier . type IDENTIFIER LPAREN RPAREN block
    (29) method_decl -> modifier . VOID IDENTIFIER LPAREN RPAREN block
    (30) method_decl -> modifier . VOID IDENTIFIER LPAREN formals RPAREN block
    (31) method_decl -> modifier . type IDENTIFIER LPAREN formals RPAREN block
    (32) constructor_decl -> modifier . IDENTIFIER LPAREN RPAREN block
    (33) constructor_decl -> modifier . IDENTIFIER LPAREN formals RPAREN block
    (19) var_decl -> . type variables SEMICOLON
    (20) type -> . INT
    (21) type -> . FLOAT
    (22) type -> . BOOLEAN
    (23) type -> . IDENTIFIER

    VOID            shift and go to state 17
    IDENTIFIER      shift and go to state 21
    INT             shift and go to state 16
    FLOAT           shift and go to state 18
    BOOLEAN         shift and go to state 20

    var_decl                       shift and go to state 19
    type                           shift and go to state 22

state 7

    (1) classdecl -> CLASS IDENTIFIER LCURLY RCURLY .

    $end            reduce using rule 1 (classdecl -> CLASS IDENTIFIER LCURLY RCURLY .)


state 8

    (2) classdecl -> CLASS IDENTIFIER LCURLY field_decl . class_body_decl RCURLY
    (8) class_body_decl -> . field_decl class_body_decl
    (9) class_body_decl -> . method_decl class_body_decl
    (10) class_body_decl -> . constructor_decl class_body_decl
    (11) class_body_decl -> . empty
    (12) field_decl -> . modifier var_decl
    (28) method_decl -> . modifier type IDENTIFIER LPAREN RPAREN block
    (29) method_decl -> . modifier VOID IDENTIFIER LPAREN RPAREN block
    (30) method_decl -> . modifier VOID IDENTIFIER LPAREN formals RPAREN block
    (31) method_decl -> . modifier type IDENTIFIER LPAREN formals RPAREN block
    (32) constructor_decl -> . modifier IDENTIFIER LPAREN RPAREN block
    (33) constructor_decl -> . modifier IDENTIFIER LPAREN formals RPAREN block
    (113) empty -> .
    (13) modifier -> . PUBLIC
    (14) modifier -> . PRIVATE
    (15) modifier -> . STATIC
    (16) modifier -> . PUBLIC STATIC
    (17) modifier -> . PRIVATE STATIC
    (18) modifier -> . empty

    RCURLY          reduce using rule 113 (empty -> .)
    VOID            reduce using rule 113 (empty -> .)
    IDENTIFIER      reduce using rule 113 (empty -> .)
    INT             reduce using rule 113 (empty -> .)
    FLOAT           reduce using rule 113 (empty -> .)
    BOOLEAN         reduce using rule 113 (empty -> .)
    PUBLIC          shift and go to state 11
    PRIVATE         shift and go to state 14
    STATIC          shift and go to state 13

    class_body_decl                shift and go to state 23
    field_decl                     shift and go to state 24
    constructor_decl               shift and go to state 25
    method_decl                    shift and go to state 26
    modifier                       shift and go to state 6
    empty                          shift and go to state 27

state 9

    (4) classdecl -> CLASS IDENTIFIER LCURLY constructor_decl . class_body_decl RCURLY
    (8) class_body_decl -> . field_decl class_body_decl
    (9) class_body_decl -> . method_decl class_body_decl
    (10) class_body_decl -> . constructor_decl class_body_decl
    (11) class_body_decl -> . empty
    (12) field_decl -> . modifier var_decl
    (28) method_decl -> . modifier type IDENTIFIER LPAREN RPAREN block
    (29) method_decl -> . modifier VOID IDENTIFIER LPAREN RPAREN block
    (30) method_decl -> . modifier VOID IDENTIFIER LPAREN formals RPAREN block
    (31) method_decl -> . modifier type IDENTIFIER LPAREN formals RPAREN block
    (32) constructor_decl -> . modifier IDENTIFIER LPAREN RPAREN block
    (33) constructor_decl -> . modifier IDENTIFIER LPAREN formals RPAREN block
    (113) empty -> .
    (13) modifier -> . PUBLIC
    (14) modifier -> . PRIVATE
    (15) modifier -> . STATIC
    (16) modifier -> . PUBLIC STATIC
    (17) modifier -> . PRIVATE STATIC
    (18) modifier -> . empty

    RCURLY          reduce using rule 113 (empty -> .)
    VOID            reduce using rule 113 (empty -> .)
    IDENTIFIER      reduce using rule 113 (empty -> .)
    INT             reduce using rule 113 (empty -> .)
    FLOAT           reduce using rule 113 (empty -> .)
    BOOLEAN         reduce using rule 113 (empty -> .)
    PUBLIC          shift and go to state 11
    PRIVATE         shift and go to state 14
    STATIC          shift and go to state 13

    class_body_decl                shift and go to state 28
    field_decl                     shift and go to state 24
    constructor_decl               shift and go to state 25
    method_decl                    shift and go to state 26
    modifier                       shift and go to state 6
    empty                          shift and go to state 27

state 10

    (3) classdecl -> CLASS IDENTIFIER LCURLY method_decl . class_body_decl RCURLY
    (8) class_body_decl -> . field_decl class_body_decl
    (9) class_body_decl -> . method_decl class_body_decl
    (10) class_body_decl -> . constructor_decl class_body_decl
    (11) class_body_decl -> . empty
    (12) field_decl -> . modifier var_decl
    (28) method_decl -> . modifier type IDENTIFIER LPAREN RPAREN block
    (29) method_decl -> . modifier VOID IDENTIFIER LPAREN RPAREN block
    (30) method_decl -> . modifier VOID IDENTIFIER LPAREN formals RPAREN block
    (31) method_decl -> . modifier type IDENTIFIER LPAREN formals RPAREN block
    (32) constructor_decl -> . modifier IDENTIFIER LPAREN RPAREN block
    (33) constructor_decl -> . modifier IDENTIFIER LPAREN formals RPAREN block
    (113) empty -> .
    (13) modifier -> . PUBLIC
    (14) modifier -> . PRIVATE
    (15) modifier -> . STATIC
    (16) modifier -> . PUBLIC STATIC
    (17) modifier -> . PRIVATE STATIC
    (18) modifier -> . empty

    RCURLY          reduce using rule 113 (empty -> .)
    VOID            reduce using rule 113 (empty -> .)
    IDENTIFIER      reduce using rule 113 (empty -> .)
    INT             reduce using rule 113 (empty -> .)
    FLOAT           reduce using rule 113 (empty -> .)
    BOOLEAN         reduce using rule 113 (empty -> .)
    PUBLIC          shift and go to state 11
    PRIVATE         shift and go to state 14
    STATIC          shift and go to state 13

    class_body_decl                shift and go to state 29
    field_decl                     shift and go to state 24
    constructor_decl               shift and go to state 25
    method_decl                    shift and go to state 26
    modifier                       shift and go to state 6
    empty                          shift and go to state 27

state 11

    (13) modifier -> PUBLIC .
    (16) modifier -> PUBLIC . STATIC

    VOID            reduce using rule 13 (modifier -> PUBLIC .)
    IDENTIFIER      reduce using rule 13 (modifier -> PUBLIC .)
    INT             reduce using rule 13 (modifier -> PUBLIC .)
    FLOAT           reduce using rule 13 (modifier -> PUBLIC .)
    BOOLEAN         reduce using rule 13 (modifier -> PUBLIC .)
    STATIC          shift and go to state 30


state 12

    (18) modifier -> empty .

    VOID            reduce using rule 18 (modifier -> empty .)
    IDENTIFIER      reduce using rule 18 (modifier -> empty .)
    INT             reduce using rule 18 (modifier -> empty .)
    FLOAT           reduce using rule 18 (modifier -> empty .)
    BOOLEAN         reduce using rule 18 (modifier -> empty .)


state 13

    (15) modifier -> STATIC .

    VOID            reduce using rule 15 (modifier -> STATIC .)
    IDENTIFIER      reduce using rule 15 (modifier -> STATIC .)
    INT             reduce using rule 15 (modifier -> STATIC .)
    FLOAT           reduce using rule 15 (modifier -> STATIC .)
    BOOLEAN         reduce using rule 15 (modifier -> STATIC .)


state 14

    (14) modifier -> PRIVATE .
    (17) modifier -> PRIVATE . STATIC

    VOID            reduce using rule 14 (modifier -> PRIVATE .)
    IDENTIFIER      reduce using rule 14 (modifier -> PRIVATE .)
    INT             reduce using rule 14 (modifier -> PRIVATE .)
    FLOAT           reduce using rule 14 (modifier -> PRIVATE .)
    BOOLEAN         reduce using rule 14 (modifier -> PRIVATE .)
    STATIC          shift and go to state 31


state 15

    (5) classdecl -> CLASS IDENTIFIER EXTENDS IDENTIFIER . LCURLY field_decl class_body_decl RCURLY
    (6) classdecl -> CLASS IDENTIFIER EXTENDS IDENTIFIER . LCURLY constructor_decl class_body_decl RCURLY
    (7) classdecl -> CLASS IDENTIFIER EXTENDS IDENTIFIER . LCURLY method_decl class_body_decl RCURLY

    LCURLY          shift and go to state 32


state 16

    (20) type -> INT .

    LSQUARE         reduce using rule 20 (type -> INT .)
    IDENTIFIER      reduce using rule 20 (type -> INT .)


state 17

    (29) method_decl -> modifier VOID . IDENTIFIER LPAREN RPAREN block
    (30) method_decl -> modifier VOID . IDENTIFIER LPAREN formals RPAREN block

    IDENTIFIER      shift and go to state 33


state 18

    (21) type -> FLOAT .

    LSQUARE         reduce using rule 21 (type -> FLOAT .)
    IDENTIFIER      reduce using rule 21 (type -> FLOAT .)


state 19

    (12) field_decl -> modifier var_decl .

    PUBLIC          reduce using rule 12 (field_decl -> modifier var_decl .)
    PRIVATE         reduce using rule 12 (field_decl -> modifier var_decl .)
    STATIC          reduce using rule 12 (field_decl -> modifier var_decl .)
    VOID            reduce using rule 12 (field_decl -> modifier var_decl .)
    IDENTIFIER      reduce using rule 12 (field_decl -> modifier var_decl .)
    INT             reduce using rule 12 (field_decl -> modifier var_decl .)
    FLOAT           reduce using rule 12 (field_decl -> modifier var_decl .)
    BOOLEAN         reduce using rule 12 (field_decl -> modifier var_decl .)
    RCURLY          reduce using rule 12 (field_decl -> modifier var_decl .)


state 20

    (22) type -> BOOLEAN .

    LSQUARE         reduce using rule 22 (type -> BOOLEAN .)
    IDENTIFIER      reduce using rule 22 (type -> BOOLEAN .)


state 21

    (32) constructor_decl -> modifier IDENTIFIER . LPAREN RPAREN block
    (33) constructor_decl -> modifier IDENTIFIER . LPAREN formals RPAREN block
    (23) type -> IDENTIFIER .

    LPAREN          shift and go to state 34
    IDENTIFIER      reduce using rule 23 (type -> IDENTIFIER .)


state 22

    (28) method_decl -> modifier type . IDENTIFIER LPAREN RPAREN block
    (31) method_decl -> modifier type . IDENTIFIER LPAREN formals RPAREN block
    (19) var_decl -> type . variables SEMICOLON
    (24) variables -> . IDENTIFIER brackets
    (25) variables -> . variables COMMA IDENTIFIER brackets

    IDENTIFIER      shift and go to state 36

    variables                      shift and go to state 35

state 23

    (2) classdecl -> CLASS IDENTIFIER LCURLY field_decl class_body_decl . RCURLY

    RCURLY          shift and go to state 37


state 24

    (8) class_body_decl -> field_decl . class_body_decl
    (8) class_body_decl -> . field_decl class_body_decl
    (9) class_body_decl -> . method_decl class_body_decl
    (10) class_body_decl -> . constructor_decl class_body_decl
    (11) class_body_decl -> . empty
    (12) field_decl -> . modifier var_decl
    (28) method_decl -> . modifier type IDENTIFIER LPAREN RPAREN block
    (29) method_decl -> . modifier VOID IDENTIFIER LPAREN RPAREN block
    (30) method_decl -> . modifier VOID IDENTIFIER LPAREN formals RPAREN block
    (31) method_decl -> . modifier type IDENTIFIER LPAREN formals RPAREN block
    (32) constructor_decl -> . modifier IDENTIFIER LPAREN RPAREN block
    (33) constructor_decl -> . modifier IDENTIFIER LPAREN formals RPAREN block
    (113) empty -> .
    (13) modifier -> . PUBLIC
    (14) modifier -> . PRIVATE
    (15) modifier -> . STATIC
    (16) modifier -> . PUBLIC STATIC
    (17) modifier -> . PRIVATE STATIC
    (18) modifier -> . empty

    RCURLY          reduce using rule 113 (empty -> .)
    VOID            reduce using rule 113 (empty -> .)
    IDENTIFIER      reduce using rule 113 (empty -> .)
    INT             reduce using rule 113 (empty -> .)
    FLOAT           reduce using rule 113 (empty -> .)
    BOOLEAN         reduce using rule 113 (empty -> .)
    PUBLIC          shift and go to state 11
    PRIVATE         shift and go to state 14
    STATIC          shift and go to state 13

    class_body_decl                shift and go to state 38
    field_decl                     shift and go to state 24
    constructor_decl               shift and go to state 25
    method_decl                    shift and go to state 26
    modifier                       shift and go to state 6
    empty                          shift and go to state 27

state 25

    (10) class_body_decl -> constructor_decl . class_body_decl
    (8) class_body_decl -> . field_decl class_body_decl
    (9) class_body_decl -> . method_decl class_body_decl
    (10) class_body_decl -> . constructor_decl class_body_decl
    (11) class_body_decl -> . empty
    (12) field_decl -> . modifier var_decl
    (28) method_decl -> . modifier type IDENTIFIER LPAREN RPAREN block
    (29) method_decl -> . modifier VOID IDENTIFIER LPAREN RPAREN block
    (30) method_decl -> . modifier VOID IDENTIFIER LPAREN formals RPAREN block
    (31) method_decl -> . modifier type IDENTIFIER LPAREN formals RPAREN block
    (32) constructor_decl -> . modifier IDENTIFIER LPAREN RPAREN block
    (33) constructor_decl -> . modifier IDENTIFIER LPAREN formals RPAREN block
    (113) empty -> .
    (13) modifier -> . PUBLIC
    (14) modifier -> . PRIVATE
    (15) modifier -> . STATIC
    (16) modifier -> . PUBLIC STATIC
    (17) modifier -> . PRIVATE STATIC
    (18) modifier -> . empty

    RCURLY          reduce using rule 113 (empty -> .)
    VOID            reduce using rule 113 (empty -> .)
    IDENTIFIER      reduce using rule 113 (empty -> .)
    INT             reduce using rule 113 (empty -> .)
    FLOAT           reduce using rule 113 (empty -> .)
    BOOLEAN         reduce using rule 113 (empty -> .)
    PUBLIC          shift and go to state 11
    PRIVATE         shift and go to state 14
    STATIC          shift and go to state 13

    class_body_decl                shift and go to state 39
    field_decl                     shift and go to state 24
    constructor_decl               shift and go to state 25
    method_decl                    shift and go to state 26
    modifier                       shift and go to state 6
    empty                          shift and go to state 27

state 26

    (9) class_body_decl -> method_decl . class_body_decl
    (8) class_body_decl -> . field_decl class_body_decl
    (9) class_body_decl -> . method_decl class_body_decl
    (10) class_body_decl -> . constructor_decl class_body_decl
    (11) class_body_decl -> . empty
    (12) field_decl -> . modifier var_decl
    (28) method_decl -> . modifier type IDENTIFIER LPAREN RPAREN block
    (29) method_decl -> . modifier VOID IDENTIFIER LPAREN RPAREN block
    (30) method_decl -> . modifier VOID IDENTIFIER LPAREN formals RPAREN block
    (31) method_decl -> . modifier type IDENTIFIER LPAREN formals RPAREN block
    (32) constructor_decl -> . modifier IDENTIFIER LPAREN RPAREN block
    (33) constructor_decl -> . modifier IDENTIFIER LPAREN formals RPAREN block
    (113) empty -> .
    (13) modifier -> . PUBLIC
    (14) modifier -> . PRIVATE
    (15) modifier -> . STATIC
    (16) modifier -> . PUBLIC STATIC
    (17) modifier -> . PRIVATE STATIC
    (18) modifier -> . empty

    RCURLY          reduce using rule 113 (empty -> .)
    VOID            reduce using rule 113 (empty -> .)
    IDENTIFIER      reduce using rule 113 (empty -> .)
    INT             reduce using rule 113 (empty -> .)
    FLOAT           reduce using rule 113 (empty -> .)
    BOOLEAN         reduce using rule 113 (empty -> .)
    PUBLIC          shift and go to state 11
    PRIVATE         shift and go to state 14
    STATIC          shift and go to state 13

    class_body_decl                shift and go to state 40
    field_decl                     shift and go to state 24
    constructor_decl               shift and go to state 25
    method_decl                    shift and go to state 26
    modifier                       shift and go to state 6
    empty                          shift and go to state 27

state 27

    (11) class_body_decl -> empty .
    (18) modifier -> empty .

    RCURLY          reduce using rule 11 (class_body_decl -> empty .)
    VOID            reduce using rule 18 (modifier -> empty .)
    IDENTIFIER      reduce using rule 18 (modifier -> empty .)
    INT             reduce using rule 18 (modifier -> empty .)
    FLOAT           reduce using rule 18 (modifier -> empty .)
    BOOLEAN         reduce using rule 18 (modifier -> empty .)


state 28

    (4) classdecl -> CLASS IDENTIFIER LCURLY constructor_decl class_body_decl . RCURLY

    RCURLY          shift and go to state 41


state 29

    (3) classdecl -> CLASS IDENTIFIER LCURLY method_decl class_body_decl . RCURLY

    RCURLY          shift and go to state 42


state 30

    (16) modifier -> PUBLIC STATIC .

    VOID            reduce using rule 16 (modifier -> PUBLIC STATIC .)
    IDENTIFIER      reduce using rule 16 (modifier -> PUBLIC STATIC .)
    INT             reduce using rule 16 (modifier -> PUBLIC STATIC .)
    FLOAT           reduce using rule 16 (modifier -> PUBLIC STATIC .)
    BOOLEAN         reduce using rule 16 (modifier -> PUBLIC STATIC .)


state 31

    (17) modifier -> PRIVATE STATIC .

    VOID            reduce using rule 17 (modifier -> PRIVATE STATIC .)
    IDENTIFIER      reduce using rule 17 (modifier -> PRIVATE STATIC .)
    INT             reduce using rule 17 (modifier -> PRIVATE STATIC .)
    FLOAT           reduce using rule 17 (modifier -> PRIVATE STATIC .)
    BOOLEAN         reduce using rule 17 (modifier -> PRIVATE STATIC .)


state 32

    (5) classdecl -> CLASS IDENTIFIER EXTENDS IDENTIFIER LCURLY . field_decl class_body_decl RCURLY
    (6) classdecl -> CLASS IDENTIFIER EXTENDS IDENTIFIER LCURLY . constructor_decl class_body_decl RCURLY
    (7) classdecl -> CLASS IDENTIFIER EXTENDS IDENTIFIER LCURLY . method_decl class_body_decl RCURLY
    (12) field_decl -> . modifier var_decl
    (32) constructor_decl -> . modifier IDENTIFIER LPAREN RPAREN block
    (33) constructor_decl -> . modifier IDENTIFIER LPAREN formals RPAREN block
    (28) method_decl -> . modifier type IDENTIFIER LPAREN RPAREN block
    (29) method_decl -> . modifier VOID IDENTIFIER LPAREN RPAREN block
    (30) method_decl -> . modifier VOID IDENTIFIER LPAREN formals RPAREN block
    (31) method_decl -> . modifier type IDENTIFIER LPAREN formals RPAREN block
    (13) modifier -> . PUBLIC
    (14) modifier -> . PRIVATE
    (15) modifier -> . STATIC
    (16) modifier -> . PUBLIC STATIC
    (17) modifier -> . PRIVATE STATIC
    (18) modifier -> . empty
    (113) empty -> .

    PUBLIC          shift and go to state 11
    PRIVATE         shift and go to state 14
    STATIC          shift and go to state 13
    IDENTIFIER      reduce using rule 113 (empty -> .)
    VOID            reduce using rule 113 (empty -> .)
    INT             reduce using rule 113 (empty -> .)
    FLOAT           reduce using rule 113 (empty -> .)
    BOOLEAN         reduce using rule 113 (empty -> .)

    field_decl                     shift and go to state 44
    constructor_decl               shift and go to state 45
    method_decl                    shift and go to state 46
    empty                          shift and go to state 12
    modifier                       shift and go to state 43

state 33

    (29) method_decl -> modifier VOID IDENTIFIER . LPAREN RPAREN block
    (30) method_decl -> modifier VOID IDENTIFIER . LPAREN formals RPAREN block

    LPAREN          shift and go to state 47


state 34

    (32) constructor_decl -> modifier IDENTIFIER LPAREN . RPAREN block
    (33) constructor_decl -> modifier IDENTIFIER LPAREN . formals RPAREN block
    (34) formals -> . type variables
    (35) formals -> . type variables COMMA formals
    (20) type -> . INT
    (21) type -> . FLOAT
    (22) type -> . BOOLEAN
    (23) type -> . IDENTIFIER

    RPAREN          shift and go to state 48
    INT             shift and go to state 16
    FLOAT           shift and go to state 18
    BOOLEAN         shift and go to state 20
    IDENTIFIER      shift and go to state 49

    type                           shift and go to state 50
    formals                        shift and go to state 51

state 35

    (19) var_decl -> type variables . SEMICOLON
    (25) variables -> variables . COMMA IDENTIFIER brackets

    SEMICOLON       shift and go to state 52
    COMMA           shift and go to state 53


state 36

    (28) method_decl -> modifier type IDENTIFIER . LPAREN RPAREN block
    (31) method_decl -> modifier type IDENTIFIER . LPAREN formals RPAREN block
    (24) variables -> IDENTIFIER . brackets
    (26) brackets -> . LSQUARE RSQUARE brackets
    (27) brackets -> . empty
    (113) empty -> .

    LPAREN          shift and go to state 57
    LSQUARE         shift and go to state 54
    SEMICOLON       reduce using rule 113 (empty -> .)
    COMMA           reduce using rule 113 (empty -> .)

    brackets                       shift and go to state 55
    empty                          shift and go to state 56

state 37

    (2) classdecl -> CLASS IDENTIFIER LCURLY field_decl class_body_decl RCURLY .

    $end            reduce using rule 2 (classdecl -> CLASS IDENTIFIER LCURLY field_decl class_body_decl RCURLY .)


state 38

    (8) class_body_decl -> field_decl class_body_decl .

    RCURLY          reduce using rule 8 (class_body_decl -> field_decl class_body_decl .)


state 39

    (10) class_body_decl -> constructor_decl class_body_decl .

    RCURLY          reduce using rule 10 (class_body_decl -> constructor_decl class_body_decl .)


state 40

    (9) class_body_decl -> method_decl class_body_decl .

    RCURLY          reduce using rule 9 (class_body_decl -> method_decl class_body_decl .)


state 41

    (4) classdecl -> CLASS IDENTIFIER LCURLY constructor_decl class_body_decl RCURLY .

    $end            reduce using rule 4 (classdecl -> CLASS IDENTIFIER LCURLY constructor_decl class_body_decl RCURLY .)


state 42

    (3) classdecl -> CLASS IDENTIFIER LCURLY method_decl class_body_decl RCURLY .

    $end            reduce using rule 3 (classdecl -> CLASS IDENTIFIER LCURLY method_decl class_body_decl RCURLY .)


state 43

    (12) field_decl -> modifier . var_decl
    (32) constructor_decl -> modifier . IDENTIFIER LPAREN RPAREN block
    (33) constructor_decl -> modifier . IDENTIFIER LPAREN formals RPAREN block
    (28) method_decl -> modifier . type IDENTIFIER LPAREN RPAREN block
    (29) method_decl -> modifier . VOID IDENTIFIER LPAREN RPAREN block
    (30) method_decl -> modifier . VOID IDENTIFIER LPAREN formals RPAREN block
    (31) method_decl -> modifier . type IDENTIFIER LPAREN formals RPAREN block
    (19) var_decl -> . type variables SEMICOLON
    (20) type -> . INT
    (21) type -> . FLOAT
    (22) type -> . BOOLEAN
    (23) type -> . IDENTIFIER

    IDENTIFIER      shift and go to state 21
    VOID            shift and go to state 17
    INT             shift and go to state 16
    FLOAT           shift and go to state 18
    BOOLEAN         shift and go to state 20

    var_decl                       shift and go to state 19
    type                           shift and go to state 22

state 44

    (5) classdecl -> CLASS IDENTIFIER EXTENDS IDENTIFIER LCURLY field_decl . class_body_decl RCURLY
    (8) class_body_decl -> . field_decl class_body_decl
    (9) class_body_decl -> . method_decl class_body_decl
    (10) class_body_decl -> . constructor_decl class_body_decl
    (11) class_body_decl -> . empty
    (12) field_decl -> . modifier var_decl
    (28) method_decl -> . modifier type IDENTIFIER LPAREN RPAREN block
    (29) method_decl -> . modifier VOID IDENTIFIER LPAREN RPAREN block
    (30) method_decl -> . modifier VOID IDENTIFIER LPAREN formals RPAREN block
    (31) method_decl -> . modifier type IDENTIFIER LPAREN formals RPAREN block
    (32) constructor_decl -> . modifier IDENTIFIER LPAREN RPAREN block
    (33) constructor_decl -> . modifier IDENTIFIER LPAREN formals RPAREN block
    (113) empty -> .
    (13) modifier -> . PUBLIC
    (14) modifier -> . PRIVATE
    (15) modifier -> . STATIC
    (16) modifier -> . PUBLIC STATIC
    (17) modifier -> . PRIVATE STATIC
    (18) modifier -> . empty

    RCURLY          reduce using rule 113 (empty -> .)
    VOID            reduce using rule 113 (empty -> .)
    IDENTIFIER      reduce using rule 113 (empty -> .)
    INT             reduce using rule 113 (empty -> .)
    FLOAT           reduce using rule 113 (empty -> .)
    BOOLEAN         reduce using rule 113 (empty -> .)
    PUBLIC          shift and go to state 11
    PRIVATE         shift and go to state 14
    STATIC          shift and go to state 13

    class_body_decl                shift and go to state 58
    field_decl                     shift and go to state 24
    constructor_decl               shift and go to state 25
    method_decl                    shift and go to state 26
    modifier                       shift and go to state 6
    empty                          shift and go to state 27

state 45

    (6) classdecl -> CLASS IDENTIFIER EXTENDS IDENTIFIER LCURLY constructor_decl . class_body_decl RCURLY
    (8) class_body_decl -> . field_decl class_body_decl
    (9) class_body_decl -> . method_decl class_body_decl
    (10) class_body_decl -> . constructor_decl class_body_decl
    (11) class_body_decl -> . empty
    (12) field_decl -> . modifier var_decl
    (28) method_decl -> . modifier type IDENTIFIER LPAREN RPAREN block
    (29) method_decl -> . modifier VOID IDENTIFIER LPAREN RPAREN block
    (30) method_decl -> . modifier VOID IDENTIFIER LPAREN formals RPAREN block
    (31) method_decl -> . modifier type IDENTIFIER LPAREN formals RPAREN block
    (32) constructor_decl -> . modifier IDENTIFIER LPAREN RPAREN block
    (33) constructor_decl -> . modifier IDENTIFIER LPAREN formals RPAREN block
    (113) empty -> .
    (13) modifier -> . PUBLIC
    (14) modifier -> . PRIVATE
    (15) modifier -> . STATIC
    (16) modifier -> . PUBLIC STATIC
    (17) modifier -> . PRIVATE STATIC
    (18) modifier -> . empty

    RCURLY          reduce using rule 113 (empty -> .)
    VOID            reduce using rule 113 (empty -> .)
    IDENTIFIER      reduce using rule 113 (empty -> .)
    INT             reduce using rule 113 (empty -> .)
    FLOAT           reduce using rule 113 (empty -> .)
    BOOLEAN         reduce using rule 113 (empty -> .)
    PUBLIC          shift and go to state 11
    PRIVATE         shift and go to state 14
    STATIC          shift and go to state 13

    class_body_decl                shift and go to state 59
    field_decl                     shift and go to state 24
    constructor_decl               shift and go to state 25
    method_decl                    shift and go to state 26
    modifier                       shift and go to state 6
    empty                          shift and go to state 27

state 46

    (7) classdecl -> CLASS IDENTIFIER EXTENDS IDENTIFIER LCURLY method_decl . class_body_decl RCURLY
    (8) class_body_decl -> . field_decl class_body_decl
    (9) class_body_decl -> . method_decl class_body_decl
    (10) class_body_decl -> . constructor_decl class_body_decl
    (11) class_body_decl -> . empty
    (12) field_decl -> . modifier var_decl
    (28) method_decl -> . modifier type IDENTIFIER LPAREN RPAREN block
    (29) method_decl -> . modifier VOID IDENTIFIER LPAREN RPAREN block
    (30) method_decl -> . modifier VOID IDENTIFIER LPAREN formals RPAREN block
    (31) method_decl -> . modifier type IDENTIFIER LPAREN formals RPAREN block
    (32) constructor_decl -> . modifier IDENTIFIER LPAREN RPAREN block
    (33) constructor_decl -> . modifier IDENTIFIER LPAREN formals RPAREN block
    (113) empty -> .
    (13) modifier -> . PUBLIC
    (14) modifier -> . PRIVATE
    (15) modifier -> . STATIC
    (16) modifier -> . PUBLIC STATIC
    (17) modifier -> . PRIVATE STATIC
    (18) modifier -> . empty

    RCURLY          reduce using rule 113 (empty -> .)
    VOID            reduce using rule 113 (empty -> .)
    IDENTIFIER      reduce using rule 113 (empty -> .)
    INT             reduce using rule 113 (empty -> .)
    FLOAT           reduce using rule 113 (empty -> .)
    BOOLEAN         reduce using rule 113 (empty -> .)
    PUBLIC          shift and go to state 11
    PRIVATE         shift and go to state 14
    STATIC          shift and go to state 13

    class_body_decl                shift and go to state 60
    field_decl                     shift and go to state 24
    constructor_decl               shift and go to state 25
    method_decl                    shift and go to state 26
    modifier                       shift and go to state 6
    empty                          shift and go to state 27

state 47

    (29) method_decl -> modifier VOID IDENTIFIER LPAREN . RPAREN block
    (30) method_decl -> modifier VOID IDENTIFIER LPAREN . formals RPAREN block
    (34) formals -> . type variables
    (35) formals -> . type variables COMMA formals
    (20) type -> . INT
    (21) type -> . FLOAT
    (22) type -> . BOOLEAN
    (23) type -> . IDENTIFIER

    RPAREN          shift and go to state 61
    INT             shift and go to state 16
    FLOAT           shift and go to state 18
    BOOLEAN         shift and go to state 20
    IDENTIFIER      shift and go to state 49

    type                           shift and go to state 50
    formals                        shift and go to state 62

state 48

    (32) constructor_decl -> modifier IDENTIFIER LPAREN RPAREN . block
    (36) block -> . LCURLY empty RCURLY
    (37) block -> . LCURLY stmthelper RCURLY

    LCURLY          shift and go to state 63

    block                          shift and go to state 64

state 49

    (23) type -> IDENTIFIER .

    IDENTIFIER      reduce using rule 23 (type -> IDENTIFIER .)


state 50

    (34) formals -> type . variables
    (35) formals -> type . variables COMMA formals
    (24) variables -> . IDENTIFIER brackets
    (25) variables -> . variables COMMA IDENTIFIER brackets

    IDENTIFIER      shift and go to state 66

    variables                      shift and go to state 65

state 51

    (33) constructor_decl -> modifier IDENTIFIER LPAREN formals . RPAREN block

    RPAREN          shift and go to state 67


state 52

    (19) var_decl -> type variables SEMICOLON .

    RCURLY          reduce using rule 19 (var_decl -> type variables SEMICOLON .)
    IF              reduce using rule 19 (var_decl -> type variables SEMICOLON .)
    WHILE           reduce using rule 19 (var_decl -> type variables SEMICOLON .)
    FOR             reduce using rule 19 (var_decl -> type variables SEMICOLON .)
    RETURN          reduce using rule 19 (var_decl -> type variables SEMICOLON .)
    BREAK           reduce using rule 19 (var_decl -> type variables SEMICOLON .)
    CONTINUE        reduce using rule 19 (var_decl -> type variables SEMICOLON .)
    SEMICOLON       reduce using rule 19 (var_decl -> type variables SEMICOLON .)
    LCURLY          reduce using rule 19 (var_decl -> type variables SEMICOLON .)
    INT             reduce using rule 19 (var_decl -> type variables SEMICOLON .)
    FLOAT           reduce using rule 19 (var_decl -> type variables SEMICOLON .)
    BOOLEAN         reduce using rule 19 (var_decl -> type variables SEMICOLON .)
    IDENTIFIER      reduce using rule 19 (var_decl -> type variables SEMICOLON .)
    PLUSPLUS        reduce using rule 19 (var_decl -> type variables SEMICOLON .)
    MINUSMINUS      reduce using rule 19 (var_decl -> type variables SEMICOLON .)
    THIS            reduce using rule 19 (var_decl -> type variables SEMICOLON .)
    SUPER           reduce using rule 19 (var_decl -> type variables SEMICOLON .)
    LPAREN          reduce using rule 19 (var_decl -> type variables SEMICOLON .)
    NEW             reduce using rule 19 (var_decl -> type variables SEMICOLON .)
    INTEGERCONSTANT reduce using rule 19 (var_decl -> type variables SEMICOLON .)
    FLOATCONSTANT   reduce using rule 19 (var_decl -> type variables SEMICOLON .)
    STRINGCONSTANT  reduce using rule 19 (var_decl -> type variables SEMICOLON .)
    NULL            reduce using rule 19 (var_decl -> type variables SEMICOLON .)
    TRUE            reduce using rule 19 (var_decl -> type variables SEMICOLON .)
    FALSE           reduce using rule 19 (var_decl -> type variables SEMICOLON .)
    ELSE            reduce using rule 19 (var_decl -> type variables SEMICOLON .)
    PUBLIC          reduce using rule 19 (var_decl -> type variables SEMICOLON .)
    PRIVATE         reduce using rule 19 (var_decl -> type variables SEMICOLON .)
    STATIC          reduce using rule 19 (var_decl -> type variables SEMICOLON .)
    VOID            reduce using rule 19 (var_decl -> type variables SEMICOLON .)


state 53

    (25) variables -> variables COMMA . IDENTIFIER brackets

    IDENTIFIER      shift and go to state 68


state 54

    (26) brackets -> LSQUARE . RSQUARE brackets

    RSQUARE         shift and go to state 69


state 55

    (24) variables -> IDENTIFIER brackets .

    COMMA           reduce using rule 24 (variables -> IDENTIFIER brackets .)
    RPAREN          reduce using rule 24 (variables -> IDENTIFIER brackets .)
    SEMICOLON       reduce using rule 24 (variables -> IDENTIFIER brackets .)


state 56

    (27) brackets -> empty .

    SEMICOLON       reduce using rule 27 (brackets -> empty .)
    COMMA           reduce using rule 27 (brackets -> empty .)
    RPAREN          reduce using rule 27 (brackets -> empty .)


state 57

    (28) method_decl -> modifier type IDENTIFIER LPAREN . RPAREN block
    (31) method_decl -> modifier type IDENTIFIER LPAREN . formals RPAREN block
    (34) formals -> . type variables
    (35) formals -> . type variables COMMA formals
    (20) type -> . INT
    (21) type -> . FLOAT
    (22) type -> . BOOLEAN
    (23) type -> . IDENTIFIER

    RPAREN          shift and go to state 70
    INT             shift and go to state 16
    FLOAT           shift and go to state 18
    BOOLEAN         shift and go to state 20
    IDENTIFIER      shift and go to state 49

    type                           shift and go to state 50
    formals                        shift and go to state 71

state 58

    (5) classdecl -> CLASS IDENTIFIER EXTENDS IDENTIFIER LCURLY field_decl class_body_decl . RCURLY

    RCURLY          shift and go to state 72


state 59

    (6) classdecl -> CLASS IDENTIFIER EXTENDS IDENTIFIER LCURLY constructor_decl class_body_decl . RCURLY

    RCURLY          shift and go to state 73


state 60

    (7) classdecl -> CLASS IDENTIFIER EXTENDS IDENTIFIER LCURLY method_decl class_body_decl . RCURLY

    RCURLY          shift and go to state 74


state 61

    (29) method_decl -> modifier VOID IDENTIFIER LPAREN RPAREN . block
    (36) block -> . LCURLY empty RCURLY
    (37) block -> . LCURLY stmthelper RCURLY

    LCURLY          shift and go to state 63

    block                          shift and go to state 75

state 62

    (30) method_decl -> modifier VOID IDENTIFIER LPAREN formals . RPAREN block

    RPAREN          shift and go to state 76


state 63

    (36) block -> LCURLY . empty RCURLY
    (37) block -> LCURLY . stmthelper RCURLY
    (113) empty -> .
    (38) stmthelper -> . stmt
    (39) stmthelper -> . stmthelper stmt
    (40) stmt -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (41) stmt -> . IF LPAREN expr RPAREN stmt
    (42) stmt -> . WHILE LPAREN expr RPAREN stmt
    (43) stmt -> . FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt
    (44) stmt -> . FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt
    (45) stmt -> . FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt
    (46) stmt -> . FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt
    (47) stmt -> . FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (48) stmt -> . FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt
    (49) stmt -> . FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (50) stmt -> . FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt
    (51) stmt -> . block
    (52) stmt -> . var_decl
    (53) stmt -> . stmt_expr SEMICOLON
    (54) stmt -> . RETURN expr SEMICOLON
    (55) stmt -> . RETURN SEMICOLON
    (56) stmt -> . BREAK SEMICOLON
    (57) stmt -> . CONTINUE SEMICOLON
    (58) stmt -> . SEMICOLON
    (36) block -> . LCURLY empty RCURLY
    (37) block -> . LCURLY stmthelper RCURLY
    (19) var_decl -> . type variables SEMICOLON
    (88) stmt_expr -> . assign
    (89) stmt_expr -> . method_invocation
    (20) type -> . INT
    (21) type -> . FLOAT
    (22) type -> . BOOLEAN
    (23) type -> . IDENTIFIER
    (77) assign -> . lhs ASSIGN expr
    (78) assign -> . lhs PLUSPLUS
    (79) assign -> . PLUSPLUS lhs
    (80) assign -> . lhs MINUSMINUS
    (81) assign -> . MINUSMINUS lhs
    (111) method_invocation -> . field_access LPAREN RPAREN
    (112) method_invocation -> . field_access LPAREN arguments RPAREN
    (106) lhs -> . field_access
    (107) lhs -> . array_access
    (108) field_access -> . primary DOT IDENTIFIER
    (109) field_access -> . IDENTIFIER
    (110) array_access -> . primary LSQUARE expr RSQUARE
    (96) primary -> . literal
    (97) primary -> . THIS
    (98) primary -> . SUPER
    (99) primary -> . LPAREN expr RPAREN
    (100) primary -> . NEW IDENTIFIER LPAREN RPAREN
    (101) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (102) primary -> . lhs
    (103) primary -> . method_invocation
    (90) literal -> . INTEGERCONSTANT
    (91) literal -> . FLOATCONSTANT
    (92) literal -> . STRINGCONSTANT
    (93) literal -> . NULL
    (94) literal -> . TRUE
    (95) literal -> . FALSE

    RCURLY          reduce using rule 113 (empty -> .)
    IF              shift and go to state 99
    WHILE           shift and go to state 79
    FOR             shift and go to state 93
    RETURN          shift and go to state 77
    BREAK           shift and go to state 104
    CONTINUE        shift and go to state 106
    SEMICOLON       shift and go to state 84
    LCURLY          shift and go to state 63
    INT             shift and go to state 16
    FLOAT           shift and go to state 18
    BOOLEAN         shift and go to state 20
    IDENTIFIER      shift and go to state 89
    PLUSPLUS        shift and go to state 94
    MINUSMINUS      shift and go to state 98
    THIS            shift and go to state 105
    SUPER           shift and go to state 108
    LPAREN          shift and go to state 96
    NEW             shift and go to state 80
    INTEGERCONSTANT shift and go to state 102
    FLOATCONSTANT   shift and go to state 100
    STRINGCONSTANT  shift and go to state 83
    NULL            shift and go to state 81
    TRUE            shift and go to state 85
    FALSE           shift and go to state 97

    field_access                   shift and go to state 92
    stmthelper                     shift and go to state 101
    var_decl                       shift and go to state 103
    primary                        shift and go to state 78
    stmt                           shift and go to state 95
    stmt_expr                      shift and go to state 86
    literal                        shift and go to state 87
    array_access                   shift and go to state 82
    lhs                            shift and go to state 107
    empty                          shift and go to state 91
    method_invocation              shift and go to state 88
    type                           shift and go to state 90
    assign                         shift and go to state 109
    block                          shift and go to state 110

state 64

    (32) constructor_decl -> modifier IDENTIFIER LPAREN RPAREN block .

    PUBLIC          reduce using rule 32 (constructor_decl -> modifier IDENTIFIER LPAREN RPAREN block .)
    PRIVATE         reduce using rule 32 (constructor_decl -> modifier IDENTIFIER LPAREN RPAREN block .)
    STATIC          reduce using rule 32 (constructor_decl -> modifier IDENTIFIER LPAREN RPAREN block .)
    VOID            reduce using rule 32 (constructor_decl -> modifier IDENTIFIER LPAREN RPAREN block .)
    IDENTIFIER      reduce using rule 32 (constructor_decl -> modifier IDENTIFIER LPAREN RPAREN block .)
    INT             reduce using rule 32 (constructor_decl -> modifier IDENTIFIER LPAREN RPAREN block .)
    FLOAT           reduce using rule 32 (constructor_decl -> modifier IDENTIFIER LPAREN RPAREN block .)
    BOOLEAN         reduce using rule 32 (constructor_decl -> modifier IDENTIFIER LPAREN RPAREN block .)
    RCURLY          reduce using rule 32 (constructor_decl -> modifier IDENTIFIER LPAREN RPAREN block .)


state 65

    (34) formals -> type variables .
    (35) formals -> type variables . COMMA formals
    (25) variables -> variables . COMMA IDENTIFIER brackets

    RPAREN          reduce using rule 34 (formals -> type variables .)
    COMMA           shift and go to state 111


state 66

    (24) variables -> IDENTIFIER . brackets
    (26) brackets -> . LSQUARE RSQUARE brackets
    (27) brackets -> . empty
    (113) empty -> .

    LSQUARE         shift and go to state 54
    COMMA           reduce using rule 113 (empty -> .)
    RPAREN          reduce using rule 113 (empty -> .)
    SEMICOLON       reduce using rule 113 (empty -> .)

    empty                          shift and go to state 56
    brackets                       shift and go to state 55

state 67

    (33) constructor_decl -> modifier IDENTIFIER LPAREN formals RPAREN . block
    (36) block -> . LCURLY empty RCURLY
    (37) block -> . LCURLY stmthelper RCURLY

    LCURLY          shift and go to state 63

    block                          shift and go to state 112

state 68

    (25) variables -> variables COMMA IDENTIFIER . brackets
    (26) brackets -> . LSQUARE RSQUARE brackets
    (27) brackets -> . empty
    (113) empty -> .

    LSQUARE         shift and go to state 54
    SEMICOLON       reduce using rule 113 (empty -> .)
    COMMA           reduce using rule 113 (empty -> .)

    empty                          shift and go to state 56
    brackets                       shift and go to state 113

state 69

    (26) brackets -> LSQUARE RSQUARE . brackets
    (26) brackets -> . LSQUARE RSQUARE brackets
    (27) brackets -> . empty
    (113) empty -> .

    LSQUARE         shift and go to state 54
    SEMICOLON       reduce using rule 113 (empty -> .)
    COMMA           reduce using rule 113 (empty -> .)
    RPAREN          reduce using rule 113 (empty -> .)

    empty                          shift and go to state 56
    brackets                       shift and go to state 114

state 70

    (28) method_decl -> modifier type IDENTIFIER LPAREN RPAREN . block
    (36) block -> . LCURLY empty RCURLY
    (37) block -> . LCURLY stmthelper RCURLY

    LCURLY          shift and go to state 63

    block                          shift and go to state 115

state 71

    (31) method_decl -> modifier type IDENTIFIER LPAREN formals . RPAREN block

    RPAREN          shift and go to state 116


state 72

    (5) classdecl -> CLASS IDENTIFIER EXTENDS IDENTIFIER LCURLY field_decl class_body_decl RCURLY .

    $end            reduce using rule 5 (classdecl -> CLASS IDENTIFIER EXTENDS IDENTIFIER LCURLY field_decl class_body_decl RCURLY .)


state 73

    (6) classdecl -> CLASS IDENTIFIER EXTENDS IDENTIFIER LCURLY constructor_decl class_body_decl RCURLY .

    $end            reduce using rule 6 (classdecl -> CLASS IDENTIFIER EXTENDS IDENTIFIER LCURLY constructor_decl class_body_decl RCURLY .)


state 74

    (7) classdecl -> CLASS IDENTIFIER EXTENDS IDENTIFIER LCURLY method_decl class_body_decl RCURLY .

    $end            reduce using rule 7 (classdecl -> CLASS IDENTIFIER EXTENDS IDENTIFIER LCURLY method_decl class_body_decl RCURLY .)


state 75

    (29) method_decl -> modifier VOID IDENTIFIER LPAREN RPAREN block .

    PUBLIC          reduce using rule 29 (method_decl -> modifier VOID IDENTIFIER LPAREN RPAREN block .)
    PRIVATE         reduce using rule 29 (method_decl -> modifier VOID IDENTIFIER LPAREN RPAREN block .)
    STATIC          reduce using rule 29 (method_decl -> modifier VOID IDENTIFIER LPAREN RPAREN block .)
    VOID            reduce using rule 29 (method_decl -> modifier VOID IDENTIFIER LPAREN RPAREN block .)
    IDENTIFIER      reduce using rule 29 (method_decl -> modifier VOID IDENTIFIER LPAREN RPAREN block .)
    INT             reduce using rule 29 (method_decl -> modifier VOID IDENTIFIER LPAREN RPAREN block .)
    FLOAT           reduce using rule 29 (method_decl -> modifier VOID IDENTIFIER LPAREN RPAREN block .)
    BOOLEAN         reduce using rule 29 (method_decl -> modifier VOID IDENTIFIER LPAREN RPAREN block .)
    RCURLY          reduce using rule 29 (method_decl -> modifier VOID IDENTIFIER LPAREN RPAREN block .)


state 76

    (30) method_decl -> modifier VOID IDENTIFIER LPAREN formals RPAREN . block
    (36) block -> . LCURLY empty RCURLY
    (37) block -> . LCURLY stmthelper RCURLY

    LCURLY          shift and go to state 63

    block                          shift and go to state 117

state 77

    (54) stmt -> RETURN . expr SEMICOLON
    (55) stmt -> RETURN . SEMICOLON
    (59) expr -> . primary
    (60) expr -> . assign
    (61) expr -> . new_array
    (62) expr -> . expr OR expr
    (63) expr -> . expr AND expr
    (64) expr -> . expr EQUALS expr
    (65) expr -> . expr NOTEQUALS expr
    (66) expr -> . expr LT expr
    (67) expr -> . expr GT expr
    (68) expr -> . expr LEQ expr
    (69) expr -> . expr GEQ expr
    (70) expr -> . expr PLUS expr
    (71) expr -> . expr MINUS expr
    (72) expr -> . expr MULT expr
    (73) expr -> . expr DIV expr
    (74) expr -> . NOT expr
    (75) expr -> . MINUS expr
    (76) expr -> . PLUS expr
    (96) primary -> . literal
    (97) primary -> . THIS
    (98) primary -> . SUPER
    (99) primary -> . LPAREN expr RPAREN
    (100) primary -> . NEW IDENTIFIER LPAREN RPAREN
    (101) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (102) primary -> . lhs
    (103) primary -> . method_invocation
    (77) assign -> . lhs ASSIGN expr
    (78) assign -> . lhs PLUSPLUS
    (79) assign -> . PLUSPLUS lhs
    (80) assign -> . lhs MINUSMINUS
    (81) assign -> . MINUSMINUS lhs
    (82) new_array -> . NEW type expr_array_helper
    (90) literal -> . INTEGERCONSTANT
    (91) literal -> . FLOATCONSTANT
    (92) literal -> . STRINGCONSTANT
    (93) literal -> . NULL
    (94) literal -> . TRUE
    (95) literal -> . FALSE
    (106) lhs -> . field_access
    (107) lhs -> . array_access
    (111) method_invocation -> . field_access LPAREN RPAREN
    (112) method_invocation -> . field_access LPAREN arguments RPAREN
    (108) field_access -> . primary DOT IDENTIFIER
    (109) field_access -> . IDENTIFIER
    (110) array_access -> . primary LSQUARE expr RSQUARE

    SEMICOLON       shift and go to state 122
    NOT             shift and go to state 130
    MINUS           shift and go to state 121
    PLUS            shift and go to state 123
    THIS            shift and go to state 105
    SUPER           shift and go to state 108
    LPAREN          shift and go to state 96
    NEW             shift and go to state 120
    PLUSPLUS        shift and go to state 94
    MINUSMINUS      shift and go to state 98
    INTEGERCONSTANT shift and go to state 102
    FLOATCONSTANT   shift and go to state 100
    STRINGCONSTANT  shift and go to state 83
    NULL            shift and go to state 81
    TRUE            shift and go to state 85
    FALSE           shift and go to state 97
    IDENTIFIER      shift and go to state 125

    new_array                      shift and go to state 118
    field_access                   shift and go to state 126
    expr                           shift and go to state 127
    primary                        shift and go to state 119
    array_access                   shift and go to state 82
    literal                        shift and go to state 87
    lhs                            shift and go to state 129
    method_invocation              shift and go to state 124
    assign                         shift and go to state 128

state 78

    (108) field_access -> primary . DOT IDENTIFIER
    (110) array_access -> primary . LSQUARE expr RSQUARE

    DOT             shift and go to state 132
    LSQUARE         shift and go to state 131


state 79

    (42) stmt -> WHILE . LPAREN expr RPAREN stmt

    LPAREN          shift and go to state 133


state 80

    (100) primary -> NEW . IDENTIFIER LPAREN RPAREN
    (101) primary -> NEW . IDENTIFIER LPAREN arguments RPAREN

    IDENTIFIER      shift and go to state 134


state 81

    (93) literal -> NULL .

    DOT             reduce using rule 93 (literal -> NULL .)
    LSQUARE         reduce using rule 93 (literal -> NULL .)
    OR              reduce using rule 93 (literal -> NULL .)
    AND             reduce using rule 93 (literal -> NULL .)
    EQUALS          reduce using rule 93 (literal -> NULL .)
    NOTEQUALS       reduce using rule 93 (literal -> NULL .)
    LT              reduce using rule 93 (literal -> NULL .)
    GT              reduce using rule 93 (literal -> NULL .)
    LEQ             reduce using rule 93 (literal -> NULL .)
    GEQ             reduce using rule 93 (literal -> NULL .)
    PLUS            reduce using rule 93 (literal -> NULL .)
    MINUS           reduce using rule 93 (literal -> NULL .)
    MULT            reduce using rule 93 (literal -> NULL .)
    DIV             reduce using rule 93 (literal -> NULL .)
    SEMICOLON       reduce using rule 93 (literal -> NULL .)
    RPAREN          reduce using rule 93 (literal -> NULL .)
    RSQUARE         reduce using rule 93 (literal -> NULL .)
    COMMA           reduce using rule 93 (literal -> NULL .)


state 82

    (107) lhs -> array_access .

    ASSIGN          reduce using rule 107 (lhs -> array_access .)
    PLUSPLUS        reduce using rule 107 (lhs -> array_access .)
    MINUSMINUS      reduce using rule 107 (lhs -> array_access .)
    DOT             reduce using rule 107 (lhs -> array_access .)
    LSQUARE         reduce using rule 107 (lhs -> array_access .)
    OR              reduce using rule 107 (lhs -> array_access .)
    AND             reduce using rule 107 (lhs -> array_access .)
    EQUALS          reduce using rule 107 (lhs -> array_access .)
    NOTEQUALS       reduce using rule 107 (lhs -> array_access .)
    LT              reduce using rule 107 (lhs -> array_access .)
    GT              reduce using rule 107 (lhs -> array_access .)
    LEQ             reduce using rule 107 (lhs -> array_access .)
    GEQ             reduce using rule 107 (lhs -> array_access .)
    PLUS            reduce using rule 107 (lhs -> array_access .)
    MINUS           reduce using rule 107 (lhs -> array_access .)
    MULT            reduce using rule 107 (lhs -> array_access .)
    DIV             reduce using rule 107 (lhs -> array_access .)
    SEMICOLON       reduce using rule 107 (lhs -> array_access .)
    RPAREN          reduce using rule 107 (lhs -> array_access .)
    RSQUARE         reduce using rule 107 (lhs -> array_access .)
    COMMA           reduce using rule 107 (lhs -> array_access .)


state 83

    (92) literal -> STRINGCONSTANT .

    DOT             reduce using rule 92 (literal -> STRINGCONSTANT .)
    LSQUARE         reduce using rule 92 (literal -> STRINGCONSTANT .)
    OR              reduce using rule 92 (literal -> STRINGCONSTANT .)
    AND             reduce using rule 92 (literal -> STRINGCONSTANT .)
    EQUALS          reduce using rule 92 (literal -> STRINGCONSTANT .)
    NOTEQUALS       reduce using rule 92 (literal -> STRINGCONSTANT .)
    LT              reduce using rule 92 (literal -> STRINGCONSTANT .)
    GT              reduce using rule 92 (literal -> STRINGCONSTANT .)
    LEQ             reduce using rule 92 (literal -> STRINGCONSTANT .)
    GEQ             reduce using rule 92 (literal -> STRINGCONSTANT .)
    PLUS            reduce using rule 92 (literal -> STRINGCONSTANT .)
    MINUS           reduce using rule 92 (literal -> STRINGCONSTANT .)
    MULT            reduce using rule 92 (literal -> STRINGCONSTANT .)
    DIV             reduce using rule 92 (literal -> STRINGCONSTANT .)
    SEMICOLON       reduce using rule 92 (literal -> STRINGCONSTANT .)
    RPAREN          reduce using rule 92 (literal -> STRINGCONSTANT .)
    RSQUARE         reduce using rule 92 (literal -> STRINGCONSTANT .)
    COMMA           reduce using rule 92 (literal -> STRINGCONSTANT .)


state 84

    (58) stmt -> SEMICOLON .

    RCURLY          reduce using rule 58 (stmt -> SEMICOLON .)
    IF              reduce using rule 58 (stmt -> SEMICOLON .)
    WHILE           reduce using rule 58 (stmt -> SEMICOLON .)
    FOR             reduce using rule 58 (stmt -> SEMICOLON .)
    RETURN          reduce using rule 58 (stmt -> SEMICOLON .)
    BREAK           reduce using rule 58 (stmt -> SEMICOLON .)
    CONTINUE        reduce using rule 58 (stmt -> SEMICOLON .)
    SEMICOLON       reduce using rule 58 (stmt -> SEMICOLON .)
    LCURLY          reduce using rule 58 (stmt -> SEMICOLON .)
    INT             reduce using rule 58 (stmt -> SEMICOLON .)
    FLOAT           reduce using rule 58 (stmt -> SEMICOLON .)
    BOOLEAN         reduce using rule 58 (stmt -> SEMICOLON .)
    IDENTIFIER      reduce using rule 58 (stmt -> SEMICOLON .)
    PLUSPLUS        reduce using rule 58 (stmt -> SEMICOLON .)
    MINUSMINUS      reduce using rule 58 (stmt -> SEMICOLON .)
    THIS            reduce using rule 58 (stmt -> SEMICOLON .)
    SUPER           reduce using rule 58 (stmt -> SEMICOLON .)
    LPAREN          reduce using rule 58 (stmt -> SEMICOLON .)
    NEW             reduce using rule 58 (stmt -> SEMICOLON .)
    INTEGERCONSTANT reduce using rule 58 (stmt -> SEMICOLON .)
    FLOATCONSTANT   reduce using rule 58 (stmt -> SEMICOLON .)
    STRINGCONSTANT  reduce using rule 58 (stmt -> SEMICOLON .)
    NULL            reduce using rule 58 (stmt -> SEMICOLON .)
    TRUE            reduce using rule 58 (stmt -> SEMICOLON .)
    FALSE           reduce using rule 58 (stmt -> SEMICOLON .)
    ELSE            reduce using rule 58 (stmt -> SEMICOLON .)


state 85

    (94) literal -> TRUE .

    DOT             reduce using rule 94 (literal -> TRUE .)
    LSQUARE         reduce using rule 94 (literal -> TRUE .)
    OR              reduce using rule 94 (literal -> TRUE .)
    AND             reduce using rule 94 (literal -> TRUE .)
    EQUALS          reduce using rule 94 (literal -> TRUE .)
    NOTEQUALS       reduce using rule 94 (literal -> TRUE .)
    LT              reduce using rule 94 (literal -> TRUE .)
    GT              reduce using rule 94 (literal -> TRUE .)
    LEQ             reduce using rule 94 (literal -> TRUE .)
    GEQ             reduce using rule 94 (literal -> TRUE .)
    PLUS            reduce using rule 94 (literal -> TRUE .)
    MINUS           reduce using rule 94 (literal -> TRUE .)
    MULT            reduce using rule 94 (literal -> TRUE .)
    DIV             reduce using rule 94 (literal -> TRUE .)
    SEMICOLON       reduce using rule 94 (literal -> TRUE .)
    RPAREN          reduce using rule 94 (literal -> TRUE .)
    RSQUARE         reduce using rule 94 (literal -> TRUE .)
    COMMA           reduce using rule 94 (literal -> TRUE .)


state 86

    (53) stmt -> stmt_expr . SEMICOLON

    SEMICOLON       shift and go to state 135


state 87

    (96) primary -> literal .

    DOT             reduce using rule 96 (primary -> literal .)
    LSQUARE         reduce using rule 96 (primary -> literal .)
    OR              reduce using rule 96 (primary -> literal .)
    AND             reduce using rule 96 (primary -> literal .)
    EQUALS          reduce using rule 96 (primary -> literal .)
    NOTEQUALS       reduce using rule 96 (primary -> literal .)
    LT              reduce using rule 96 (primary -> literal .)
    GT              reduce using rule 96 (primary -> literal .)
    LEQ             reduce using rule 96 (primary -> literal .)
    GEQ             reduce using rule 96 (primary -> literal .)
    PLUS            reduce using rule 96 (primary -> literal .)
    MINUS           reduce using rule 96 (primary -> literal .)
    MULT            reduce using rule 96 (primary -> literal .)
    DIV             reduce using rule 96 (primary -> literal .)
    SEMICOLON       reduce using rule 96 (primary -> literal .)
    RPAREN          reduce using rule 96 (primary -> literal .)
    RSQUARE         reduce using rule 96 (primary -> literal .)
    COMMA           reduce using rule 96 (primary -> literal .)


state 88

    (89) stmt_expr -> method_invocation .
    (103) primary -> method_invocation .

    SEMICOLON       reduce using rule 89 (stmt_expr -> method_invocation .)
    RPAREN          reduce using rule 89 (stmt_expr -> method_invocation .)
    DOT             reduce using rule 103 (primary -> method_invocation .)
    LSQUARE         reduce using rule 103 (primary -> method_invocation .)


state 89

    (23) type -> IDENTIFIER .
    (109) field_access -> IDENTIFIER .

    IDENTIFIER      reduce using rule 23 (type -> IDENTIFIER .)
    LPAREN          reduce using rule 109 (field_access -> IDENTIFIER .)
    ASSIGN          reduce using rule 109 (field_access -> IDENTIFIER .)
    PLUSPLUS        reduce using rule 109 (field_access -> IDENTIFIER .)
    MINUSMINUS      reduce using rule 109 (field_access -> IDENTIFIER .)
    DOT             reduce using rule 109 (field_access -> IDENTIFIER .)
    LSQUARE         reduce using rule 109 (field_access -> IDENTIFIER .)


state 90

    (19) var_decl -> type . variables SEMICOLON
    (24) variables -> . IDENTIFIER brackets
    (25) variables -> . variables COMMA IDENTIFIER brackets

    IDENTIFIER      shift and go to state 66

    variables                      shift and go to state 35

state 91

    (36) block -> LCURLY empty . RCURLY

    RCURLY          shift and go to state 136


state 92

    (111) method_invocation -> field_access . LPAREN RPAREN
    (112) method_invocation -> field_access . LPAREN arguments RPAREN
    (106) lhs -> field_access .

    LPAREN          shift and go to state 137
    ASSIGN          reduce using rule 106 (lhs -> field_access .)
    PLUSPLUS        reduce using rule 106 (lhs -> field_access .)
    MINUSMINUS      reduce using rule 106 (lhs -> field_access .)
    DOT             reduce using rule 106 (lhs -> field_access .)
    LSQUARE         reduce using rule 106 (lhs -> field_access .)


state 93

    (43) stmt -> FOR . LPAREN SEMICOLON SEMICOLON RPAREN stmt
    (44) stmt -> FOR . LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt
    (45) stmt -> FOR . LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt
    (46) stmt -> FOR . LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt
    (47) stmt -> FOR . LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (48) stmt -> FOR . LPAREN SEMICOLON expr SEMICOLON RPAREN stmt
    (49) stmt -> FOR . LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (50) stmt -> FOR . LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt

    LPAREN          shift and go to state 138


state 94

    (79) assign -> PLUSPLUS . lhs
    (106) lhs -> . field_access
    (107) lhs -> . array_access
    (108) field_access -> . primary DOT IDENTIFIER
    (109) field_access -> . IDENTIFIER
    (110) array_access -> . primary LSQUARE expr RSQUARE
    (96) primary -> . literal
    (97) primary -> . THIS
    (98) primary -> . SUPER
    (99) primary -> . LPAREN expr RPAREN
    (100) primary -> . NEW IDENTIFIER LPAREN RPAREN
    (101) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (102) primary -> . lhs
    (103) primary -> . method_invocation
    (90) literal -> . INTEGERCONSTANT
    (91) literal -> . FLOATCONSTANT
    (92) literal -> . STRINGCONSTANT
    (93) literal -> . NULL
    (94) literal -> . TRUE
    (95) literal -> . FALSE
    (111) method_invocation -> . field_access LPAREN RPAREN
    (112) method_invocation -> . field_access LPAREN arguments RPAREN

    IDENTIFIER      shift and go to state 125
    THIS            shift and go to state 105
    SUPER           shift and go to state 108
    LPAREN          shift and go to state 96
    NEW             shift and go to state 80
    INTEGERCONSTANT shift and go to state 102
    FLOATCONSTANT   shift and go to state 100
    STRINGCONSTANT  shift and go to state 83
    NULL            shift and go to state 81
    TRUE            shift and go to state 85
    FALSE           shift and go to state 97

    field_access                   shift and go to state 126
    primary                        shift and go to state 78
    literal                        shift and go to state 87
    lhs                            shift and go to state 139
    method_invocation              shift and go to state 124
    array_access                   shift and go to state 82

state 95

    (38) stmthelper -> stmt .

    RCURLY          reduce using rule 38 (stmthelper -> stmt .)
    IF              reduce using rule 38 (stmthelper -> stmt .)
    WHILE           reduce using rule 38 (stmthelper -> stmt .)
    FOR             reduce using rule 38 (stmthelper -> stmt .)
    RETURN          reduce using rule 38 (stmthelper -> stmt .)
    BREAK           reduce using rule 38 (stmthelper -> stmt .)
    CONTINUE        reduce using rule 38 (stmthelper -> stmt .)
    SEMICOLON       reduce using rule 38 (stmthelper -> stmt .)
    LCURLY          reduce using rule 38 (stmthelper -> stmt .)
    INT             reduce using rule 38 (stmthelper -> stmt .)
    FLOAT           reduce using rule 38 (stmthelper -> stmt .)
    BOOLEAN         reduce using rule 38 (stmthelper -> stmt .)
    IDENTIFIER      reduce using rule 38 (stmthelper -> stmt .)
    PLUSPLUS        reduce using rule 38 (stmthelper -> stmt .)
    MINUSMINUS      reduce using rule 38 (stmthelper -> stmt .)
    THIS            reduce using rule 38 (stmthelper -> stmt .)
    SUPER           reduce using rule 38 (stmthelper -> stmt .)
    LPAREN          reduce using rule 38 (stmthelper -> stmt .)
    NEW             reduce using rule 38 (stmthelper -> stmt .)
    INTEGERCONSTANT reduce using rule 38 (stmthelper -> stmt .)
    FLOATCONSTANT   reduce using rule 38 (stmthelper -> stmt .)
    STRINGCONSTANT  reduce using rule 38 (stmthelper -> stmt .)
    NULL            reduce using rule 38 (stmthelper -> stmt .)
    TRUE            reduce using rule 38 (stmthelper -> stmt .)
    FALSE           reduce using rule 38 (stmthelper -> stmt .)


state 96

    (99) primary -> LPAREN . expr RPAREN
    (59) expr -> . primary
    (60) expr -> . assign
    (61) expr -> . new_array
    (62) expr -> . expr OR expr
    (63) expr -> . expr AND expr
    (64) expr -> . expr EQUALS expr
    (65) expr -> . expr NOTEQUALS expr
    (66) expr -> . expr LT expr
    (67) expr -> . expr GT expr
    (68) expr -> . expr LEQ expr
    (69) expr -> . expr GEQ expr
    (70) expr -> . expr PLUS expr
    (71) expr -> . expr MINUS expr
    (72) expr -> . expr MULT expr
    (73) expr -> . expr DIV expr
    (74) expr -> . NOT expr
    (75) expr -> . MINUS expr
    (76) expr -> . PLUS expr
    (96) primary -> . literal
    (97) primary -> . THIS
    (98) primary -> . SUPER
    (99) primary -> . LPAREN expr RPAREN
    (100) primary -> . NEW IDENTIFIER LPAREN RPAREN
    (101) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (102) primary -> . lhs
    (103) primary -> . method_invocation
    (77) assign -> . lhs ASSIGN expr
    (78) assign -> . lhs PLUSPLUS
    (79) assign -> . PLUSPLUS lhs
    (80) assign -> . lhs MINUSMINUS
    (81) assign -> . MINUSMINUS lhs
    (82) new_array -> . NEW type expr_array_helper
    (90) literal -> . INTEGERCONSTANT
    (91) literal -> . FLOATCONSTANT
    (92) literal -> . STRINGCONSTANT
    (93) literal -> . NULL
    (94) literal -> . TRUE
    (95) literal -> . FALSE
    (106) lhs -> . field_access
    (107) lhs -> . array_access
    (111) method_invocation -> . field_access LPAREN RPAREN
    (112) method_invocation -> . field_access LPAREN arguments RPAREN
    (108) field_access -> . primary DOT IDENTIFIER
    (109) field_access -> . IDENTIFIER
    (110) array_access -> . primary LSQUARE expr RSQUARE

    NOT             shift and go to state 130
    MINUS           shift and go to state 121
    PLUS            shift and go to state 123
    THIS            shift and go to state 105
    SUPER           shift and go to state 108
    LPAREN          shift and go to state 96
    NEW             shift and go to state 120
    PLUSPLUS        shift and go to state 94
    MINUSMINUS      shift and go to state 98
    INTEGERCONSTANT shift and go to state 102
    FLOATCONSTANT   shift and go to state 100
    STRINGCONSTANT  shift and go to state 83
    NULL            shift and go to state 81
    TRUE            shift and go to state 85
    FALSE           shift and go to state 97
    IDENTIFIER      shift and go to state 125

    new_array                      shift and go to state 118
    field_access                   shift and go to state 126
    expr                           shift and go to state 140
    primary                        shift and go to state 119
    array_access                   shift and go to state 82
    literal                        shift and go to state 87
    lhs                            shift and go to state 129
    method_invocation              shift and go to state 124
    assign                         shift and go to state 128

state 97

    (95) literal -> FALSE .

    DOT             reduce using rule 95 (literal -> FALSE .)
    LSQUARE         reduce using rule 95 (literal -> FALSE .)
    OR              reduce using rule 95 (literal -> FALSE .)
    AND             reduce using rule 95 (literal -> FALSE .)
    EQUALS          reduce using rule 95 (literal -> FALSE .)
    NOTEQUALS       reduce using rule 95 (literal -> FALSE .)
    LT              reduce using rule 95 (literal -> FALSE .)
    GT              reduce using rule 95 (literal -> FALSE .)
    LEQ             reduce using rule 95 (literal -> FALSE .)
    GEQ             reduce using rule 95 (literal -> FALSE .)
    PLUS            reduce using rule 95 (literal -> FALSE .)
    MINUS           reduce using rule 95 (literal -> FALSE .)
    MULT            reduce using rule 95 (literal -> FALSE .)
    DIV             reduce using rule 95 (literal -> FALSE .)
    SEMICOLON       reduce using rule 95 (literal -> FALSE .)
    RPAREN          reduce using rule 95 (literal -> FALSE .)
    RSQUARE         reduce using rule 95 (literal -> FALSE .)
    COMMA           reduce using rule 95 (literal -> FALSE .)


state 98

    (81) assign -> MINUSMINUS . lhs
    (106) lhs -> . field_access
    (107) lhs -> . array_access
    (108) field_access -> . primary DOT IDENTIFIER
    (109) field_access -> . IDENTIFIER
    (110) array_access -> . primary LSQUARE expr RSQUARE
    (96) primary -> . literal
    (97) primary -> . THIS
    (98) primary -> . SUPER
    (99) primary -> . LPAREN expr RPAREN
    (100) primary -> . NEW IDENTIFIER LPAREN RPAREN
    (101) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (102) primary -> . lhs
    (103) primary -> . method_invocation
    (90) literal -> . INTEGERCONSTANT
    (91) literal -> . FLOATCONSTANT
    (92) literal -> . STRINGCONSTANT
    (93) literal -> . NULL
    (94) literal -> . TRUE
    (95) literal -> . FALSE
    (111) method_invocation -> . field_access LPAREN RPAREN
    (112) method_invocation -> . field_access LPAREN arguments RPAREN

    IDENTIFIER      shift and go to state 125
    THIS            shift and go to state 105
    SUPER           shift and go to state 108
    LPAREN          shift and go to state 96
    NEW             shift and go to state 80
    INTEGERCONSTANT shift and go to state 102
    FLOATCONSTANT   shift and go to state 100
    STRINGCONSTANT  shift and go to state 83
    NULL            shift and go to state 81
    TRUE            shift and go to state 85
    FALSE           shift and go to state 97

    field_access                   shift and go to state 126
    primary                        shift and go to state 78
    literal                        shift and go to state 87
    lhs                            shift and go to state 141
    method_invocation              shift and go to state 124
    array_access                   shift and go to state 82

state 99

    (40) stmt -> IF . LPAREN expr RPAREN stmt ELSE stmt
    (41) stmt -> IF . LPAREN expr RPAREN stmt

    LPAREN          shift and go to state 142


state 100

    (91) literal -> FLOATCONSTANT .

    DOT             reduce using rule 91 (literal -> FLOATCONSTANT .)
    LSQUARE         reduce using rule 91 (literal -> FLOATCONSTANT .)
    OR              reduce using rule 91 (literal -> FLOATCONSTANT .)
    AND             reduce using rule 91 (literal -> FLOATCONSTANT .)
    EQUALS          reduce using rule 91 (literal -> FLOATCONSTANT .)
    NOTEQUALS       reduce using rule 91 (literal -> FLOATCONSTANT .)
    LT              reduce using rule 91 (literal -> FLOATCONSTANT .)
    GT              reduce using rule 91 (literal -> FLOATCONSTANT .)
    LEQ             reduce using rule 91 (literal -> FLOATCONSTANT .)
    GEQ             reduce using rule 91 (literal -> FLOATCONSTANT .)
    PLUS            reduce using rule 91 (literal -> FLOATCONSTANT .)
    MINUS           reduce using rule 91 (literal -> FLOATCONSTANT .)
    MULT            reduce using rule 91 (literal -> FLOATCONSTANT .)
    DIV             reduce using rule 91 (literal -> FLOATCONSTANT .)
    SEMICOLON       reduce using rule 91 (literal -> FLOATCONSTANT .)
    RPAREN          reduce using rule 91 (literal -> FLOATCONSTANT .)
    RSQUARE         reduce using rule 91 (literal -> FLOATCONSTANT .)
    COMMA           reduce using rule 91 (literal -> FLOATCONSTANT .)


state 101

    (37) block -> LCURLY stmthelper . RCURLY
    (39) stmthelper -> stmthelper . stmt
    (40) stmt -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (41) stmt -> . IF LPAREN expr RPAREN stmt
    (42) stmt -> . WHILE LPAREN expr RPAREN stmt
    (43) stmt -> . FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt
    (44) stmt -> . FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt
    (45) stmt -> . FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt
    (46) stmt -> . FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt
    (47) stmt -> . FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (48) stmt -> . FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt
    (49) stmt -> . FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (50) stmt -> . FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt
    (51) stmt -> . block
    (52) stmt -> . var_decl
    (53) stmt -> . stmt_expr SEMICOLON
    (54) stmt -> . RETURN expr SEMICOLON
    (55) stmt -> . RETURN SEMICOLON
    (56) stmt -> . BREAK SEMICOLON
    (57) stmt -> . CONTINUE SEMICOLON
    (58) stmt -> . SEMICOLON
    (36) block -> . LCURLY empty RCURLY
    (37) block -> . LCURLY stmthelper RCURLY
    (19) var_decl -> . type variables SEMICOLON
    (88) stmt_expr -> . assign
    (89) stmt_expr -> . method_invocation
    (20) type -> . INT
    (21) type -> . FLOAT
    (22) type -> . BOOLEAN
    (23) type -> . IDENTIFIER
    (77) assign -> . lhs ASSIGN expr
    (78) assign -> . lhs PLUSPLUS
    (79) assign -> . PLUSPLUS lhs
    (80) assign -> . lhs MINUSMINUS
    (81) assign -> . MINUSMINUS lhs
    (111) method_invocation -> . field_access LPAREN RPAREN
    (112) method_invocation -> . field_access LPAREN arguments RPAREN
    (106) lhs -> . field_access
    (107) lhs -> . array_access
    (108) field_access -> . primary DOT IDENTIFIER
    (109) field_access -> . IDENTIFIER
    (110) array_access -> . primary LSQUARE expr RSQUARE
    (96) primary -> . literal
    (97) primary -> . THIS
    (98) primary -> . SUPER
    (99) primary -> . LPAREN expr RPAREN
    (100) primary -> . NEW IDENTIFIER LPAREN RPAREN
    (101) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (102) primary -> . lhs
    (103) primary -> . method_invocation
    (90) literal -> . INTEGERCONSTANT
    (91) literal -> . FLOATCONSTANT
    (92) literal -> . STRINGCONSTANT
    (93) literal -> . NULL
    (94) literal -> . TRUE
    (95) literal -> . FALSE

    RCURLY          shift and go to state 143
    IF              shift and go to state 99
    WHILE           shift and go to state 79
    FOR             shift and go to state 93
    RETURN          shift and go to state 77
    BREAK           shift and go to state 104
    CONTINUE        shift and go to state 106
    SEMICOLON       shift and go to state 84
    LCURLY          shift and go to state 63
    INT             shift and go to state 16
    FLOAT           shift and go to state 18
    BOOLEAN         shift and go to state 20
    IDENTIFIER      shift and go to state 89
    PLUSPLUS        shift and go to state 94
    MINUSMINUS      shift and go to state 98
    THIS            shift and go to state 105
    SUPER           shift and go to state 108
    LPAREN          shift and go to state 96
    NEW             shift and go to state 80
    INTEGERCONSTANT shift and go to state 102
    FLOATCONSTANT   shift and go to state 100
    STRINGCONSTANT  shift and go to state 83
    NULL            shift and go to state 81
    TRUE            shift and go to state 85
    FALSE           shift and go to state 97

    field_access                   shift and go to state 92
    array_access                   shift and go to state 82
    primary                        shift and go to state 78
    var_decl                       shift and go to state 103
    stmt_expr                      shift and go to state 86
    literal                        shift and go to state 87
    lhs                            shift and go to state 107
    stmt                           shift and go to state 144
    method_invocation              shift and go to state 88
    type                           shift and go to state 90
    assign                         shift and go to state 109
    block                          shift and go to state 110

state 102

    (90) literal -> INTEGERCONSTANT .

    DOT             reduce using rule 90 (literal -> INTEGERCONSTANT .)
    LSQUARE         reduce using rule 90 (literal -> INTEGERCONSTANT .)
    OR              reduce using rule 90 (literal -> INTEGERCONSTANT .)
    AND             reduce using rule 90 (literal -> INTEGERCONSTANT .)
    EQUALS          reduce using rule 90 (literal -> INTEGERCONSTANT .)
    NOTEQUALS       reduce using rule 90 (literal -> INTEGERCONSTANT .)
    LT              reduce using rule 90 (literal -> INTEGERCONSTANT .)
    GT              reduce using rule 90 (literal -> INTEGERCONSTANT .)
    LEQ             reduce using rule 90 (literal -> INTEGERCONSTANT .)
    GEQ             reduce using rule 90 (literal -> INTEGERCONSTANT .)
    PLUS            reduce using rule 90 (literal -> INTEGERCONSTANT .)
    MINUS           reduce using rule 90 (literal -> INTEGERCONSTANT .)
    MULT            reduce using rule 90 (literal -> INTEGERCONSTANT .)
    DIV             reduce using rule 90 (literal -> INTEGERCONSTANT .)
    SEMICOLON       reduce using rule 90 (literal -> INTEGERCONSTANT .)
    RPAREN          reduce using rule 90 (literal -> INTEGERCONSTANT .)
    RSQUARE         reduce using rule 90 (literal -> INTEGERCONSTANT .)
    COMMA           reduce using rule 90 (literal -> INTEGERCONSTANT .)


state 103

    (52) stmt -> var_decl .

    RCURLY          reduce using rule 52 (stmt -> var_decl .)
    IF              reduce using rule 52 (stmt -> var_decl .)
    WHILE           reduce using rule 52 (stmt -> var_decl .)
    FOR             reduce using rule 52 (stmt -> var_decl .)
    RETURN          reduce using rule 52 (stmt -> var_decl .)
    BREAK           reduce using rule 52 (stmt -> var_decl .)
    CONTINUE        reduce using rule 52 (stmt -> var_decl .)
    SEMICOLON       reduce using rule 52 (stmt -> var_decl .)
    LCURLY          reduce using rule 52 (stmt -> var_decl .)
    INT             reduce using rule 52 (stmt -> var_decl .)
    FLOAT           reduce using rule 52 (stmt -> var_decl .)
    BOOLEAN         reduce using rule 52 (stmt -> var_decl .)
    IDENTIFIER      reduce using rule 52 (stmt -> var_decl .)
    PLUSPLUS        reduce using rule 52 (stmt -> var_decl .)
    MINUSMINUS      reduce using rule 52 (stmt -> var_decl .)
    THIS            reduce using rule 52 (stmt -> var_decl .)
    SUPER           reduce using rule 52 (stmt -> var_decl .)
    LPAREN          reduce using rule 52 (stmt -> var_decl .)
    NEW             reduce using rule 52 (stmt -> var_decl .)
    INTEGERCONSTANT reduce using rule 52 (stmt -> var_decl .)
    FLOATCONSTANT   reduce using rule 52 (stmt -> var_decl .)
    STRINGCONSTANT  reduce using rule 52 (stmt -> var_decl .)
    NULL            reduce using rule 52 (stmt -> var_decl .)
    TRUE            reduce using rule 52 (stmt -> var_decl .)
    FALSE           reduce using rule 52 (stmt -> var_decl .)
    ELSE            reduce using rule 52 (stmt -> var_decl .)


state 104

    (56) stmt -> BREAK . SEMICOLON

    SEMICOLON       shift and go to state 145


state 105

    (97) primary -> THIS .

    DOT             reduce using rule 97 (primary -> THIS .)
    LSQUARE         reduce using rule 97 (primary -> THIS .)
    OR              reduce using rule 97 (primary -> THIS .)
    AND             reduce using rule 97 (primary -> THIS .)
    EQUALS          reduce using rule 97 (primary -> THIS .)
    NOTEQUALS       reduce using rule 97 (primary -> THIS .)
    LT              reduce using rule 97 (primary -> THIS .)
    GT              reduce using rule 97 (primary -> THIS .)
    LEQ             reduce using rule 97 (primary -> THIS .)
    GEQ             reduce using rule 97 (primary -> THIS .)
    PLUS            reduce using rule 97 (primary -> THIS .)
    MINUS           reduce using rule 97 (primary -> THIS .)
    MULT            reduce using rule 97 (primary -> THIS .)
    DIV             reduce using rule 97 (primary -> THIS .)
    SEMICOLON       reduce using rule 97 (primary -> THIS .)
    RPAREN          reduce using rule 97 (primary -> THIS .)
    RSQUARE         reduce using rule 97 (primary -> THIS .)
    COMMA           reduce using rule 97 (primary -> THIS .)


state 106

    (57) stmt -> CONTINUE . SEMICOLON

    SEMICOLON       shift and go to state 146


state 107

    (77) assign -> lhs . ASSIGN expr
    (78) assign -> lhs . PLUSPLUS
    (80) assign -> lhs . MINUSMINUS
    (102) primary -> lhs .

    ASSIGN          shift and go to state 149
    PLUSPLUS        shift and go to state 147
    MINUSMINUS      shift and go to state 148
    DOT             reduce using rule 102 (primary -> lhs .)
    LSQUARE         reduce using rule 102 (primary -> lhs .)


state 108

    (98) primary -> SUPER .

    DOT             reduce using rule 98 (primary -> SUPER .)
    LSQUARE         reduce using rule 98 (primary -> SUPER .)
    OR              reduce using rule 98 (primary -> SUPER .)
    AND             reduce using rule 98 (primary -> SUPER .)
    EQUALS          reduce using rule 98 (primary -> SUPER .)
    NOTEQUALS       reduce using rule 98 (primary -> SUPER .)
    LT              reduce using rule 98 (primary -> SUPER .)
    GT              reduce using rule 98 (primary -> SUPER .)
    LEQ             reduce using rule 98 (primary -> SUPER .)
    GEQ             reduce using rule 98 (primary -> SUPER .)
    PLUS            reduce using rule 98 (primary -> SUPER .)
    MINUS           reduce using rule 98 (primary -> SUPER .)
    MULT            reduce using rule 98 (primary -> SUPER .)
    DIV             reduce using rule 98 (primary -> SUPER .)
    SEMICOLON       reduce using rule 98 (primary -> SUPER .)
    RPAREN          reduce using rule 98 (primary -> SUPER .)
    RSQUARE         reduce using rule 98 (primary -> SUPER .)
    COMMA           reduce using rule 98 (primary -> SUPER .)


state 109

    (88) stmt_expr -> assign .

    SEMICOLON       reduce using rule 88 (stmt_expr -> assign .)
    RPAREN          reduce using rule 88 (stmt_expr -> assign .)


state 110

    (51) stmt -> block .

    RCURLY          reduce using rule 51 (stmt -> block .)
    IF              reduce using rule 51 (stmt -> block .)
    WHILE           reduce using rule 51 (stmt -> block .)
    FOR             reduce using rule 51 (stmt -> block .)
    RETURN          reduce using rule 51 (stmt -> block .)
    BREAK           reduce using rule 51 (stmt -> block .)
    CONTINUE        reduce using rule 51 (stmt -> block .)
    SEMICOLON       reduce using rule 51 (stmt -> block .)
    LCURLY          reduce using rule 51 (stmt -> block .)
    INT             reduce using rule 51 (stmt -> block .)
    FLOAT           reduce using rule 51 (stmt -> block .)
    BOOLEAN         reduce using rule 51 (stmt -> block .)
    IDENTIFIER      reduce using rule 51 (stmt -> block .)
    PLUSPLUS        reduce using rule 51 (stmt -> block .)
    MINUSMINUS      reduce using rule 51 (stmt -> block .)
    THIS            reduce using rule 51 (stmt -> block .)
    SUPER           reduce using rule 51 (stmt -> block .)
    LPAREN          reduce using rule 51 (stmt -> block .)
    NEW             reduce using rule 51 (stmt -> block .)
    INTEGERCONSTANT reduce using rule 51 (stmt -> block .)
    FLOATCONSTANT   reduce using rule 51 (stmt -> block .)
    STRINGCONSTANT  reduce using rule 51 (stmt -> block .)
    NULL            reduce using rule 51 (stmt -> block .)
    TRUE            reduce using rule 51 (stmt -> block .)
    FALSE           reduce using rule 51 (stmt -> block .)
    ELSE            reduce using rule 51 (stmt -> block .)


state 111

    (35) formals -> type variables COMMA . formals
    (25) variables -> variables COMMA . IDENTIFIER brackets
    (34) formals -> . type variables
    (35) formals -> . type variables COMMA formals
    (20) type -> . INT
    (21) type -> . FLOAT
    (22) type -> . BOOLEAN
    (23) type -> . IDENTIFIER

    IDENTIFIER      shift and go to state 150
    INT             shift and go to state 16
    FLOAT           shift and go to state 18
    BOOLEAN         shift and go to state 20

    type                           shift and go to state 50
    formals                        shift and go to state 151

state 112

    (33) constructor_decl -> modifier IDENTIFIER LPAREN formals RPAREN block .

    PUBLIC          reduce using rule 33 (constructor_decl -> modifier IDENTIFIER LPAREN formals RPAREN block .)
    PRIVATE         reduce using rule 33 (constructor_decl -> modifier IDENTIFIER LPAREN formals RPAREN block .)
    STATIC          reduce using rule 33 (constructor_decl -> modifier IDENTIFIER LPAREN formals RPAREN block .)
    VOID            reduce using rule 33 (constructor_decl -> modifier IDENTIFIER LPAREN formals RPAREN block .)
    IDENTIFIER      reduce using rule 33 (constructor_decl -> modifier IDENTIFIER LPAREN formals RPAREN block .)
    INT             reduce using rule 33 (constructor_decl -> modifier IDENTIFIER LPAREN formals RPAREN block .)
    FLOAT           reduce using rule 33 (constructor_decl -> modifier IDENTIFIER LPAREN formals RPAREN block .)
    BOOLEAN         reduce using rule 33 (constructor_decl -> modifier IDENTIFIER LPAREN formals RPAREN block .)
    RCURLY          reduce using rule 33 (constructor_decl -> modifier IDENTIFIER LPAREN formals RPAREN block .)


state 113

    (25) variables -> variables COMMA IDENTIFIER brackets .

    COMMA           reduce using rule 25 (variables -> variables COMMA IDENTIFIER brackets .)
    RPAREN          reduce using rule 25 (variables -> variables COMMA IDENTIFIER brackets .)
    SEMICOLON       reduce using rule 25 (variables -> variables COMMA IDENTIFIER brackets .)


state 114

    (26) brackets -> LSQUARE RSQUARE brackets .

    SEMICOLON       reduce using rule 26 (brackets -> LSQUARE RSQUARE brackets .)
    COMMA           reduce using rule 26 (brackets -> LSQUARE RSQUARE brackets .)
    RPAREN          reduce using rule 26 (brackets -> LSQUARE RSQUARE brackets .)


state 115

    (28) method_decl -> modifier type IDENTIFIER LPAREN RPAREN block .

    PUBLIC          reduce using rule 28 (method_decl -> modifier type IDENTIFIER LPAREN RPAREN block .)
    PRIVATE         reduce using rule 28 (method_decl -> modifier type IDENTIFIER LPAREN RPAREN block .)
    STATIC          reduce using rule 28 (method_decl -> modifier type IDENTIFIER LPAREN RPAREN block .)
    VOID            reduce using rule 28 (method_decl -> modifier type IDENTIFIER LPAREN RPAREN block .)
    IDENTIFIER      reduce using rule 28 (method_decl -> modifier type IDENTIFIER LPAREN RPAREN block .)
    INT             reduce using rule 28 (method_decl -> modifier type IDENTIFIER LPAREN RPAREN block .)
    FLOAT           reduce using rule 28 (method_decl -> modifier type IDENTIFIER LPAREN RPAREN block .)
    BOOLEAN         reduce using rule 28 (method_decl -> modifier type IDENTIFIER LPAREN RPAREN block .)
    RCURLY          reduce using rule 28 (method_decl -> modifier type IDENTIFIER LPAREN RPAREN block .)


state 116

    (31) method_decl -> modifier type IDENTIFIER LPAREN formals RPAREN . block
    (36) block -> . LCURLY empty RCURLY
    (37) block -> . LCURLY stmthelper RCURLY

    LCURLY          shift and go to state 63

    block                          shift and go to state 152

state 117

    (30) method_decl -> modifier VOID IDENTIFIER LPAREN formals RPAREN block .

    PUBLIC          reduce using rule 30 (method_decl -> modifier VOID IDENTIFIER LPAREN formals RPAREN block .)
    PRIVATE         reduce using rule 30 (method_decl -> modifier VOID IDENTIFIER LPAREN formals RPAREN block .)
    STATIC          reduce using rule 30 (method_decl -> modifier VOID IDENTIFIER LPAREN formals RPAREN block .)
    VOID            reduce using rule 30 (method_decl -> modifier VOID IDENTIFIER LPAREN formals RPAREN block .)
    IDENTIFIER      reduce using rule 30 (method_decl -> modifier VOID IDENTIFIER LPAREN formals RPAREN block .)
    INT             reduce using rule 30 (method_decl -> modifier VOID IDENTIFIER LPAREN formals RPAREN block .)
    FLOAT           reduce using rule 30 (method_decl -> modifier VOID IDENTIFIER LPAREN formals RPAREN block .)
    BOOLEAN         reduce using rule 30 (method_decl -> modifier VOID IDENTIFIER LPAREN formals RPAREN block .)
    RCURLY          reduce using rule 30 (method_decl -> modifier VOID IDENTIFIER LPAREN formals RPAREN block .)


state 118

    (61) expr -> new_array .

    OR              reduce using rule 61 (expr -> new_array .)
    AND             reduce using rule 61 (expr -> new_array .)
    EQUALS          reduce using rule 61 (expr -> new_array .)
    NOTEQUALS       reduce using rule 61 (expr -> new_array .)
    LT              reduce using rule 61 (expr -> new_array .)
    GT              reduce using rule 61 (expr -> new_array .)
    LEQ             reduce using rule 61 (expr -> new_array .)
    GEQ             reduce using rule 61 (expr -> new_array .)
    PLUS            reduce using rule 61 (expr -> new_array .)
    MINUS           reduce using rule 61 (expr -> new_array .)
    MULT            reduce using rule 61 (expr -> new_array .)
    DIV             reduce using rule 61 (expr -> new_array .)
    RPAREN          reduce using rule 61 (expr -> new_array .)
    COMMA           reduce using rule 61 (expr -> new_array .)
    SEMICOLON       reduce using rule 61 (expr -> new_array .)
    RSQUARE         reduce using rule 61 (expr -> new_array .)


state 119

    (59) expr -> primary .
    (108) field_access -> primary . DOT IDENTIFIER
    (110) array_access -> primary . LSQUARE expr RSQUARE

    OR              reduce using rule 59 (expr -> primary .)
    AND             reduce using rule 59 (expr -> primary .)
    EQUALS          reduce using rule 59 (expr -> primary .)
    NOTEQUALS       reduce using rule 59 (expr -> primary .)
    LT              reduce using rule 59 (expr -> primary .)
    GT              reduce using rule 59 (expr -> primary .)
    LEQ             reduce using rule 59 (expr -> primary .)
    GEQ             reduce using rule 59 (expr -> primary .)
    PLUS            reduce using rule 59 (expr -> primary .)
    MINUS           reduce using rule 59 (expr -> primary .)
    MULT            reduce using rule 59 (expr -> primary .)
    DIV             reduce using rule 59 (expr -> primary .)
    RPAREN          reduce using rule 59 (expr -> primary .)
    COMMA           reduce using rule 59 (expr -> primary .)
    SEMICOLON       reduce using rule 59 (expr -> primary .)
    RSQUARE         reduce using rule 59 (expr -> primary .)
    DOT             shift and go to state 132
    LSQUARE         shift and go to state 131


state 120

    (100) primary -> NEW . IDENTIFIER LPAREN RPAREN
    (101) primary -> NEW . IDENTIFIER LPAREN arguments RPAREN
    (82) new_array -> NEW . type expr_array_helper
    (20) type -> . INT
    (21) type -> . FLOAT
    (22) type -> . BOOLEAN
    (23) type -> . IDENTIFIER

    IDENTIFIER      shift and go to state 153
    INT             shift and go to state 16
    FLOAT           shift and go to state 18
    BOOLEAN         shift and go to state 20

    type                           shift and go to state 154

state 121

    (75) expr -> MINUS . expr
    (59) expr -> . primary
    (60) expr -> . assign
    (61) expr -> . new_array
    (62) expr -> . expr OR expr
    (63) expr -> . expr AND expr
    (64) expr -> . expr EQUALS expr
    (65) expr -> . expr NOTEQUALS expr
    (66) expr -> . expr LT expr
    (67) expr -> . expr GT expr
    (68) expr -> . expr LEQ expr
    (69) expr -> . expr GEQ expr
    (70) expr -> . expr PLUS expr
    (71) expr -> . expr MINUS expr
    (72) expr -> . expr MULT expr
    (73) expr -> . expr DIV expr
    (74) expr -> . NOT expr
    (75) expr -> . MINUS expr
    (76) expr -> . PLUS expr
    (96) primary -> . literal
    (97) primary -> . THIS
    (98) primary -> . SUPER
    (99) primary -> . LPAREN expr RPAREN
    (100) primary -> . NEW IDENTIFIER LPAREN RPAREN
    (101) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (102) primary -> . lhs
    (103) primary -> . method_invocation
    (77) assign -> . lhs ASSIGN expr
    (78) assign -> . lhs PLUSPLUS
    (79) assign -> . PLUSPLUS lhs
    (80) assign -> . lhs MINUSMINUS
    (81) assign -> . MINUSMINUS lhs
    (82) new_array -> . NEW type expr_array_helper
    (90) literal -> . INTEGERCONSTANT
    (91) literal -> . FLOATCONSTANT
    (92) literal -> . STRINGCONSTANT
    (93) literal -> . NULL
    (94) literal -> . TRUE
    (95) literal -> . FALSE
    (106) lhs -> . field_access
    (107) lhs -> . array_access
    (111) method_invocation -> . field_access LPAREN RPAREN
    (112) method_invocation -> . field_access LPAREN arguments RPAREN
    (108) field_access -> . primary DOT IDENTIFIER
    (109) field_access -> . IDENTIFIER
    (110) array_access -> . primary LSQUARE expr RSQUARE

    NOT             shift and go to state 130
    MINUS           shift and go to state 121
    PLUS            shift and go to state 123
    THIS            shift and go to state 105
    SUPER           shift and go to state 108
    LPAREN          shift and go to state 96
    NEW             shift and go to state 120
    PLUSPLUS        shift and go to state 94
    MINUSMINUS      shift and go to state 98
    INTEGERCONSTANT shift and go to state 102
    FLOATCONSTANT   shift and go to state 100
    STRINGCONSTANT  shift and go to state 83
    NULL            shift and go to state 81
    TRUE            shift and go to state 85
    FALSE           shift and go to state 97
    IDENTIFIER      shift and go to state 125

    new_array                      shift and go to state 118
    field_access                   shift and go to state 126
    expr                           shift and go to state 155
    primary                        shift and go to state 119
    array_access                   shift and go to state 82
    literal                        shift and go to state 87
    lhs                            shift and go to state 129
    method_invocation              shift and go to state 124
    assign                         shift and go to state 128

state 122

    (55) stmt -> RETURN SEMICOLON .

    RCURLY          reduce using rule 55 (stmt -> RETURN SEMICOLON .)
    IF              reduce using rule 55 (stmt -> RETURN SEMICOLON .)
    WHILE           reduce using rule 55 (stmt -> RETURN SEMICOLON .)
    FOR             reduce using rule 55 (stmt -> RETURN SEMICOLON .)
    RETURN          reduce using rule 55 (stmt -> RETURN SEMICOLON .)
    BREAK           reduce using rule 55 (stmt -> RETURN SEMICOLON .)
    CONTINUE        reduce using rule 55 (stmt -> RETURN SEMICOLON .)
    SEMICOLON       reduce using rule 55 (stmt -> RETURN SEMICOLON .)
    LCURLY          reduce using rule 55 (stmt -> RETURN SEMICOLON .)
    INT             reduce using rule 55 (stmt -> RETURN SEMICOLON .)
    FLOAT           reduce using rule 55 (stmt -> RETURN SEMICOLON .)
    BOOLEAN         reduce using rule 55 (stmt -> RETURN SEMICOLON .)
    IDENTIFIER      reduce using rule 55 (stmt -> RETURN SEMICOLON .)
    PLUSPLUS        reduce using rule 55 (stmt -> RETURN SEMICOLON .)
    MINUSMINUS      reduce using rule 55 (stmt -> RETURN SEMICOLON .)
    THIS            reduce using rule 55 (stmt -> RETURN SEMICOLON .)
    SUPER           reduce using rule 55 (stmt -> RETURN SEMICOLON .)
    LPAREN          reduce using rule 55 (stmt -> RETURN SEMICOLON .)
    NEW             reduce using rule 55 (stmt -> RETURN SEMICOLON .)
    INTEGERCONSTANT reduce using rule 55 (stmt -> RETURN SEMICOLON .)
    FLOATCONSTANT   reduce using rule 55 (stmt -> RETURN SEMICOLON .)
    STRINGCONSTANT  reduce using rule 55 (stmt -> RETURN SEMICOLON .)
    NULL            reduce using rule 55 (stmt -> RETURN SEMICOLON .)
    TRUE            reduce using rule 55 (stmt -> RETURN SEMICOLON .)
    FALSE           reduce using rule 55 (stmt -> RETURN SEMICOLON .)
    ELSE            reduce using rule 55 (stmt -> RETURN SEMICOLON .)


state 123

    (76) expr -> PLUS . expr
    (59) expr -> . primary
    (60) expr -> . assign
    (61) expr -> . new_array
    (62) expr -> . expr OR expr
    (63) expr -> . expr AND expr
    (64) expr -> . expr EQUALS expr
    (65) expr -> . expr NOTEQUALS expr
    (66) expr -> . expr LT expr
    (67) expr -> . expr GT expr
    (68) expr -> . expr LEQ expr
    (69) expr -> . expr GEQ expr
    (70) expr -> . expr PLUS expr
    (71) expr -> . expr MINUS expr
    (72) expr -> . expr MULT expr
    (73) expr -> . expr DIV expr
    (74) expr -> . NOT expr
    (75) expr -> . MINUS expr
    (76) expr -> . PLUS expr
    (96) primary -> . literal
    (97) primary -> . THIS
    (98) primary -> . SUPER
    (99) primary -> . LPAREN expr RPAREN
    (100) primary -> . NEW IDENTIFIER LPAREN RPAREN
    (101) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (102) primary -> . lhs
    (103) primary -> . method_invocation
    (77) assign -> . lhs ASSIGN expr
    (78) assign -> . lhs PLUSPLUS
    (79) assign -> . PLUSPLUS lhs
    (80) assign -> . lhs MINUSMINUS
    (81) assign -> . MINUSMINUS lhs
    (82) new_array -> . NEW type expr_array_helper
    (90) literal -> . INTEGERCONSTANT
    (91) literal -> . FLOATCONSTANT
    (92) literal -> . STRINGCONSTANT
    (93) literal -> . NULL
    (94) literal -> . TRUE
    (95) literal -> . FALSE
    (106) lhs -> . field_access
    (107) lhs -> . array_access
    (111) method_invocation -> . field_access LPAREN RPAREN
    (112) method_invocation -> . field_access LPAREN arguments RPAREN
    (108) field_access -> . primary DOT IDENTIFIER
    (109) field_access -> . IDENTIFIER
    (110) array_access -> . primary LSQUARE expr RSQUARE

    NOT             shift and go to state 130
    MINUS           shift and go to state 121
    PLUS            shift and go to state 123
    THIS            shift and go to state 105
    SUPER           shift and go to state 108
    LPAREN          shift and go to state 96
    NEW             shift and go to state 120
    PLUSPLUS        shift and go to state 94
    MINUSMINUS      shift and go to state 98
    INTEGERCONSTANT shift and go to state 102
    FLOATCONSTANT   shift and go to state 100
    STRINGCONSTANT  shift and go to state 83
    NULL            shift and go to state 81
    TRUE            shift and go to state 85
    FALSE           shift and go to state 97
    IDENTIFIER      shift and go to state 125

    new_array                      shift and go to state 118
    field_access                   shift and go to state 126
    expr                           shift and go to state 156
    primary                        shift and go to state 119
    array_access                   shift and go to state 82
    literal                        shift and go to state 87
    lhs                            shift and go to state 129
    method_invocation              shift and go to state 124
    assign                         shift and go to state 128

state 124

    (103) primary -> method_invocation .

    DOT             reduce using rule 103 (primary -> method_invocation .)
    LSQUARE         reduce using rule 103 (primary -> method_invocation .)
    OR              reduce using rule 103 (primary -> method_invocation .)
    AND             reduce using rule 103 (primary -> method_invocation .)
    EQUALS          reduce using rule 103 (primary -> method_invocation .)
    NOTEQUALS       reduce using rule 103 (primary -> method_invocation .)
    LT              reduce using rule 103 (primary -> method_invocation .)
    GT              reduce using rule 103 (primary -> method_invocation .)
    LEQ             reduce using rule 103 (primary -> method_invocation .)
    GEQ             reduce using rule 103 (primary -> method_invocation .)
    PLUS            reduce using rule 103 (primary -> method_invocation .)
    MINUS           reduce using rule 103 (primary -> method_invocation .)
    MULT            reduce using rule 103 (primary -> method_invocation .)
    DIV             reduce using rule 103 (primary -> method_invocation .)
    SEMICOLON       reduce using rule 103 (primary -> method_invocation .)
    RPAREN          reduce using rule 103 (primary -> method_invocation .)
    RSQUARE         reduce using rule 103 (primary -> method_invocation .)
    COMMA           reduce using rule 103 (primary -> method_invocation .)


state 125

    (109) field_access -> IDENTIFIER .

    LPAREN          reduce using rule 109 (field_access -> IDENTIFIER .)
    ASSIGN          reduce using rule 109 (field_access -> IDENTIFIER .)
    PLUSPLUS        reduce using rule 109 (field_access -> IDENTIFIER .)
    MINUSMINUS      reduce using rule 109 (field_access -> IDENTIFIER .)
    DOT             reduce using rule 109 (field_access -> IDENTIFIER .)
    LSQUARE         reduce using rule 109 (field_access -> IDENTIFIER .)
    OR              reduce using rule 109 (field_access -> IDENTIFIER .)
    AND             reduce using rule 109 (field_access -> IDENTIFIER .)
    EQUALS          reduce using rule 109 (field_access -> IDENTIFIER .)
    NOTEQUALS       reduce using rule 109 (field_access -> IDENTIFIER .)
    LT              reduce using rule 109 (field_access -> IDENTIFIER .)
    GT              reduce using rule 109 (field_access -> IDENTIFIER .)
    LEQ             reduce using rule 109 (field_access -> IDENTIFIER .)
    GEQ             reduce using rule 109 (field_access -> IDENTIFIER .)
    PLUS            reduce using rule 109 (field_access -> IDENTIFIER .)
    MINUS           reduce using rule 109 (field_access -> IDENTIFIER .)
    MULT            reduce using rule 109 (field_access -> IDENTIFIER .)
    DIV             reduce using rule 109 (field_access -> IDENTIFIER .)
    SEMICOLON       reduce using rule 109 (field_access -> IDENTIFIER .)
    RPAREN          reduce using rule 109 (field_access -> IDENTIFIER .)
    RSQUARE         reduce using rule 109 (field_access -> IDENTIFIER .)
    COMMA           reduce using rule 109 (field_access -> IDENTIFIER .)


state 126

    (106) lhs -> field_access .
    (111) method_invocation -> field_access . LPAREN RPAREN
    (112) method_invocation -> field_access . LPAREN arguments RPAREN

    ASSIGN          reduce using rule 106 (lhs -> field_access .)
    PLUSPLUS        reduce using rule 106 (lhs -> field_access .)
    MINUSMINUS      reduce using rule 106 (lhs -> field_access .)
    DOT             reduce using rule 106 (lhs -> field_access .)
    LSQUARE         reduce using rule 106 (lhs -> field_access .)
    OR              reduce using rule 106 (lhs -> field_access .)
    AND             reduce using rule 106 (lhs -> field_access .)
    EQUALS          reduce using rule 106 (lhs -> field_access .)
    NOTEQUALS       reduce using rule 106 (lhs -> field_access .)
    LT              reduce using rule 106 (lhs -> field_access .)
    GT              reduce using rule 106 (lhs -> field_access .)
    LEQ             reduce using rule 106 (lhs -> field_access .)
    GEQ             reduce using rule 106 (lhs -> field_access .)
    PLUS            reduce using rule 106 (lhs -> field_access .)
    MINUS           reduce using rule 106 (lhs -> field_access .)
    MULT            reduce using rule 106 (lhs -> field_access .)
    DIV             reduce using rule 106 (lhs -> field_access .)
    SEMICOLON       reduce using rule 106 (lhs -> field_access .)
    RPAREN          reduce using rule 106 (lhs -> field_access .)
    RSQUARE         reduce using rule 106 (lhs -> field_access .)
    COMMA           reduce using rule 106 (lhs -> field_access .)
    LPAREN          shift and go to state 137


state 127

    (54) stmt -> RETURN expr . SEMICOLON
    (62) expr -> expr . OR expr
    (63) expr -> expr . AND expr
    (64) expr -> expr . EQUALS expr
    (65) expr -> expr . NOTEQUALS expr
    (66) expr -> expr . LT expr
    (67) expr -> expr . GT expr
    (68) expr -> expr . LEQ expr
    (69) expr -> expr . GEQ expr
    (70) expr -> expr . PLUS expr
    (71) expr -> expr . MINUS expr
    (72) expr -> expr . MULT expr
    (73) expr -> expr . DIV expr

    SEMICOLON       shift and go to state 161
    OR              shift and go to state 168
    AND             shift and go to state 157
    EQUALS          shift and go to state 162
    NOTEQUALS       shift and go to state 158
    LT              shift and go to state 165
    GT              shift and go to state 160
    LEQ             shift and go to state 164
    GEQ             shift and go to state 159
    PLUS            shift and go to state 166
    MINUS           shift and go to state 163
    MULT            shift and go to state 169
    DIV             shift and go to state 167


state 128

    (60) expr -> assign .

    OR              reduce using rule 60 (expr -> assign .)
    AND             reduce using rule 60 (expr -> assign .)
    EQUALS          reduce using rule 60 (expr -> assign .)
    NOTEQUALS       reduce using rule 60 (expr -> assign .)
    LT              reduce using rule 60 (expr -> assign .)
    GT              reduce using rule 60 (expr -> assign .)
    LEQ             reduce using rule 60 (expr -> assign .)
    GEQ             reduce using rule 60 (expr -> assign .)
    PLUS            reduce using rule 60 (expr -> assign .)
    MINUS           reduce using rule 60 (expr -> assign .)
    MULT            reduce using rule 60 (expr -> assign .)
    DIV             reduce using rule 60 (expr -> assign .)
    RPAREN          reduce using rule 60 (expr -> assign .)
    COMMA           reduce using rule 60 (expr -> assign .)
    SEMICOLON       reduce using rule 60 (expr -> assign .)
    RSQUARE         reduce using rule 60 (expr -> assign .)


state 129

    (102) primary -> lhs .
    (77) assign -> lhs . ASSIGN expr
    (78) assign -> lhs . PLUSPLUS
    (80) assign -> lhs . MINUSMINUS

    DOT             reduce using rule 102 (primary -> lhs .)
    LSQUARE         reduce using rule 102 (primary -> lhs .)
    OR              reduce using rule 102 (primary -> lhs .)
    AND             reduce using rule 102 (primary -> lhs .)
    EQUALS          reduce using rule 102 (primary -> lhs .)
    NOTEQUALS       reduce using rule 102 (primary -> lhs .)
    LT              reduce using rule 102 (primary -> lhs .)
    GT              reduce using rule 102 (primary -> lhs .)
    LEQ             reduce using rule 102 (primary -> lhs .)
    GEQ             reduce using rule 102 (primary -> lhs .)
    PLUS            reduce using rule 102 (primary -> lhs .)
    MINUS           reduce using rule 102 (primary -> lhs .)
    MULT            reduce using rule 102 (primary -> lhs .)
    DIV             reduce using rule 102 (primary -> lhs .)
    SEMICOLON       reduce using rule 102 (primary -> lhs .)
    RPAREN          reduce using rule 102 (primary -> lhs .)
    RSQUARE         reduce using rule 102 (primary -> lhs .)
    COMMA           reduce using rule 102 (primary -> lhs .)
    ASSIGN          shift and go to state 149
    PLUSPLUS        shift and go to state 147
    MINUSMINUS      shift and go to state 148


state 130

    (74) expr -> NOT . expr
    (59) expr -> . primary
    (60) expr -> . assign
    (61) expr -> . new_array
    (62) expr -> . expr OR expr
    (63) expr -> . expr AND expr
    (64) expr -> . expr EQUALS expr
    (65) expr -> . expr NOTEQUALS expr
    (66) expr -> . expr LT expr
    (67) expr -> . expr GT expr
    (68) expr -> . expr LEQ expr
    (69) expr -> . expr GEQ expr
    (70) expr -> . expr PLUS expr
    (71) expr -> . expr MINUS expr
    (72) expr -> . expr MULT expr
    (73) expr -> . expr DIV expr
    (74) expr -> . NOT expr
    (75) expr -> . MINUS expr
    (76) expr -> . PLUS expr
    (96) primary -> . literal
    (97) primary -> . THIS
    (98) primary -> . SUPER
    (99) primary -> . LPAREN expr RPAREN
    (100) primary -> . NEW IDENTIFIER LPAREN RPAREN
    (101) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (102) primary -> . lhs
    (103) primary -> . method_invocation
    (77) assign -> . lhs ASSIGN expr
    (78) assign -> . lhs PLUSPLUS
    (79) assign -> . PLUSPLUS lhs
    (80) assign -> . lhs MINUSMINUS
    (81) assign -> . MINUSMINUS lhs
    (82) new_array -> . NEW type expr_array_helper
    (90) literal -> . INTEGERCONSTANT
    (91) literal -> . FLOATCONSTANT
    (92) literal -> . STRINGCONSTANT
    (93) literal -> . NULL
    (94) literal -> . TRUE
    (95) literal -> . FALSE
    (106) lhs -> . field_access
    (107) lhs -> . array_access
    (111) method_invocation -> . field_access LPAREN RPAREN
    (112) method_invocation -> . field_access LPAREN arguments RPAREN
    (108) field_access -> . primary DOT IDENTIFIER
    (109) field_access -> . IDENTIFIER
    (110) array_access -> . primary LSQUARE expr RSQUARE

    NOT             shift and go to state 130
    MINUS           shift and go to state 121
    PLUS            shift and go to state 123
    THIS            shift and go to state 105
    SUPER           shift and go to state 108
    LPAREN          shift and go to state 96
    NEW             shift and go to state 120
    PLUSPLUS        shift and go to state 94
    MINUSMINUS      shift and go to state 98
    INTEGERCONSTANT shift and go to state 102
    FLOATCONSTANT   shift and go to state 100
    STRINGCONSTANT  shift and go to state 83
    NULL            shift and go to state 81
    TRUE            shift and go to state 85
    FALSE           shift and go to state 97
    IDENTIFIER      shift and go to state 125

    new_array                      shift and go to state 118
    field_access                   shift and go to state 126
    expr                           shift and go to state 170
    primary                        shift and go to state 119
    array_access                   shift and go to state 82
    literal                        shift and go to state 87
    lhs                            shift and go to state 129
    method_invocation              shift and go to state 124
    assign                         shift and go to state 128

state 131

    (110) array_access -> primary LSQUARE . expr RSQUARE
    (59) expr -> . primary
    (60) expr -> . assign
    (61) expr -> . new_array
    (62) expr -> . expr OR expr
    (63) expr -> . expr AND expr
    (64) expr -> . expr EQUALS expr
    (65) expr -> . expr NOTEQUALS expr
    (66) expr -> . expr LT expr
    (67) expr -> . expr GT expr
    (68) expr -> . expr LEQ expr
    (69) expr -> . expr GEQ expr
    (70) expr -> . expr PLUS expr
    (71) expr -> . expr MINUS expr
    (72) expr -> . expr MULT expr
    (73) expr -> . expr DIV expr
    (74) expr -> . NOT expr
    (75) expr -> . MINUS expr
    (76) expr -> . PLUS expr
    (96) primary -> . literal
    (97) primary -> . THIS
    (98) primary -> . SUPER
    (99) primary -> . LPAREN expr RPAREN
    (100) primary -> . NEW IDENTIFIER LPAREN RPAREN
    (101) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (102) primary -> . lhs
    (103) primary -> . method_invocation
    (77) assign -> . lhs ASSIGN expr
    (78) assign -> . lhs PLUSPLUS
    (79) assign -> . PLUSPLUS lhs
    (80) assign -> . lhs MINUSMINUS
    (81) assign -> . MINUSMINUS lhs
    (82) new_array -> . NEW type expr_array_helper
    (90) literal -> . INTEGERCONSTANT
    (91) literal -> . FLOATCONSTANT
    (92) literal -> . STRINGCONSTANT
    (93) literal -> . NULL
    (94) literal -> . TRUE
    (95) literal -> . FALSE
    (106) lhs -> . field_access
    (107) lhs -> . array_access
    (111) method_invocation -> . field_access LPAREN RPAREN
    (112) method_invocation -> . field_access LPAREN arguments RPAREN
    (108) field_access -> . primary DOT IDENTIFIER
    (109) field_access -> . IDENTIFIER
    (110) array_access -> . primary LSQUARE expr RSQUARE

    NOT             shift and go to state 130
    MINUS           shift and go to state 121
    PLUS            shift and go to state 123
    THIS            shift and go to state 105
    SUPER           shift and go to state 108
    LPAREN          shift and go to state 96
    NEW             shift and go to state 120
    PLUSPLUS        shift and go to state 94
    MINUSMINUS      shift and go to state 98
    INTEGERCONSTANT shift and go to state 102
    FLOATCONSTANT   shift and go to state 100
    STRINGCONSTANT  shift and go to state 83
    NULL            shift and go to state 81
    TRUE            shift and go to state 85
    FALSE           shift and go to state 97
    IDENTIFIER      shift and go to state 125

    new_array                      shift and go to state 118
    field_access                   shift and go to state 126
    expr                           shift and go to state 171
    primary                        shift and go to state 119
    array_access                   shift and go to state 82
    literal                        shift and go to state 87
    lhs                            shift and go to state 129
    method_invocation              shift and go to state 124
    assign                         shift and go to state 128

state 132

    (108) field_access -> primary DOT . IDENTIFIER

    IDENTIFIER      shift and go to state 172


state 133

    (42) stmt -> WHILE LPAREN . expr RPAREN stmt
    (59) expr -> . primary
    (60) expr -> . assign
    (61) expr -> . new_array
    (62) expr -> . expr OR expr
    (63) expr -> . expr AND expr
    (64) expr -> . expr EQUALS expr
    (65) expr -> . expr NOTEQUALS expr
    (66) expr -> . expr LT expr
    (67) expr -> . expr GT expr
    (68) expr -> . expr LEQ expr
    (69) expr -> . expr GEQ expr
    (70) expr -> . expr PLUS expr
    (71) expr -> . expr MINUS expr
    (72) expr -> . expr MULT expr
    (73) expr -> . expr DIV expr
    (74) expr -> . NOT expr
    (75) expr -> . MINUS expr
    (76) expr -> . PLUS expr
    (96) primary -> . literal
    (97) primary -> . THIS
    (98) primary -> . SUPER
    (99) primary -> . LPAREN expr RPAREN
    (100) primary -> . NEW IDENTIFIER LPAREN RPAREN
    (101) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (102) primary -> . lhs
    (103) primary -> . method_invocation
    (77) assign -> . lhs ASSIGN expr
    (78) assign -> . lhs PLUSPLUS
    (79) assign -> . PLUSPLUS lhs
    (80) assign -> . lhs MINUSMINUS
    (81) assign -> . MINUSMINUS lhs
    (82) new_array -> . NEW type expr_array_helper
    (90) literal -> . INTEGERCONSTANT
    (91) literal -> . FLOATCONSTANT
    (92) literal -> . STRINGCONSTANT
    (93) literal -> . NULL
    (94) literal -> . TRUE
    (95) literal -> . FALSE
    (106) lhs -> . field_access
    (107) lhs -> . array_access
    (111) method_invocation -> . field_access LPAREN RPAREN
    (112) method_invocation -> . field_access LPAREN arguments RPAREN
    (108) field_access -> . primary DOT IDENTIFIER
    (109) field_access -> . IDENTIFIER
    (110) array_access -> . primary LSQUARE expr RSQUARE

    NOT             shift and go to state 130
    MINUS           shift and go to state 121
    PLUS            shift and go to state 123
    THIS            shift and go to state 105
    SUPER           shift and go to state 108
    LPAREN          shift and go to state 96
    NEW             shift and go to state 120
    PLUSPLUS        shift and go to state 94
    MINUSMINUS      shift and go to state 98
    INTEGERCONSTANT shift and go to state 102
    FLOATCONSTANT   shift and go to state 100
    STRINGCONSTANT  shift and go to state 83
    NULL            shift and go to state 81
    TRUE            shift and go to state 85
    FALSE           shift and go to state 97
    IDENTIFIER      shift and go to state 125

    new_array                      shift and go to state 118
    field_access                   shift and go to state 126
    expr                           shift and go to state 173
    primary                        shift and go to state 119
    literal                        shift and go to state 87
    array_access                   shift and go to state 82
    lhs                            shift and go to state 129
    method_invocation              shift and go to state 124
    assign                         shift and go to state 128

state 134

    (100) primary -> NEW IDENTIFIER . LPAREN RPAREN
    (101) primary -> NEW IDENTIFIER . LPAREN arguments RPAREN

    LPAREN          shift and go to state 174


state 135

    (53) stmt -> stmt_expr SEMICOLON .

    RCURLY          reduce using rule 53 (stmt -> stmt_expr SEMICOLON .)
    IF              reduce using rule 53 (stmt -> stmt_expr SEMICOLON .)
    WHILE           reduce using rule 53 (stmt -> stmt_expr SEMICOLON .)
    FOR             reduce using rule 53 (stmt -> stmt_expr SEMICOLON .)
    RETURN          reduce using rule 53 (stmt -> stmt_expr SEMICOLON .)
    BREAK           reduce using rule 53 (stmt -> stmt_expr SEMICOLON .)
    CONTINUE        reduce using rule 53 (stmt -> stmt_expr SEMICOLON .)
    SEMICOLON       reduce using rule 53 (stmt -> stmt_expr SEMICOLON .)
    LCURLY          reduce using rule 53 (stmt -> stmt_expr SEMICOLON .)
    INT             reduce using rule 53 (stmt -> stmt_expr SEMICOLON .)
    FLOAT           reduce using rule 53 (stmt -> stmt_expr SEMICOLON .)
    BOOLEAN         reduce using rule 53 (stmt -> stmt_expr SEMICOLON .)
    IDENTIFIER      reduce using rule 53 (stmt -> stmt_expr SEMICOLON .)
    PLUSPLUS        reduce using rule 53 (stmt -> stmt_expr SEMICOLON .)
    MINUSMINUS      reduce using rule 53 (stmt -> stmt_expr SEMICOLON .)
    THIS            reduce using rule 53 (stmt -> stmt_expr SEMICOLON .)
    SUPER           reduce using rule 53 (stmt -> stmt_expr SEMICOLON .)
    LPAREN          reduce using rule 53 (stmt -> stmt_expr SEMICOLON .)
    NEW             reduce using rule 53 (stmt -> stmt_expr SEMICOLON .)
    INTEGERCONSTANT reduce using rule 53 (stmt -> stmt_expr SEMICOLON .)
    FLOATCONSTANT   reduce using rule 53 (stmt -> stmt_expr SEMICOLON .)
    STRINGCONSTANT  reduce using rule 53 (stmt -> stmt_expr SEMICOLON .)
    NULL            reduce using rule 53 (stmt -> stmt_expr SEMICOLON .)
    TRUE            reduce using rule 53 (stmt -> stmt_expr SEMICOLON .)
    FALSE           reduce using rule 53 (stmt -> stmt_expr SEMICOLON .)
    ELSE            reduce using rule 53 (stmt -> stmt_expr SEMICOLON .)


state 136

    (36) block -> LCURLY empty RCURLY .

    RCURLY          reduce using rule 36 (block -> LCURLY empty RCURLY .)
    IF              reduce using rule 36 (block -> LCURLY empty RCURLY .)
    WHILE           reduce using rule 36 (block -> LCURLY empty RCURLY .)
    FOR             reduce using rule 36 (block -> LCURLY empty RCURLY .)
    RETURN          reduce using rule 36 (block -> LCURLY empty RCURLY .)
    BREAK           reduce using rule 36 (block -> LCURLY empty RCURLY .)
    CONTINUE        reduce using rule 36 (block -> LCURLY empty RCURLY .)
    SEMICOLON       reduce using rule 36 (block -> LCURLY empty RCURLY .)
    LCURLY          reduce using rule 36 (block -> LCURLY empty RCURLY .)
    INT             reduce using rule 36 (block -> LCURLY empty RCURLY .)
    FLOAT           reduce using rule 36 (block -> LCURLY empty RCURLY .)
    BOOLEAN         reduce using rule 36 (block -> LCURLY empty RCURLY .)
    IDENTIFIER      reduce using rule 36 (block -> LCURLY empty RCURLY .)
    PLUSPLUS        reduce using rule 36 (block -> LCURLY empty RCURLY .)
    MINUSMINUS      reduce using rule 36 (block -> LCURLY empty RCURLY .)
    THIS            reduce using rule 36 (block -> LCURLY empty RCURLY .)
    SUPER           reduce using rule 36 (block -> LCURLY empty RCURLY .)
    LPAREN          reduce using rule 36 (block -> LCURLY empty RCURLY .)
    NEW             reduce using rule 36 (block -> LCURLY empty RCURLY .)
    INTEGERCONSTANT reduce using rule 36 (block -> LCURLY empty RCURLY .)
    FLOATCONSTANT   reduce using rule 36 (block -> LCURLY empty RCURLY .)
    STRINGCONSTANT  reduce using rule 36 (block -> LCURLY empty RCURLY .)
    NULL            reduce using rule 36 (block -> LCURLY empty RCURLY .)
    TRUE            reduce using rule 36 (block -> LCURLY empty RCURLY .)
    FALSE           reduce using rule 36 (block -> LCURLY empty RCURLY .)
    ELSE            reduce using rule 36 (block -> LCURLY empty RCURLY .)
    PUBLIC          reduce using rule 36 (block -> LCURLY empty RCURLY .)
    PRIVATE         reduce using rule 36 (block -> LCURLY empty RCURLY .)
    STATIC          reduce using rule 36 (block -> LCURLY empty RCURLY .)
    VOID            reduce using rule 36 (block -> LCURLY empty RCURLY .)


state 137

    (111) method_invocation -> field_access LPAREN . RPAREN
    (112) method_invocation -> field_access LPAREN . arguments RPAREN
    (104) arguments -> . expr
    (105) arguments -> . arguments COMMA expr
    (59) expr -> . primary
    (60) expr -> . assign
    (61) expr -> . new_array
    (62) expr -> . expr OR expr
    (63) expr -> . expr AND expr
    (64) expr -> . expr EQUALS expr
    (65) expr -> . expr NOTEQUALS expr
    (66) expr -> . expr LT expr
    (67) expr -> . expr GT expr
    (68) expr -> . expr LEQ expr
    (69) expr -> . expr GEQ expr
    (70) expr -> . expr PLUS expr
    (71) expr -> . expr MINUS expr
    (72) expr -> . expr MULT expr
    (73) expr -> . expr DIV expr
    (74) expr -> . NOT expr
    (75) expr -> . MINUS expr
    (76) expr -> . PLUS expr
    (96) primary -> . literal
    (97) primary -> . THIS
    (98) primary -> . SUPER
    (99) primary -> . LPAREN expr RPAREN
    (100) primary -> . NEW IDENTIFIER LPAREN RPAREN
    (101) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (102) primary -> . lhs
    (103) primary -> . method_invocation
    (77) assign -> . lhs ASSIGN expr
    (78) assign -> . lhs PLUSPLUS
    (79) assign -> . PLUSPLUS lhs
    (80) assign -> . lhs MINUSMINUS
    (81) assign -> . MINUSMINUS lhs
    (82) new_array -> . NEW type expr_array_helper
    (90) literal -> . INTEGERCONSTANT
    (91) literal -> . FLOATCONSTANT
    (92) literal -> . STRINGCONSTANT
    (93) literal -> . NULL
    (94) literal -> . TRUE
    (95) literal -> . FALSE
    (106) lhs -> . field_access
    (107) lhs -> . array_access
    (111) method_invocation -> . field_access LPAREN RPAREN
    (112) method_invocation -> . field_access LPAREN arguments RPAREN
    (108) field_access -> . primary DOT IDENTIFIER
    (109) field_access -> . IDENTIFIER
    (110) array_access -> . primary LSQUARE expr RSQUARE

    RPAREN          shift and go to state 175
    NOT             shift and go to state 130
    MINUS           shift and go to state 121
    PLUS            shift and go to state 123
    THIS            shift and go to state 105
    SUPER           shift and go to state 108
    LPAREN          shift and go to state 96
    NEW             shift and go to state 120
    PLUSPLUS        shift and go to state 94
    MINUSMINUS      shift and go to state 98
    INTEGERCONSTANT shift and go to state 102
    FLOATCONSTANT   shift and go to state 100
    STRINGCONSTANT  shift and go to state 83
    NULL            shift and go to state 81
    TRUE            shift and go to state 85
    FALSE           shift and go to state 97
    IDENTIFIER      shift and go to state 125

    new_array                      shift and go to state 118
    field_access                   shift and go to state 126
    expr                           shift and go to state 177
    primary                        shift and go to state 119
    array_access                   shift and go to state 82
    literal                        shift and go to state 87
    lhs                            shift and go to state 129
    arguments                      shift and go to state 176
    method_invocation              shift and go to state 124
    assign                         shift and go to state 128

state 138

    (43) stmt -> FOR LPAREN . SEMICOLON SEMICOLON RPAREN stmt
    (44) stmt -> FOR LPAREN . stmt_expr SEMICOLON SEMICOLON RPAREN stmt
    (45) stmt -> FOR LPAREN . stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt
    (46) stmt -> FOR LPAREN . stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt
    (47) stmt -> FOR LPAREN . stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (48) stmt -> FOR LPAREN . SEMICOLON expr SEMICOLON RPAREN stmt
    (49) stmt -> FOR LPAREN . SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (50) stmt -> FOR LPAREN . SEMICOLON SEMICOLON stmt_expr RPAREN stmt
    (88) stmt_expr -> . assign
    (89) stmt_expr -> . method_invocation
    (77) assign -> . lhs ASSIGN expr
    (78) assign -> . lhs PLUSPLUS
    (79) assign -> . PLUSPLUS lhs
    (80) assign -> . lhs MINUSMINUS
    (81) assign -> . MINUSMINUS lhs
    (111) method_invocation -> . field_access LPAREN RPAREN
    (112) method_invocation -> . field_access LPAREN arguments RPAREN
    (106) lhs -> . field_access
    (107) lhs -> . array_access
    (108) field_access -> . primary DOT IDENTIFIER
    (109) field_access -> . IDENTIFIER
    (110) array_access -> . primary LSQUARE expr RSQUARE
    (96) primary -> . literal
    (97) primary -> . THIS
    (98) primary -> . SUPER
    (99) primary -> . LPAREN expr RPAREN
    (100) primary -> . NEW IDENTIFIER LPAREN RPAREN
    (101) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (102) primary -> . lhs
    (103) primary -> . method_invocation
    (90) literal -> . INTEGERCONSTANT
    (91) literal -> . FLOATCONSTANT
    (92) literal -> . STRINGCONSTANT
    (93) literal -> . NULL
    (94) literal -> . TRUE
    (95) literal -> . FALSE

    SEMICOLON       shift and go to state 178
    PLUSPLUS        shift and go to state 94
    MINUSMINUS      shift and go to state 98
    IDENTIFIER      shift and go to state 125
    THIS            shift and go to state 105
    SUPER           shift and go to state 108
    LPAREN          shift and go to state 96
    NEW             shift and go to state 80
    INTEGERCONSTANT shift and go to state 102
    FLOATCONSTANT   shift and go to state 100
    STRINGCONSTANT  shift and go to state 83
    NULL            shift and go to state 81
    TRUE            shift and go to state 85
    FALSE           shift and go to state 97

    field_access                   shift and go to state 92
    primary                        shift and go to state 78
    stmt_expr                      shift and go to state 179
    literal                        shift and go to state 87
    lhs                            shift and go to state 107
    method_invocation              shift and go to state 88
    array_access                   shift and go to state 82
    assign                         shift and go to state 109

state 139

    (79) assign -> PLUSPLUS lhs .
    (102) primary -> lhs .

    OR              reduce using rule 79 (assign -> PLUSPLUS lhs .)
    AND             reduce using rule 79 (assign -> PLUSPLUS lhs .)
    EQUALS          reduce using rule 79 (assign -> PLUSPLUS lhs .)
    NOTEQUALS       reduce using rule 79 (assign -> PLUSPLUS lhs .)
    LT              reduce using rule 79 (assign -> PLUSPLUS lhs .)
    GT              reduce using rule 79 (assign -> PLUSPLUS lhs .)
    LEQ             reduce using rule 79 (assign -> PLUSPLUS lhs .)
    GEQ             reduce using rule 79 (assign -> PLUSPLUS lhs .)
    PLUS            reduce using rule 79 (assign -> PLUSPLUS lhs .)
    MINUS           reduce using rule 79 (assign -> PLUSPLUS lhs .)
    MULT            reduce using rule 79 (assign -> PLUSPLUS lhs .)
    DIV             reduce using rule 79 (assign -> PLUSPLUS lhs .)
    RPAREN          reduce using rule 79 (assign -> PLUSPLUS lhs .)
    COMMA           reduce using rule 79 (assign -> PLUSPLUS lhs .)
    SEMICOLON       reduce using rule 79 (assign -> PLUSPLUS lhs .)
    RSQUARE         reduce using rule 79 (assign -> PLUSPLUS lhs .)
    DOT             reduce using rule 102 (primary -> lhs .)
    LSQUARE         reduce using rule 102 (primary -> lhs .)


state 140

    (99) primary -> LPAREN expr . RPAREN
    (62) expr -> expr . OR expr
    (63) expr -> expr . AND expr
    (64) expr -> expr . EQUALS expr
    (65) expr -> expr . NOTEQUALS expr
    (66) expr -> expr . LT expr
    (67) expr -> expr . GT expr
    (68) expr -> expr . LEQ expr
    (69) expr -> expr . GEQ expr
    (70) expr -> expr . PLUS expr
    (71) expr -> expr . MINUS expr
    (72) expr -> expr . MULT expr
    (73) expr -> expr . DIV expr

    RPAREN          shift and go to state 180
    OR              shift and go to state 168
    AND             shift and go to state 157
    EQUALS          shift and go to state 162
    NOTEQUALS       shift and go to state 158
    LT              shift and go to state 165
    GT              shift and go to state 160
    LEQ             shift and go to state 164
    GEQ             shift and go to state 159
    PLUS            shift and go to state 166
    MINUS           shift and go to state 163
    MULT            shift and go to state 169
    DIV             shift and go to state 167


state 141

    (81) assign -> MINUSMINUS lhs .
    (102) primary -> lhs .

    OR              reduce using rule 81 (assign -> MINUSMINUS lhs .)
    AND             reduce using rule 81 (assign -> MINUSMINUS lhs .)
    EQUALS          reduce using rule 81 (assign -> MINUSMINUS lhs .)
    NOTEQUALS       reduce using rule 81 (assign -> MINUSMINUS lhs .)
    LT              reduce using rule 81 (assign -> MINUSMINUS lhs .)
    GT              reduce using rule 81 (assign -> MINUSMINUS lhs .)
    LEQ             reduce using rule 81 (assign -> MINUSMINUS lhs .)
    GEQ             reduce using rule 81 (assign -> MINUSMINUS lhs .)
    PLUS            reduce using rule 81 (assign -> MINUSMINUS lhs .)
    MINUS           reduce using rule 81 (assign -> MINUSMINUS lhs .)
    MULT            reduce using rule 81 (assign -> MINUSMINUS lhs .)
    DIV             reduce using rule 81 (assign -> MINUSMINUS lhs .)
    RPAREN          reduce using rule 81 (assign -> MINUSMINUS lhs .)
    COMMA           reduce using rule 81 (assign -> MINUSMINUS lhs .)
    SEMICOLON       reduce using rule 81 (assign -> MINUSMINUS lhs .)
    RSQUARE         reduce using rule 81 (assign -> MINUSMINUS lhs .)
    DOT             reduce using rule 102 (primary -> lhs .)
    LSQUARE         reduce using rule 102 (primary -> lhs .)


state 142

    (40) stmt -> IF LPAREN . expr RPAREN stmt ELSE stmt
    (41) stmt -> IF LPAREN . expr RPAREN stmt
    (59) expr -> . primary
    (60) expr -> . assign
    (61) expr -> . new_array
    (62) expr -> . expr OR expr
    (63) expr -> . expr AND expr
    (64) expr -> . expr EQUALS expr
    (65) expr -> . expr NOTEQUALS expr
    (66) expr -> . expr LT expr
    (67) expr -> . expr GT expr
    (68) expr -> . expr LEQ expr
    (69) expr -> . expr GEQ expr
    (70) expr -> . expr PLUS expr
    (71) expr -> . expr MINUS expr
    (72) expr -> . expr MULT expr
    (73) expr -> . expr DIV expr
    (74) expr -> . NOT expr
    (75) expr -> . MINUS expr
    (76) expr -> . PLUS expr
    (96) primary -> . literal
    (97) primary -> . THIS
    (98) primary -> . SUPER
    (99) primary -> . LPAREN expr RPAREN
    (100) primary -> . NEW IDENTIFIER LPAREN RPAREN
    (101) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (102) primary -> . lhs
    (103) primary -> . method_invocation
    (77) assign -> . lhs ASSIGN expr
    (78) assign -> . lhs PLUSPLUS
    (79) assign -> . PLUSPLUS lhs
    (80) assign -> . lhs MINUSMINUS
    (81) assign -> . MINUSMINUS lhs
    (82) new_array -> . NEW type expr_array_helper
    (90) literal -> . INTEGERCONSTANT
    (91) literal -> . FLOATCONSTANT
    (92) literal -> . STRINGCONSTANT
    (93) literal -> . NULL
    (94) literal -> . TRUE
    (95) literal -> . FALSE
    (106) lhs -> . field_access
    (107) lhs -> . array_access
    (111) method_invocation -> . field_access LPAREN RPAREN
    (112) method_invocation -> . field_access LPAREN arguments RPAREN
    (108) field_access -> . primary DOT IDENTIFIER
    (109) field_access -> . IDENTIFIER
    (110) array_access -> . primary LSQUARE expr RSQUARE

    NOT             shift and go to state 130
    MINUS           shift and go to state 121
    PLUS            shift and go to state 123
    THIS            shift and go to state 105
    SUPER           shift and go to state 108
    LPAREN          shift and go to state 96
    NEW             shift and go to state 120
    PLUSPLUS        shift and go to state 94
    MINUSMINUS      shift and go to state 98
    INTEGERCONSTANT shift and go to state 102
    FLOATCONSTANT   shift and go to state 100
    STRINGCONSTANT  shift and go to state 83
    NULL            shift and go to state 81
    TRUE            shift and go to state 85
    FALSE           shift and go to state 97
    IDENTIFIER      shift and go to state 125

    new_array                      shift and go to state 118
    field_access                   shift and go to state 126
    expr                           shift and go to state 181
    primary                        shift and go to state 119
    literal                        shift and go to state 87
    array_access                   shift and go to state 82
    lhs                            shift and go to state 129
    method_invocation              shift and go to state 124
    assign                         shift and go to state 128

state 143

    (37) block -> LCURLY stmthelper RCURLY .

    RCURLY          reduce using rule 37 (block -> LCURLY stmthelper RCURLY .)
    IF              reduce using rule 37 (block -> LCURLY stmthelper RCURLY .)
    WHILE           reduce using rule 37 (block -> LCURLY stmthelper RCURLY .)
    FOR             reduce using rule 37 (block -> LCURLY stmthelper RCURLY .)
    RETURN          reduce using rule 37 (block -> LCURLY stmthelper RCURLY .)
    BREAK           reduce using rule 37 (block -> LCURLY stmthelper RCURLY .)
    CONTINUE        reduce using rule 37 (block -> LCURLY stmthelper RCURLY .)
    SEMICOLON       reduce using rule 37 (block -> LCURLY stmthelper RCURLY .)
    LCURLY          reduce using rule 37 (block -> LCURLY stmthelper RCURLY .)
    INT             reduce using rule 37 (block -> LCURLY stmthelper RCURLY .)
    FLOAT           reduce using rule 37 (block -> LCURLY stmthelper RCURLY .)
    BOOLEAN         reduce using rule 37 (block -> LCURLY stmthelper RCURLY .)
    IDENTIFIER      reduce using rule 37 (block -> LCURLY stmthelper RCURLY .)
    PLUSPLUS        reduce using rule 37 (block -> LCURLY stmthelper RCURLY .)
    MINUSMINUS      reduce using rule 37 (block -> LCURLY stmthelper RCURLY .)
    THIS            reduce using rule 37 (block -> LCURLY stmthelper RCURLY .)
    SUPER           reduce using rule 37 (block -> LCURLY stmthelper RCURLY .)
    LPAREN          reduce using rule 37 (block -> LCURLY stmthelper RCURLY .)
    NEW             reduce using rule 37 (block -> LCURLY stmthelper RCURLY .)
    INTEGERCONSTANT reduce using rule 37 (block -> LCURLY stmthelper RCURLY .)
    FLOATCONSTANT   reduce using rule 37 (block -> LCURLY stmthelper RCURLY .)
    STRINGCONSTANT  reduce using rule 37 (block -> LCURLY stmthelper RCURLY .)
    NULL            reduce using rule 37 (block -> LCURLY stmthelper RCURLY .)
    TRUE            reduce using rule 37 (block -> LCURLY stmthelper RCURLY .)
    FALSE           reduce using rule 37 (block -> LCURLY stmthelper RCURLY .)
    ELSE            reduce using rule 37 (block -> LCURLY stmthelper RCURLY .)
    PUBLIC          reduce using rule 37 (block -> LCURLY stmthelper RCURLY .)
    PRIVATE         reduce using rule 37 (block -> LCURLY stmthelper RCURLY .)
    STATIC          reduce using rule 37 (block -> LCURLY stmthelper RCURLY .)
    VOID            reduce using rule 37 (block -> LCURLY stmthelper RCURLY .)


state 144

    (39) stmthelper -> stmthelper stmt .

    RCURLY          reduce using rule 39 (stmthelper -> stmthelper stmt .)
    IF              reduce using rule 39 (stmthelper -> stmthelper stmt .)
    WHILE           reduce using rule 39 (stmthelper -> stmthelper stmt .)
    FOR             reduce using rule 39 (stmthelper -> stmthelper stmt .)
    RETURN          reduce using rule 39 (stmthelper -> stmthelper stmt .)
    BREAK           reduce using rule 39 (stmthelper -> stmthelper stmt .)
    CONTINUE        reduce using rule 39 (stmthelper -> stmthelper stmt .)
    SEMICOLON       reduce using rule 39 (stmthelper -> stmthelper stmt .)
    LCURLY          reduce using rule 39 (stmthelper -> stmthelper stmt .)
    INT             reduce using rule 39 (stmthelper -> stmthelper stmt .)
    FLOAT           reduce using rule 39 (stmthelper -> stmthelper stmt .)
    BOOLEAN         reduce using rule 39 (stmthelper -> stmthelper stmt .)
    IDENTIFIER      reduce using rule 39 (stmthelper -> stmthelper stmt .)
    PLUSPLUS        reduce using rule 39 (stmthelper -> stmthelper stmt .)
    MINUSMINUS      reduce using rule 39 (stmthelper -> stmthelper stmt .)
    THIS            reduce using rule 39 (stmthelper -> stmthelper stmt .)
    SUPER           reduce using rule 39 (stmthelper -> stmthelper stmt .)
    LPAREN          reduce using rule 39 (stmthelper -> stmthelper stmt .)
    NEW             reduce using rule 39 (stmthelper -> stmthelper stmt .)
    INTEGERCONSTANT reduce using rule 39 (stmthelper -> stmthelper stmt .)
    FLOATCONSTANT   reduce using rule 39 (stmthelper -> stmthelper stmt .)
    STRINGCONSTANT  reduce using rule 39 (stmthelper -> stmthelper stmt .)
    NULL            reduce using rule 39 (stmthelper -> stmthelper stmt .)
    TRUE            reduce using rule 39 (stmthelper -> stmthelper stmt .)
    FALSE           reduce using rule 39 (stmthelper -> stmthelper stmt .)


state 145

    (56) stmt -> BREAK SEMICOLON .

    RCURLY          reduce using rule 56 (stmt -> BREAK SEMICOLON .)
    IF              reduce using rule 56 (stmt -> BREAK SEMICOLON .)
    WHILE           reduce using rule 56 (stmt -> BREAK SEMICOLON .)
    FOR             reduce using rule 56 (stmt -> BREAK SEMICOLON .)
    RETURN          reduce using rule 56 (stmt -> BREAK SEMICOLON .)
    BREAK           reduce using rule 56 (stmt -> BREAK SEMICOLON .)
    CONTINUE        reduce using rule 56 (stmt -> BREAK SEMICOLON .)
    SEMICOLON       reduce using rule 56 (stmt -> BREAK SEMICOLON .)
    LCURLY          reduce using rule 56 (stmt -> BREAK SEMICOLON .)
    INT             reduce using rule 56 (stmt -> BREAK SEMICOLON .)
    FLOAT           reduce using rule 56 (stmt -> BREAK SEMICOLON .)
    BOOLEAN         reduce using rule 56 (stmt -> BREAK SEMICOLON .)
    IDENTIFIER      reduce using rule 56 (stmt -> BREAK SEMICOLON .)
    PLUSPLUS        reduce using rule 56 (stmt -> BREAK SEMICOLON .)
    MINUSMINUS      reduce using rule 56 (stmt -> BREAK SEMICOLON .)
    THIS            reduce using rule 56 (stmt -> BREAK SEMICOLON .)
    SUPER           reduce using rule 56 (stmt -> BREAK SEMICOLON .)
    LPAREN          reduce using rule 56 (stmt -> BREAK SEMICOLON .)
    NEW             reduce using rule 56 (stmt -> BREAK SEMICOLON .)
    INTEGERCONSTANT reduce using rule 56 (stmt -> BREAK SEMICOLON .)
    FLOATCONSTANT   reduce using rule 56 (stmt -> BREAK SEMICOLON .)
    STRINGCONSTANT  reduce using rule 56 (stmt -> BREAK SEMICOLON .)
    NULL            reduce using rule 56 (stmt -> BREAK SEMICOLON .)
    TRUE            reduce using rule 56 (stmt -> BREAK SEMICOLON .)
    FALSE           reduce using rule 56 (stmt -> BREAK SEMICOLON .)
    ELSE            reduce using rule 56 (stmt -> BREAK SEMICOLON .)


state 146

    (57) stmt -> CONTINUE SEMICOLON .

    RCURLY          reduce using rule 57 (stmt -> CONTINUE SEMICOLON .)
    IF              reduce using rule 57 (stmt -> CONTINUE SEMICOLON .)
    WHILE           reduce using rule 57 (stmt -> CONTINUE SEMICOLON .)
    FOR             reduce using rule 57 (stmt -> CONTINUE SEMICOLON .)
    RETURN          reduce using rule 57 (stmt -> CONTINUE SEMICOLON .)
    BREAK           reduce using rule 57 (stmt -> CONTINUE SEMICOLON .)
    CONTINUE        reduce using rule 57 (stmt -> CONTINUE SEMICOLON .)
    SEMICOLON       reduce using rule 57 (stmt -> CONTINUE SEMICOLON .)
    LCURLY          reduce using rule 57 (stmt -> CONTINUE SEMICOLON .)
    INT             reduce using rule 57 (stmt -> CONTINUE SEMICOLON .)
    FLOAT           reduce using rule 57 (stmt -> CONTINUE SEMICOLON .)
    BOOLEAN         reduce using rule 57 (stmt -> CONTINUE SEMICOLON .)
    IDENTIFIER      reduce using rule 57 (stmt -> CONTINUE SEMICOLON .)
    PLUSPLUS        reduce using rule 57 (stmt -> CONTINUE SEMICOLON .)
    MINUSMINUS      reduce using rule 57 (stmt -> CONTINUE SEMICOLON .)
    THIS            reduce using rule 57 (stmt -> CONTINUE SEMICOLON .)
    SUPER           reduce using rule 57 (stmt -> CONTINUE SEMICOLON .)
    LPAREN          reduce using rule 57 (stmt -> CONTINUE SEMICOLON .)
    NEW             reduce using rule 57 (stmt -> CONTINUE SEMICOLON .)
    INTEGERCONSTANT reduce using rule 57 (stmt -> CONTINUE SEMICOLON .)
    FLOATCONSTANT   reduce using rule 57 (stmt -> CONTINUE SEMICOLON .)
    STRINGCONSTANT  reduce using rule 57 (stmt -> CONTINUE SEMICOLON .)
    NULL            reduce using rule 57 (stmt -> CONTINUE SEMICOLON .)
    TRUE            reduce using rule 57 (stmt -> CONTINUE SEMICOLON .)
    FALSE           reduce using rule 57 (stmt -> CONTINUE SEMICOLON .)
    ELSE            reduce using rule 57 (stmt -> CONTINUE SEMICOLON .)


state 147

    (78) assign -> lhs PLUSPLUS .

    OR              reduce using rule 78 (assign -> lhs PLUSPLUS .)
    AND             reduce using rule 78 (assign -> lhs PLUSPLUS .)
    EQUALS          reduce using rule 78 (assign -> lhs PLUSPLUS .)
    NOTEQUALS       reduce using rule 78 (assign -> lhs PLUSPLUS .)
    LT              reduce using rule 78 (assign -> lhs PLUSPLUS .)
    GT              reduce using rule 78 (assign -> lhs PLUSPLUS .)
    LEQ             reduce using rule 78 (assign -> lhs PLUSPLUS .)
    GEQ             reduce using rule 78 (assign -> lhs PLUSPLUS .)
    PLUS            reduce using rule 78 (assign -> lhs PLUSPLUS .)
    MINUS           reduce using rule 78 (assign -> lhs PLUSPLUS .)
    MULT            reduce using rule 78 (assign -> lhs PLUSPLUS .)
    DIV             reduce using rule 78 (assign -> lhs PLUSPLUS .)
    RPAREN          reduce using rule 78 (assign -> lhs PLUSPLUS .)
    COMMA           reduce using rule 78 (assign -> lhs PLUSPLUS .)
    SEMICOLON       reduce using rule 78 (assign -> lhs PLUSPLUS .)
    RSQUARE         reduce using rule 78 (assign -> lhs PLUSPLUS .)


state 148

    (80) assign -> lhs MINUSMINUS .

    OR              reduce using rule 80 (assign -> lhs MINUSMINUS .)
    AND             reduce using rule 80 (assign -> lhs MINUSMINUS .)
    EQUALS          reduce using rule 80 (assign -> lhs MINUSMINUS .)
    NOTEQUALS       reduce using rule 80 (assign -> lhs MINUSMINUS .)
    LT              reduce using rule 80 (assign -> lhs MINUSMINUS .)
    GT              reduce using rule 80 (assign -> lhs MINUSMINUS .)
    LEQ             reduce using rule 80 (assign -> lhs MINUSMINUS .)
    GEQ             reduce using rule 80 (assign -> lhs MINUSMINUS .)
    PLUS            reduce using rule 80 (assign -> lhs MINUSMINUS .)
    MINUS           reduce using rule 80 (assign -> lhs MINUSMINUS .)
    MULT            reduce using rule 80 (assign -> lhs MINUSMINUS .)
    DIV             reduce using rule 80 (assign -> lhs MINUSMINUS .)
    RPAREN          reduce using rule 80 (assign -> lhs MINUSMINUS .)
    COMMA           reduce using rule 80 (assign -> lhs MINUSMINUS .)
    SEMICOLON       reduce using rule 80 (assign -> lhs MINUSMINUS .)
    RSQUARE         reduce using rule 80 (assign -> lhs MINUSMINUS .)


state 149

    (77) assign -> lhs ASSIGN . expr
    (59) expr -> . primary
    (60) expr -> . assign
    (61) expr -> . new_array
    (62) expr -> . expr OR expr
    (63) expr -> . expr AND expr
    (64) expr -> . expr EQUALS expr
    (65) expr -> . expr NOTEQUALS expr
    (66) expr -> . expr LT expr
    (67) expr -> . expr GT expr
    (68) expr -> . expr LEQ expr
    (69) expr -> . expr GEQ expr
    (70) expr -> . expr PLUS expr
    (71) expr -> . expr MINUS expr
    (72) expr -> . expr MULT expr
    (73) expr -> . expr DIV expr
    (74) expr -> . NOT expr
    (75) expr -> . MINUS expr
    (76) expr -> . PLUS expr
    (96) primary -> . literal
    (97) primary -> . THIS
    (98) primary -> . SUPER
    (99) primary -> . LPAREN expr RPAREN
    (100) primary -> . NEW IDENTIFIER LPAREN RPAREN
    (101) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (102) primary -> . lhs
    (103) primary -> . method_invocation
    (77) assign -> . lhs ASSIGN expr
    (78) assign -> . lhs PLUSPLUS
    (79) assign -> . PLUSPLUS lhs
    (80) assign -> . lhs MINUSMINUS
    (81) assign -> . MINUSMINUS lhs
    (82) new_array -> . NEW type expr_array_helper
    (90) literal -> . INTEGERCONSTANT
    (91) literal -> . FLOATCONSTANT
    (92) literal -> . STRINGCONSTANT
    (93) literal -> . NULL
    (94) literal -> . TRUE
    (95) literal -> . FALSE
    (106) lhs -> . field_access
    (107) lhs -> . array_access
    (111) method_invocation -> . field_access LPAREN RPAREN
    (112) method_invocation -> . field_access LPAREN arguments RPAREN
    (108) field_access -> . primary DOT IDENTIFIER
    (109) field_access -> . IDENTIFIER
    (110) array_access -> . primary LSQUARE expr RSQUARE

    NOT             shift and go to state 130
    MINUS           shift and go to state 121
    PLUS            shift and go to state 123
    THIS            shift and go to state 105
    SUPER           shift and go to state 108
    LPAREN          shift and go to state 96
    NEW             shift and go to state 120
    PLUSPLUS        shift and go to state 94
    MINUSMINUS      shift and go to state 98
    INTEGERCONSTANT shift and go to state 102
    FLOATCONSTANT   shift and go to state 100
    STRINGCONSTANT  shift and go to state 83
    NULL            shift and go to state 81
    TRUE            shift and go to state 85
    FALSE           shift and go to state 97
    IDENTIFIER      shift and go to state 125

    new_array                      shift and go to state 118
    field_access                   shift and go to state 126
    expr                           shift and go to state 182
    primary                        shift and go to state 119
    array_access                   shift and go to state 82
    literal                        shift and go to state 87
    lhs                            shift and go to state 129
    method_invocation              shift and go to state 124
    assign                         shift and go to state 128

state 150

    (25) variables -> variables COMMA IDENTIFIER . brackets
    (23) type -> IDENTIFIER .
    (26) brackets -> . LSQUARE RSQUARE brackets
    (27) brackets -> . empty
    (113) empty -> .

    IDENTIFIER      reduce using rule 23 (type -> IDENTIFIER .)
    LSQUARE         shift and go to state 54
    COMMA           reduce using rule 113 (empty -> .)
    RPAREN          reduce using rule 113 (empty -> .)

    empty                          shift and go to state 56
    brackets                       shift and go to state 113

state 151

    (35) formals -> type variables COMMA formals .

    RPAREN          reduce using rule 35 (formals -> type variables COMMA formals .)


state 152

    (31) method_decl -> modifier type IDENTIFIER LPAREN formals RPAREN block .

    PUBLIC          reduce using rule 31 (method_decl -> modifier type IDENTIFIER LPAREN formals RPAREN block .)
    PRIVATE         reduce using rule 31 (method_decl -> modifier type IDENTIFIER LPAREN formals RPAREN block .)
    STATIC          reduce using rule 31 (method_decl -> modifier type IDENTIFIER LPAREN formals RPAREN block .)
    VOID            reduce using rule 31 (method_decl -> modifier type IDENTIFIER LPAREN formals RPAREN block .)
    IDENTIFIER      reduce using rule 31 (method_decl -> modifier type IDENTIFIER LPAREN formals RPAREN block .)
    INT             reduce using rule 31 (method_decl -> modifier type IDENTIFIER LPAREN formals RPAREN block .)
    FLOAT           reduce using rule 31 (method_decl -> modifier type IDENTIFIER LPAREN formals RPAREN block .)
    BOOLEAN         reduce using rule 31 (method_decl -> modifier type IDENTIFIER LPAREN formals RPAREN block .)
    RCURLY          reduce using rule 31 (method_decl -> modifier type IDENTIFIER LPAREN formals RPAREN block .)


state 153

    (100) primary -> NEW IDENTIFIER . LPAREN RPAREN
    (101) primary -> NEW IDENTIFIER . LPAREN arguments RPAREN
    (23) type -> IDENTIFIER .

    LPAREN          shift and go to state 174
    LSQUARE         reduce using rule 23 (type -> IDENTIFIER .)


state 154

    (82) new_array -> NEW type . expr_array_helper
    (83) expr_array_helper -> . LSQUARE expr RSQUARE
    (84) expr_array_helper -> . LSQUARE expr RSQUARE expr_array_helper
    (85) expr_array_helper -> . LSQUARE expr RSQUARE expr_array_helper2

    LSQUARE         shift and go to state 184

    expr_array_helper              shift and go to state 183

state 155

    (75) expr -> MINUS expr .
    (62) expr -> expr . OR expr
    (63) expr -> expr . AND expr
    (64) expr -> expr . EQUALS expr
    (65) expr -> expr . NOTEQUALS expr
    (66) expr -> expr . LT expr
    (67) expr -> expr . GT expr
    (68) expr -> expr . LEQ expr
    (69) expr -> expr . GEQ expr
    (70) expr -> expr . PLUS expr
    (71) expr -> expr . MINUS expr
    (72) expr -> expr . MULT expr
    (73) expr -> expr . DIV expr

    OR              reduce using rule 75 (expr -> MINUS expr .)
    AND             reduce using rule 75 (expr -> MINUS expr .)
    EQUALS          reduce using rule 75 (expr -> MINUS expr .)
    NOTEQUALS       reduce using rule 75 (expr -> MINUS expr .)
    LT              reduce using rule 75 (expr -> MINUS expr .)
    GT              reduce using rule 75 (expr -> MINUS expr .)
    LEQ             reduce using rule 75 (expr -> MINUS expr .)
    GEQ             reduce using rule 75 (expr -> MINUS expr .)
    PLUS            reduce using rule 75 (expr -> MINUS expr .)
    MINUS           reduce using rule 75 (expr -> MINUS expr .)
    MULT            reduce using rule 75 (expr -> MINUS expr .)
    DIV             reduce using rule 75 (expr -> MINUS expr .)
    RPAREN          reduce using rule 75 (expr -> MINUS expr .)
    COMMA           reduce using rule 75 (expr -> MINUS expr .)
    SEMICOLON       reduce using rule 75 (expr -> MINUS expr .)
    RSQUARE         reduce using rule 75 (expr -> MINUS expr .)

  ! OR              [ shift and go to state 168 ]
  ! AND             [ shift and go to state 157 ]
  ! EQUALS          [ shift and go to state 162 ]
  ! NOTEQUALS       [ shift and go to state 158 ]
  ! LT              [ shift and go to state 165 ]
  ! GT              [ shift and go to state 160 ]
  ! LEQ             [ shift and go to state 164 ]
  ! GEQ             [ shift and go to state 159 ]
  ! PLUS            [ shift and go to state 166 ]
  ! MINUS           [ shift and go to state 163 ]
  ! MULT            [ shift and go to state 169 ]
  ! DIV             [ shift and go to state 167 ]


state 156

    (76) expr -> PLUS expr .
    (62) expr -> expr . OR expr
    (63) expr -> expr . AND expr
    (64) expr -> expr . EQUALS expr
    (65) expr -> expr . NOTEQUALS expr
    (66) expr -> expr . LT expr
    (67) expr -> expr . GT expr
    (68) expr -> expr . LEQ expr
    (69) expr -> expr . GEQ expr
    (70) expr -> expr . PLUS expr
    (71) expr -> expr . MINUS expr
    (72) expr -> expr . MULT expr
    (73) expr -> expr . DIV expr

    OR              reduce using rule 76 (expr -> PLUS expr .)
    AND             reduce using rule 76 (expr -> PLUS expr .)
    EQUALS          reduce using rule 76 (expr -> PLUS expr .)
    NOTEQUALS       reduce using rule 76 (expr -> PLUS expr .)
    LT              reduce using rule 76 (expr -> PLUS expr .)
    GT              reduce using rule 76 (expr -> PLUS expr .)
    LEQ             reduce using rule 76 (expr -> PLUS expr .)
    GEQ             reduce using rule 76 (expr -> PLUS expr .)
    PLUS            reduce using rule 76 (expr -> PLUS expr .)
    MINUS           reduce using rule 76 (expr -> PLUS expr .)
    MULT            reduce using rule 76 (expr -> PLUS expr .)
    DIV             reduce using rule 76 (expr -> PLUS expr .)
    RPAREN          reduce using rule 76 (expr -> PLUS expr .)
    COMMA           reduce using rule 76 (expr -> PLUS expr .)
    SEMICOLON       reduce using rule 76 (expr -> PLUS expr .)
    RSQUARE         reduce using rule 76 (expr -> PLUS expr .)

  ! OR              [ shift and go to state 168 ]
  ! AND             [ shift and go to state 157 ]
  ! EQUALS          [ shift and go to state 162 ]
  ! NOTEQUALS       [ shift and go to state 158 ]
  ! LT              [ shift and go to state 165 ]
  ! GT              [ shift and go to state 160 ]
  ! LEQ             [ shift and go to state 164 ]
  ! GEQ             [ shift and go to state 159 ]
  ! PLUS            [ shift and go to state 166 ]
  ! MINUS           [ shift and go to state 163 ]
  ! MULT            [ shift and go to state 169 ]
  ! DIV             [ shift and go to state 167 ]


state 157

    (63) expr -> expr AND . expr
    (59) expr -> . primary
    (60) expr -> . assign
    (61) expr -> . new_array
    (62) expr -> . expr OR expr
    (63) expr -> . expr AND expr
    (64) expr -> . expr EQUALS expr
    (65) expr -> . expr NOTEQUALS expr
    (66) expr -> . expr LT expr
    (67) expr -> . expr GT expr
    (68) expr -> . expr LEQ expr
    (69) expr -> . expr GEQ expr
    (70) expr -> . expr PLUS expr
    (71) expr -> . expr MINUS expr
    (72) expr -> . expr MULT expr
    (73) expr -> . expr DIV expr
    (74) expr -> . NOT expr
    (75) expr -> . MINUS expr
    (76) expr -> . PLUS expr
    (96) primary -> . literal
    (97) primary -> . THIS
    (98) primary -> . SUPER
    (99) primary -> . LPAREN expr RPAREN
    (100) primary -> . NEW IDENTIFIER LPAREN RPAREN
    (101) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (102) primary -> . lhs
    (103) primary -> . method_invocation
    (77) assign -> . lhs ASSIGN expr
    (78) assign -> . lhs PLUSPLUS
    (79) assign -> . PLUSPLUS lhs
    (80) assign -> . lhs MINUSMINUS
    (81) assign -> . MINUSMINUS lhs
    (82) new_array -> . NEW type expr_array_helper
    (90) literal -> . INTEGERCONSTANT
    (91) literal -> . FLOATCONSTANT
    (92) literal -> . STRINGCONSTANT
    (93) literal -> . NULL
    (94) literal -> . TRUE
    (95) literal -> . FALSE
    (106) lhs -> . field_access
    (107) lhs -> . array_access
    (111) method_invocation -> . field_access LPAREN RPAREN
    (112) method_invocation -> . field_access LPAREN arguments RPAREN
    (108) field_access -> . primary DOT IDENTIFIER
    (109) field_access -> . IDENTIFIER
    (110) array_access -> . primary LSQUARE expr RSQUARE

    NOT             shift and go to state 130
    MINUS           shift and go to state 121
    PLUS            shift and go to state 123
    THIS            shift and go to state 105
    SUPER           shift and go to state 108
    LPAREN          shift and go to state 96
    NEW             shift and go to state 120
    PLUSPLUS        shift and go to state 94
    MINUSMINUS      shift and go to state 98
    INTEGERCONSTANT shift and go to state 102
    FLOATCONSTANT   shift and go to state 100
    STRINGCONSTANT  shift and go to state 83
    NULL            shift and go to state 81
    TRUE            shift and go to state 85
    FALSE           shift and go to state 97
    IDENTIFIER      shift and go to state 125

    new_array                      shift and go to state 118
    field_access                   shift and go to state 126
    expr                           shift and go to state 185
    primary                        shift and go to state 119
    array_access                   shift and go to state 82
    literal                        shift and go to state 87
    lhs                            shift and go to state 129
    method_invocation              shift and go to state 124
    assign                         shift and go to state 128

state 158

    (65) expr -> expr NOTEQUALS . expr
    (59) expr -> . primary
    (60) expr -> . assign
    (61) expr -> . new_array
    (62) expr -> . expr OR expr
    (63) expr -> . expr AND expr
    (64) expr -> . expr EQUALS expr
    (65) expr -> . expr NOTEQUALS expr
    (66) expr -> . expr LT expr
    (67) expr -> . expr GT expr
    (68) expr -> . expr LEQ expr
    (69) expr -> . expr GEQ expr
    (70) expr -> . expr PLUS expr
    (71) expr -> . expr MINUS expr
    (72) expr -> . expr MULT expr
    (73) expr -> . expr DIV expr
    (74) expr -> . NOT expr
    (75) expr -> . MINUS expr
    (76) expr -> . PLUS expr
    (96) primary -> . literal
    (97) primary -> . THIS
    (98) primary -> . SUPER
    (99) primary -> . LPAREN expr RPAREN
    (100) primary -> . NEW IDENTIFIER LPAREN RPAREN
    (101) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (102) primary -> . lhs
    (103) primary -> . method_invocation
    (77) assign -> . lhs ASSIGN expr
    (78) assign -> . lhs PLUSPLUS
    (79) assign -> . PLUSPLUS lhs
    (80) assign -> . lhs MINUSMINUS
    (81) assign -> . MINUSMINUS lhs
    (82) new_array -> . NEW type expr_array_helper
    (90) literal -> . INTEGERCONSTANT
    (91) literal -> . FLOATCONSTANT
    (92) literal -> . STRINGCONSTANT
    (93) literal -> . NULL
    (94) literal -> . TRUE
    (95) literal -> . FALSE
    (106) lhs -> . field_access
    (107) lhs -> . array_access
    (111) method_invocation -> . field_access LPAREN RPAREN
    (112) method_invocation -> . field_access LPAREN arguments RPAREN
    (108) field_access -> . primary DOT IDENTIFIER
    (109) field_access -> . IDENTIFIER
    (110) array_access -> . primary LSQUARE expr RSQUARE

    NOT             shift and go to state 130
    MINUS           shift and go to state 121
    PLUS            shift and go to state 123
    THIS            shift and go to state 105
    SUPER           shift and go to state 108
    LPAREN          shift and go to state 96
    NEW             shift and go to state 120
    PLUSPLUS        shift and go to state 94
    MINUSMINUS      shift and go to state 98
    INTEGERCONSTANT shift and go to state 102
    FLOATCONSTANT   shift and go to state 100
    STRINGCONSTANT  shift and go to state 83
    NULL            shift and go to state 81
    TRUE            shift and go to state 85
    FALSE           shift and go to state 97
    IDENTIFIER      shift and go to state 125

    new_array                      shift and go to state 118
    field_access                   shift and go to state 126
    expr                           shift and go to state 186
    primary                        shift and go to state 119
    array_access                   shift and go to state 82
    literal                        shift and go to state 87
    lhs                            shift and go to state 129
    method_invocation              shift and go to state 124
    assign                         shift and go to state 128

state 159

    (69) expr -> expr GEQ . expr
    (59) expr -> . primary
    (60) expr -> . assign
    (61) expr -> . new_array
    (62) expr -> . expr OR expr
    (63) expr -> . expr AND expr
    (64) expr -> . expr EQUALS expr
    (65) expr -> . expr NOTEQUALS expr
    (66) expr -> . expr LT expr
    (67) expr -> . expr GT expr
    (68) expr -> . expr LEQ expr
    (69) expr -> . expr GEQ expr
    (70) expr -> . expr PLUS expr
    (71) expr -> . expr MINUS expr
    (72) expr -> . expr MULT expr
    (73) expr -> . expr DIV expr
    (74) expr -> . NOT expr
    (75) expr -> . MINUS expr
    (76) expr -> . PLUS expr
    (96) primary -> . literal
    (97) primary -> . THIS
    (98) primary -> . SUPER
    (99) primary -> . LPAREN expr RPAREN
    (100) primary -> . NEW IDENTIFIER LPAREN RPAREN
    (101) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (102) primary -> . lhs
    (103) primary -> . method_invocation
    (77) assign -> . lhs ASSIGN expr
    (78) assign -> . lhs PLUSPLUS
    (79) assign -> . PLUSPLUS lhs
    (80) assign -> . lhs MINUSMINUS
    (81) assign -> . MINUSMINUS lhs
    (82) new_array -> . NEW type expr_array_helper
    (90) literal -> . INTEGERCONSTANT
    (91) literal -> . FLOATCONSTANT
    (92) literal -> . STRINGCONSTANT
    (93) literal -> . NULL
    (94) literal -> . TRUE
    (95) literal -> . FALSE
    (106) lhs -> . field_access
    (107) lhs -> . array_access
    (111) method_invocation -> . field_access LPAREN RPAREN
    (112) method_invocation -> . field_access LPAREN arguments RPAREN
    (108) field_access -> . primary DOT IDENTIFIER
    (109) field_access -> . IDENTIFIER
    (110) array_access -> . primary LSQUARE expr RSQUARE

    NOT             shift and go to state 130
    MINUS           shift and go to state 121
    PLUS            shift and go to state 123
    THIS            shift and go to state 105
    SUPER           shift and go to state 108
    LPAREN          shift and go to state 96
    NEW             shift and go to state 120
    PLUSPLUS        shift and go to state 94
    MINUSMINUS      shift and go to state 98
    INTEGERCONSTANT shift and go to state 102
    FLOATCONSTANT   shift and go to state 100
    STRINGCONSTANT  shift and go to state 83
    NULL            shift and go to state 81
    TRUE            shift and go to state 85
    FALSE           shift and go to state 97
    IDENTIFIER      shift and go to state 125

    new_array                      shift and go to state 118
    field_access                   shift and go to state 126
    expr                           shift and go to state 187
    primary                        shift and go to state 119
    array_access                   shift and go to state 82
    literal                        shift and go to state 87
    lhs                            shift and go to state 129
    method_invocation              shift and go to state 124
    assign                         shift and go to state 128

state 160

    (67) expr -> expr GT . expr
    (59) expr -> . primary
    (60) expr -> . assign
    (61) expr -> . new_array
    (62) expr -> . expr OR expr
    (63) expr -> . expr AND expr
    (64) expr -> . expr EQUALS expr
    (65) expr -> . expr NOTEQUALS expr
    (66) expr -> . expr LT expr
    (67) expr -> . expr GT expr
    (68) expr -> . expr LEQ expr
    (69) expr -> . expr GEQ expr
    (70) expr -> . expr PLUS expr
    (71) expr -> . expr MINUS expr
    (72) expr -> . expr MULT expr
    (73) expr -> . expr DIV expr
    (74) expr -> . NOT expr
    (75) expr -> . MINUS expr
    (76) expr -> . PLUS expr
    (96) primary -> . literal
    (97) primary -> . THIS
    (98) primary -> . SUPER
    (99) primary -> . LPAREN expr RPAREN
    (100) primary -> . NEW IDENTIFIER LPAREN RPAREN
    (101) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (102) primary -> . lhs
    (103) primary -> . method_invocation
    (77) assign -> . lhs ASSIGN expr
    (78) assign -> . lhs PLUSPLUS
    (79) assign -> . PLUSPLUS lhs
    (80) assign -> . lhs MINUSMINUS
    (81) assign -> . MINUSMINUS lhs
    (82) new_array -> . NEW type expr_array_helper
    (90) literal -> . INTEGERCONSTANT
    (91) literal -> . FLOATCONSTANT
    (92) literal -> . STRINGCONSTANT
    (93) literal -> . NULL
    (94) literal -> . TRUE
    (95) literal -> . FALSE
    (106) lhs -> . field_access
    (107) lhs -> . array_access
    (111) method_invocation -> . field_access LPAREN RPAREN
    (112) method_invocation -> . field_access LPAREN arguments RPAREN
    (108) field_access -> . primary DOT IDENTIFIER
    (109) field_access -> . IDENTIFIER
    (110) array_access -> . primary LSQUARE expr RSQUARE

    NOT             shift and go to state 130
    MINUS           shift and go to state 121
    PLUS            shift and go to state 123
    THIS            shift and go to state 105
    SUPER           shift and go to state 108
    LPAREN          shift and go to state 96
    NEW             shift and go to state 120
    PLUSPLUS        shift and go to state 94
    MINUSMINUS      shift and go to state 98
    INTEGERCONSTANT shift and go to state 102
    FLOATCONSTANT   shift and go to state 100
    STRINGCONSTANT  shift and go to state 83
    NULL            shift and go to state 81
    TRUE            shift and go to state 85
    FALSE           shift and go to state 97
    IDENTIFIER      shift and go to state 125

    new_array                      shift and go to state 118
    field_access                   shift and go to state 126
    expr                           shift and go to state 188
    primary                        shift and go to state 119
    array_access                   shift and go to state 82
    literal                        shift and go to state 87
    lhs                            shift and go to state 129
    method_invocation              shift and go to state 124
    assign                         shift and go to state 128

state 161

    (54) stmt -> RETURN expr SEMICOLON .

    RCURLY          reduce using rule 54 (stmt -> RETURN expr SEMICOLON .)
    IF              reduce using rule 54 (stmt -> RETURN expr SEMICOLON .)
    WHILE           reduce using rule 54 (stmt -> RETURN expr SEMICOLON .)
    FOR             reduce using rule 54 (stmt -> RETURN expr SEMICOLON .)
    RETURN          reduce using rule 54 (stmt -> RETURN expr SEMICOLON .)
    BREAK           reduce using rule 54 (stmt -> RETURN expr SEMICOLON .)
    CONTINUE        reduce using rule 54 (stmt -> RETURN expr SEMICOLON .)
    SEMICOLON       reduce using rule 54 (stmt -> RETURN expr SEMICOLON .)
    LCURLY          reduce using rule 54 (stmt -> RETURN expr SEMICOLON .)
    INT             reduce using rule 54 (stmt -> RETURN expr SEMICOLON .)
    FLOAT           reduce using rule 54 (stmt -> RETURN expr SEMICOLON .)
    BOOLEAN         reduce using rule 54 (stmt -> RETURN expr SEMICOLON .)
    IDENTIFIER      reduce using rule 54 (stmt -> RETURN expr SEMICOLON .)
    PLUSPLUS        reduce using rule 54 (stmt -> RETURN expr SEMICOLON .)
    MINUSMINUS      reduce using rule 54 (stmt -> RETURN expr SEMICOLON .)
    THIS            reduce using rule 54 (stmt -> RETURN expr SEMICOLON .)
    SUPER           reduce using rule 54 (stmt -> RETURN expr SEMICOLON .)
    LPAREN          reduce using rule 54 (stmt -> RETURN expr SEMICOLON .)
    NEW             reduce using rule 54 (stmt -> RETURN expr SEMICOLON .)
    INTEGERCONSTANT reduce using rule 54 (stmt -> RETURN expr SEMICOLON .)
    FLOATCONSTANT   reduce using rule 54 (stmt -> RETURN expr SEMICOLON .)
    STRINGCONSTANT  reduce using rule 54 (stmt -> RETURN expr SEMICOLON .)
    NULL            reduce using rule 54 (stmt -> RETURN expr SEMICOLON .)
    TRUE            reduce using rule 54 (stmt -> RETURN expr SEMICOLON .)
    FALSE           reduce using rule 54 (stmt -> RETURN expr SEMICOLON .)
    ELSE            reduce using rule 54 (stmt -> RETURN expr SEMICOLON .)


state 162

    (64) expr -> expr EQUALS . expr
    (59) expr -> . primary
    (60) expr -> . assign
    (61) expr -> . new_array
    (62) expr -> . expr OR expr
    (63) expr -> . expr AND expr
    (64) expr -> . expr EQUALS expr
    (65) expr -> . expr NOTEQUALS expr
    (66) expr -> . expr LT expr
    (67) expr -> . expr GT expr
    (68) expr -> . expr LEQ expr
    (69) expr -> . expr GEQ expr
    (70) expr -> . expr PLUS expr
    (71) expr -> . expr MINUS expr
    (72) expr -> . expr MULT expr
    (73) expr -> . expr DIV expr
    (74) expr -> . NOT expr
    (75) expr -> . MINUS expr
    (76) expr -> . PLUS expr
    (96) primary -> . literal
    (97) primary -> . THIS
    (98) primary -> . SUPER
    (99) primary -> . LPAREN expr RPAREN
    (100) primary -> . NEW IDENTIFIER LPAREN RPAREN
    (101) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (102) primary -> . lhs
    (103) primary -> . method_invocation
    (77) assign -> . lhs ASSIGN expr
    (78) assign -> . lhs PLUSPLUS
    (79) assign -> . PLUSPLUS lhs
    (80) assign -> . lhs MINUSMINUS
    (81) assign -> . MINUSMINUS lhs
    (82) new_array -> . NEW type expr_array_helper
    (90) literal -> . INTEGERCONSTANT
    (91) literal -> . FLOATCONSTANT
    (92) literal -> . STRINGCONSTANT
    (93) literal -> . NULL
    (94) literal -> . TRUE
    (95) literal -> . FALSE
    (106) lhs -> . field_access
    (107) lhs -> . array_access
    (111) method_invocation -> . field_access LPAREN RPAREN
    (112) method_invocation -> . field_access LPAREN arguments RPAREN
    (108) field_access -> . primary DOT IDENTIFIER
    (109) field_access -> . IDENTIFIER
    (110) array_access -> . primary LSQUARE expr RSQUARE

    NOT             shift and go to state 130
    MINUS           shift and go to state 121
    PLUS            shift and go to state 123
    THIS            shift and go to state 105
    SUPER           shift and go to state 108
    LPAREN          shift and go to state 96
    NEW             shift and go to state 120
    PLUSPLUS        shift and go to state 94
    MINUSMINUS      shift and go to state 98
    INTEGERCONSTANT shift and go to state 102
    FLOATCONSTANT   shift and go to state 100
    STRINGCONSTANT  shift and go to state 83
    NULL            shift and go to state 81
    TRUE            shift and go to state 85
    FALSE           shift and go to state 97
    IDENTIFIER      shift and go to state 125

    new_array                      shift and go to state 118
    field_access                   shift and go to state 126
    expr                           shift and go to state 189
    primary                        shift and go to state 119
    array_access                   shift and go to state 82
    literal                        shift and go to state 87
    lhs                            shift and go to state 129
    method_invocation              shift and go to state 124
    assign                         shift and go to state 128

state 163

    (71) expr -> expr MINUS . expr
    (59) expr -> . primary
    (60) expr -> . assign
    (61) expr -> . new_array
    (62) expr -> . expr OR expr
    (63) expr -> . expr AND expr
    (64) expr -> . expr EQUALS expr
    (65) expr -> . expr NOTEQUALS expr
    (66) expr -> . expr LT expr
    (67) expr -> . expr GT expr
    (68) expr -> . expr LEQ expr
    (69) expr -> . expr GEQ expr
    (70) expr -> . expr PLUS expr
    (71) expr -> . expr MINUS expr
    (72) expr -> . expr MULT expr
    (73) expr -> . expr DIV expr
    (74) expr -> . NOT expr
    (75) expr -> . MINUS expr
    (76) expr -> . PLUS expr
    (96) primary -> . literal
    (97) primary -> . THIS
    (98) primary -> . SUPER
    (99) primary -> . LPAREN expr RPAREN
    (100) primary -> . NEW IDENTIFIER LPAREN RPAREN
    (101) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (102) primary -> . lhs
    (103) primary -> . method_invocation
    (77) assign -> . lhs ASSIGN expr
    (78) assign -> . lhs PLUSPLUS
    (79) assign -> . PLUSPLUS lhs
    (80) assign -> . lhs MINUSMINUS
    (81) assign -> . MINUSMINUS lhs
    (82) new_array -> . NEW type expr_array_helper
    (90) literal -> . INTEGERCONSTANT
    (91) literal -> . FLOATCONSTANT
    (92) literal -> . STRINGCONSTANT
    (93) literal -> . NULL
    (94) literal -> . TRUE
    (95) literal -> . FALSE
    (106) lhs -> . field_access
    (107) lhs -> . array_access
    (111) method_invocation -> . field_access LPAREN RPAREN
    (112) method_invocation -> . field_access LPAREN arguments RPAREN
    (108) field_access -> . primary DOT IDENTIFIER
    (109) field_access -> . IDENTIFIER
    (110) array_access -> . primary LSQUARE expr RSQUARE

    NOT             shift and go to state 130
    MINUS           shift and go to state 121
    PLUS            shift and go to state 123
    THIS            shift and go to state 105
    SUPER           shift and go to state 108
    LPAREN          shift and go to state 96
    NEW             shift and go to state 120
    PLUSPLUS        shift and go to state 94
    MINUSMINUS      shift and go to state 98
    INTEGERCONSTANT shift and go to state 102
    FLOATCONSTANT   shift and go to state 100
    STRINGCONSTANT  shift and go to state 83
    NULL            shift and go to state 81
    TRUE            shift and go to state 85
    FALSE           shift and go to state 97
    IDENTIFIER      shift and go to state 125

    new_array                      shift and go to state 118
    field_access                   shift and go to state 126
    expr                           shift and go to state 190
    primary                        shift and go to state 119
    array_access                   shift and go to state 82
    literal                        shift and go to state 87
    lhs                            shift and go to state 129
    method_invocation              shift and go to state 124
    assign                         shift and go to state 128

state 164

    (68) expr -> expr LEQ . expr
    (59) expr -> . primary
    (60) expr -> . assign
    (61) expr -> . new_array
    (62) expr -> . expr OR expr
    (63) expr -> . expr AND expr
    (64) expr -> . expr EQUALS expr
    (65) expr -> . expr NOTEQUALS expr
    (66) expr -> . expr LT expr
    (67) expr -> . expr GT expr
    (68) expr -> . expr LEQ expr
    (69) expr -> . expr GEQ expr
    (70) expr -> . expr PLUS expr
    (71) expr -> . expr MINUS expr
    (72) expr -> . expr MULT expr
    (73) expr -> . expr DIV expr
    (74) expr -> . NOT expr
    (75) expr -> . MINUS expr
    (76) expr -> . PLUS expr
    (96) primary -> . literal
    (97) primary -> . THIS
    (98) primary -> . SUPER
    (99) primary -> . LPAREN expr RPAREN
    (100) primary -> . NEW IDENTIFIER LPAREN RPAREN
    (101) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (102) primary -> . lhs
    (103) primary -> . method_invocation
    (77) assign -> . lhs ASSIGN expr
    (78) assign -> . lhs PLUSPLUS
    (79) assign -> . PLUSPLUS lhs
    (80) assign -> . lhs MINUSMINUS
    (81) assign -> . MINUSMINUS lhs
    (82) new_array -> . NEW type expr_array_helper
    (90) literal -> . INTEGERCONSTANT
    (91) literal -> . FLOATCONSTANT
    (92) literal -> . STRINGCONSTANT
    (93) literal -> . NULL
    (94) literal -> . TRUE
    (95) literal -> . FALSE
    (106) lhs -> . field_access
    (107) lhs -> . array_access
    (111) method_invocation -> . field_access LPAREN RPAREN
    (112) method_invocation -> . field_access LPAREN arguments RPAREN
    (108) field_access -> . primary DOT IDENTIFIER
    (109) field_access -> . IDENTIFIER
    (110) array_access -> . primary LSQUARE expr RSQUARE

    NOT             shift and go to state 130
    MINUS           shift and go to state 121
    PLUS            shift and go to state 123
    THIS            shift and go to state 105
    SUPER           shift and go to state 108
    LPAREN          shift and go to state 96
    NEW             shift and go to state 120
    PLUSPLUS        shift and go to state 94
    MINUSMINUS      shift and go to state 98
    INTEGERCONSTANT shift and go to state 102
    FLOATCONSTANT   shift and go to state 100
    STRINGCONSTANT  shift and go to state 83
    NULL            shift and go to state 81
    TRUE            shift and go to state 85
    FALSE           shift and go to state 97
    IDENTIFIER      shift and go to state 125

    new_array                      shift and go to state 118
    field_access                   shift and go to state 126
    expr                           shift and go to state 191
    primary                        shift and go to state 119
    array_access                   shift and go to state 82
    literal                        shift and go to state 87
    lhs                            shift and go to state 129
    method_invocation              shift and go to state 124
    assign                         shift and go to state 128

state 165

    (66) expr -> expr LT . expr
    (59) expr -> . primary
    (60) expr -> . assign
    (61) expr -> . new_array
    (62) expr -> . expr OR expr
    (63) expr -> . expr AND expr
    (64) expr -> . expr EQUALS expr
    (65) expr -> . expr NOTEQUALS expr
    (66) expr -> . expr LT expr
    (67) expr -> . expr GT expr
    (68) expr -> . expr LEQ expr
    (69) expr -> . expr GEQ expr
    (70) expr -> . expr PLUS expr
    (71) expr -> . expr MINUS expr
    (72) expr -> . expr MULT expr
    (73) expr -> . expr DIV expr
    (74) expr -> . NOT expr
    (75) expr -> . MINUS expr
    (76) expr -> . PLUS expr
    (96) primary -> . literal
    (97) primary -> . THIS
    (98) primary -> . SUPER
    (99) primary -> . LPAREN expr RPAREN
    (100) primary -> . NEW IDENTIFIER LPAREN RPAREN
    (101) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (102) primary -> . lhs
    (103) primary -> . method_invocation
    (77) assign -> . lhs ASSIGN expr
    (78) assign -> . lhs PLUSPLUS
    (79) assign -> . PLUSPLUS lhs
    (80) assign -> . lhs MINUSMINUS
    (81) assign -> . MINUSMINUS lhs
    (82) new_array -> . NEW type expr_array_helper
    (90) literal -> . INTEGERCONSTANT
    (91) literal -> . FLOATCONSTANT
    (92) literal -> . STRINGCONSTANT
    (93) literal -> . NULL
    (94) literal -> . TRUE
    (95) literal -> . FALSE
    (106) lhs -> . field_access
    (107) lhs -> . array_access
    (111) method_invocation -> . field_access LPAREN RPAREN
    (112) method_invocation -> . field_access LPAREN arguments RPAREN
    (108) field_access -> . primary DOT IDENTIFIER
    (109) field_access -> . IDENTIFIER
    (110) array_access -> . primary LSQUARE expr RSQUARE

    NOT             shift and go to state 130
    MINUS           shift and go to state 121
    PLUS            shift and go to state 123
    THIS            shift and go to state 105
    SUPER           shift and go to state 108
    LPAREN          shift and go to state 96
    NEW             shift and go to state 120
    PLUSPLUS        shift and go to state 94
    MINUSMINUS      shift and go to state 98
    INTEGERCONSTANT shift and go to state 102
    FLOATCONSTANT   shift and go to state 100
    STRINGCONSTANT  shift and go to state 83
    NULL            shift and go to state 81
    TRUE            shift and go to state 85
    FALSE           shift and go to state 97
    IDENTIFIER      shift and go to state 125

    new_array                      shift and go to state 118
    field_access                   shift and go to state 126
    expr                           shift and go to state 192
    primary                        shift and go to state 119
    array_access                   shift and go to state 82
    literal                        shift and go to state 87
    lhs                            shift and go to state 129
    method_invocation              shift and go to state 124
    assign                         shift and go to state 128

state 166

    (70) expr -> expr PLUS . expr
    (59) expr -> . primary
    (60) expr -> . assign
    (61) expr -> . new_array
    (62) expr -> . expr OR expr
    (63) expr -> . expr AND expr
    (64) expr -> . expr EQUALS expr
    (65) expr -> . expr NOTEQUALS expr
    (66) expr -> . expr LT expr
    (67) expr -> . expr GT expr
    (68) expr -> . expr LEQ expr
    (69) expr -> . expr GEQ expr
    (70) expr -> . expr PLUS expr
    (71) expr -> . expr MINUS expr
    (72) expr -> . expr MULT expr
    (73) expr -> . expr DIV expr
    (74) expr -> . NOT expr
    (75) expr -> . MINUS expr
    (76) expr -> . PLUS expr
    (96) primary -> . literal
    (97) primary -> . THIS
    (98) primary -> . SUPER
    (99) primary -> . LPAREN expr RPAREN
    (100) primary -> . NEW IDENTIFIER LPAREN RPAREN
    (101) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (102) primary -> . lhs
    (103) primary -> . method_invocation
    (77) assign -> . lhs ASSIGN expr
    (78) assign -> . lhs PLUSPLUS
    (79) assign -> . PLUSPLUS lhs
    (80) assign -> . lhs MINUSMINUS
    (81) assign -> . MINUSMINUS lhs
    (82) new_array -> . NEW type expr_array_helper
    (90) literal -> . INTEGERCONSTANT
    (91) literal -> . FLOATCONSTANT
    (92) literal -> . STRINGCONSTANT
    (93) literal -> . NULL
    (94) literal -> . TRUE
    (95) literal -> . FALSE
    (106) lhs -> . field_access
    (107) lhs -> . array_access
    (111) method_invocation -> . field_access LPAREN RPAREN
    (112) method_invocation -> . field_access LPAREN arguments RPAREN
    (108) field_access -> . primary DOT IDENTIFIER
    (109) field_access -> . IDENTIFIER
    (110) array_access -> . primary LSQUARE expr RSQUARE

    NOT             shift and go to state 130
    MINUS           shift and go to state 121
    PLUS            shift and go to state 123
    THIS            shift and go to state 105
    SUPER           shift and go to state 108
    LPAREN          shift and go to state 96
    NEW             shift and go to state 120
    PLUSPLUS        shift and go to state 94
    MINUSMINUS      shift and go to state 98
    INTEGERCONSTANT shift and go to state 102
    FLOATCONSTANT   shift and go to state 100
    STRINGCONSTANT  shift and go to state 83
    NULL            shift and go to state 81
    TRUE            shift and go to state 85
    FALSE           shift and go to state 97
    IDENTIFIER      shift and go to state 125

    new_array                      shift and go to state 118
    field_access                   shift and go to state 126
    expr                           shift and go to state 193
    primary                        shift and go to state 119
    array_access                   shift and go to state 82
    literal                        shift and go to state 87
    lhs                            shift and go to state 129
    method_invocation              shift and go to state 124
    assign                         shift and go to state 128

state 167

    (73) expr -> expr DIV . expr
    (59) expr -> . primary
    (60) expr -> . assign
    (61) expr -> . new_array
    (62) expr -> . expr OR expr
    (63) expr -> . expr AND expr
    (64) expr -> . expr EQUALS expr
    (65) expr -> . expr NOTEQUALS expr
    (66) expr -> . expr LT expr
    (67) expr -> . expr GT expr
    (68) expr -> . expr LEQ expr
    (69) expr -> . expr GEQ expr
    (70) expr -> . expr PLUS expr
    (71) expr -> . expr MINUS expr
    (72) expr -> . expr MULT expr
    (73) expr -> . expr DIV expr
    (74) expr -> . NOT expr
    (75) expr -> . MINUS expr
    (76) expr -> . PLUS expr
    (96) primary -> . literal
    (97) primary -> . THIS
    (98) primary -> . SUPER
    (99) primary -> . LPAREN expr RPAREN
    (100) primary -> . NEW IDENTIFIER LPAREN RPAREN
    (101) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (102) primary -> . lhs
    (103) primary -> . method_invocation
    (77) assign -> . lhs ASSIGN expr
    (78) assign -> . lhs PLUSPLUS
    (79) assign -> . PLUSPLUS lhs
    (80) assign -> . lhs MINUSMINUS
    (81) assign -> . MINUSMINUS lhs
    (82) new_array -> . NEW type expr_array_helper
    (90) literal -> . INTEGERCONSTANT
    (91) literal -> . FLOATCONSTANT
    (92) literal -> . STRINGCONSTANT
    (93) literal -> . NULL
    (94) literal -> . TRUE
    (95) literal -> . FALSE
    (106) lhs -> . field_access
    (107) lhs -> . array_access
    (111) method_invocation -> . field_access LPAREN RPAREN
    (112) method_invocation -> . field_access LPAREN arguments RPAREN
    (108) field_access -> . primary DOT IDENTIFIER
    (109) field_access -> . IDENTIFIER
    (110) array_access -> . primary LSQUARE expr RSQUARE

    NOT             shift and go to state 130
    MINUS           shift and go to state 121
    PLUS            shift and go to state 123
    THIS            shift and go to state 105
    SUPER           shift and go to state 108
    LPAREN          shift and go to state 96
    NEW             shift and go to state 120
    PLUSPLUS        shift and go to state 94
    MINUSMINUS      shift and go to state 98
    INTEGERCONSTANT shift and go to state 102
    FLOATCONSTANT   shift and go to state 100
    STRINGCONSTANT  shift and go to state 83
    NULL            shift and go to state 81
    TRUE            shift and go to state 85
    FALSE           shift and go to state 97
    IDENTIFIER      shift and go to state 125

    new_array                      shift and go to state 118
    field_access                   shift and go to state 126
    expr                           shift and go to state 194
    primary                        shift and go to state 119
    array_access                   shift and go to state 82
    literal                        shift and go to state 87
    lhs                            shift and go to state 129
    method_invocation              shift and go to state 124
    assign                         shift and go to state 128

state 168

    (62) expr -> expr OR . expr
    (59) expr -> . primary
    (60) expr -> . assign
    (61) expr -> . new_array
    (62) expr -> . expr OR expr
    (63) expr -> . expr AND expr
    (64) expr -> . expr EQUALS expr
    (65) expr -> . expr NOTEQUALS expr
    (66) expr -> . expr LT expr
    (67) expr -> . expr GT expr
    (68) expr -> . expr LEQ expr
    (69) expr -> . expr GEQ expr
    (70) expr -> . expr PLUS expr
    (71) expr -> . expr MINUS expr
    (72) expr -> . expr MULT expr
    (73) expr -> . expr DIV expr
    (74) expr -> . NOT expr
    (75) expr -> . MINUS expr
    (76) expr -> . PLUS expr
    (96) primary -> . literal
    (97) primary -> . THIS
    (98) primary -> . SUPER
    (99) primary -> . LPAREN expr RPAREN
    (100) primary -> . NEW IDENTIFIER LPAREN RPAREN
    (101) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (102) primary -> . lhs
    (103) primary -> . method_invocation
    (77) assign -> . lhs ASSIGN expr
    (78) assign -> . lhs PLUSPLUS
    (79) assign -> . PLUSPLUS lhs
    (80) assign -> . lhs MINUSMINUS
    (81) assign -> . MINUSMINUS lhs
    (82) new_array -> . NEW type expr_array_helper
    (90) literal -> . INTEGERCONSTANT
    (91) literal -> . FLOATCONSTANT
    (92) literal -> . STRINGCONSTANT
    (93) literal -> . NULL
    (94) literal -> . TRUE
    (95) literal -> . FALSE
    (106) lhs -> . field_access
    (107) lhs -> . array_access
    (111) method_invocation -> . field_access LPAREN RPAREN
    (112) method_invocation -> . field_access LPAREN arguments RPAREN
    (108) field_access -> . primary DOT IDENTIFIER
    (109) field_access -> . IDENTIFIER
    (110) array_access -> . primary LSQUARE expr RSQUARE

    NOT             shift and go to state 130
    MINUS           shift and go to state 121
    PLUS            shift and go to state 123
    THIS            shift and go to state 105
    SUPER           shift and go to state 108
    LPAREN          shift and go to state 96
    NEW             shift and go to state 120
    PLUSPLUS        shift and go to state 94
    MINUSMINUS      shift and go to state 98
    INTEGERCONSTANT shift and go to state 102
    FLOATCONSTANT   shift and go to state 100
    STRINGCONSTANT  shift and go to state 83
    NULL            shift and go to state 81
    TRUE            shift and go to state 85
    FALSE           shift and go to state 97
    IDENTIFIER      shift and go to state 125

    new_array                      shift and go to state 118
    field_access                   shift and go to state 126
    expr                           shift and go to state 195
    primary                        shift and go to state 119
    array_access                   shift and go to state 82
    literal                        shift and go to state 87
    lhs                            shift and go to state 129
    method_invocation              shift and go to state 124
    assign                         shift and go to state 128

state 169

    (72) expr -> expr MULT . expr
    (59) expr -> . primary
    (60) expr -> . assign
    (61) expr -> . new_array
    (62) expr -> . expr OR expr
    (63) expr -> . expr AND expr
    (64) expr -> . expr EQUALS expr
    (65) expr -> . expr NOTEQUALS expr
    (66) expr -> . expr LT expr
    (67) expr -> . expr GT expr
    (68) expr -> . expr LEQ expr
    (69) expr -> . expr GEQ expr
    (70) expr -> . expr PLUS expr
    (71) expr -> . expr MINUS expr
    (72) expr -> . expr MULT expr
    (73) expr -> . expr DIV expr
    (74) expr -> . NOT expr
    (75) expr -> . MINUS expr
    (76) expr -> . PLUS expr
    (96) primary -> . literal
    (97) primary -> . THIS
    (98) primary -> . SUPER
    (99) primary -> . LPAREN expr RPAREN
    (100) primary -> . NEW IDENTIFIER LPAREN RPAREN
    (101) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (102) primary -> . lhs
    (103) primary -> . method_invocation
    (77) assign -> . lhs ASSIGN expr
    (78) assign -> . lhs PLUSPLUS
    (79) assign -> . PLUSPLUS lhs
    (80) assign -> . lhs MINUSMINUS
    (81) assign -> . MINUSMINUS lhs
    (82) new_array -> . NEW type expr_array_helper
    (90) literal -> . INTEGERCONSTANT
    (91) literal -> . FLOATCONSTANT
    (92) literal -> . STRINGCONSTANT
    (93) literal -> . NULL
    (94) literal -> . TRUE
    (95) literal -> . FALSE
    (106) lhs -> . field_access
    (107) lhs -> . array_access
    (111) method_invocation -> . field_access LPAREN RPAREN
    (112) method_invocation -> . field_access LPAREN arguments RPAREN
    (108) field_access -> . primary DOT IDENTIFIER
    (109) field_access -> . IDENTIFIER
    (110) array_access -> . primary LSQUARE expr RSQUARE

    NOT             shift and go to state 130
    MINUS           shift and go to state 121
    PLUS            shift and go to state 123
    THIS            shift and go to state 105
    SUPER           shift and go to state 108
    LPAREN          shift and go to state 96
    NEW             shift and go to state 120
    PLUSPLUS        shift and go to state 94
    MINUSMINUS      shift and go to state 98
    INTEGERCONSTANT shift and go to state 102
    FLOATCONSTANT   shift and go to state 100
    STRINGCONSTANT  shift and go to state 83
    NULL            shift and go to state 81
    TRUE            shift and go to state 85
    FALSE           shift and go to state 97
    IDENTIFIER      shift and go to state 125

    new_array                      shift and go to state 118
    field_access                   shift and go to state 126
    expr                           shift and go to state 196
    primary                        shift and go to state 119
    array_access                   shift and go to state 82
    literal                        shift and go to state 87
    lhs                            shift and go to state 129
    method_invocation              shift and go to state 124
    assign                         shift and go to state 128

state 170

    (74) expr -> NOT expr .
    (62) expr -> expr . OR expr
    (63) expr -> expr . AND expr
    (64) expr -> expr . EQUALS expr
    (65) expr -> expr . NOTEQUALS expr
    (66) expr -> expr . LT expr
    (67) expr -> expr . GT expr
    (68) expr -> expr . LEQ expr
    (69) expr -> expr . GEQ expr
    (70) expr -> expr . PLUS expr
    (71) expr -> expr . MINUS expr
    (72) expr -> expr . MULT expr
    (73) expr -> expr . DIV expr

    OR              reduce using rule 74 (expr -> NOT expr .)
    AND             reduce using rule 74 (expr -> NOT expr .)
    EQUALS          reduce using rule 74 (expr -> NOT expr .)
    NOTEQUALS       reduce using rule 74 (expr -> NOT expr .)
    LT              reduce using rule 74 (expr -> NOT expr .)
    GT              reduce using rule 74 (expr -> NOT expr .)
    LEQ             reduce using rule 74 (expr -> NOT expr .)
    GEQ             reduce using rule 74 (expr -> NOT expr .)
    PLUS            reduce using rule 74 (expr -> NOT expr .)
    MINUS           reduce using rule 74 (expr -> NOT expr .)
    MULT            reduce using rule 74 (expr -> NOT expr .)
    DIV             reduce using rule 74 (expr -> NOT expr .)
    RPAREN          reduce using rule 74 (expr -> NOT expr .)
    COMMA           reduce using rule 74 (expr -> NOT expr .)
    SEMICOLON       reduce using rule 74 (expr -> NOT expr .)
    RSQUARE         reduce using rule 74 (expr -> NOT expr .)

  ! OR              [ shift and go to state 168 ]
  ! AND             [ shift and go to state 157 ]
  ! EQUALS          [ shift and go to state 162 ]
  ! NOTEQUALS       [ shift and go to state 158 ]
  ! LT              [ shift and go to state 165 ]
  ! GT              [ shift and go to state 160 ]
  ! LEQ             [ shift and go to state 164 ]
  ! GEQ             [ shift and go to state 159 ]
  ! PLUS            [ shift and go to state 166 ]
  ! MINUS           [ shift and go to state 163 ]
  ! MULT            [ shift and go to state 169 ]
  ! DIV             [ shift and go to state 167 ]


state 171

    (110) array_access -> primary LSQUARE expr . RSQUARE
    (62) expr -> expr . OR expr
    (63) expr -> expr . AND expr
    (64) expr -> expr . EQUALS expr
    (65) expr -> expr . NOTEQUALS expr
    (66) expr -> expr . LT expr
    (67) expr -> expr . GT expr
    (68) expr -> expr . LEQ expr
    (69) expr -> expr . GEQ expr
    (70) expr -> expr . PLUS expr
    (71) expr -> expr . MINUS expr
    (72) expr -> expr . MULT expr
    (73) expr -> expr . DIV expr

    RSQUARE         shift and go to state 197
    OR              shift and go to state 168
    AND             shift and go to state 157
    EQUALS          shift and go to state 162
    NOTEQUALS       shift and go to state 158
    LT              shift and go to state 165
    GT              shift and go to state 160
    LEQ             shift and go to state 164
    GEQ             shift and go to state 159
    PLUS            shift and go to state 166
    MINUS           shift and go to state 163
    MULT            shift and go to state 169
    DIV             shift and go to state 167


state 172

    (108) field_access -> primary DOT IDENTIFIER .

    LPAREN          reduce using rule 108 (field_access -> primary DOT IDENTIFIER .)
    ASSIGN          reduce using rule 108 (field_access -> primary DOT IDENTIFIER .)
    PLUSPLUS        reduce using rule 108 (field_access -> primary DOT IDENTIFIER .)
    MINUSMINUS      reduce using rule 108 (field_access -> primary DOT IDENTIFIER .)
    DOT             reduce using rule 108 (field_access -> primary DOT IDENTIFIER .)
    LSQUARE         reduce using rule 108 (field_access -> primary DOT IDENTIFIER .)
    OR              reduce using rule 108 (field_access -> primary DOT IDENTIFIER .)
    AND             reduce using rule 108 (field_access -> primary DOT IDENTIFIER .)
    EQUALS          reduce using rule 108 (field_access -> primary DOT IDENTIFIER .)
    NOTEQUALS       reduce using rule 108 (field_access -> primary DOT IDENTIFIER .)
    LT              reduce using rule 108 (field_access -> primary DOT IDENTIFIER .)
    GT              reduce using rule 108 (field_access -> primary DOT IDENTIFIER .)
    LEQ             reduce using rule 108 (field_access -> primary DOT IDENTIFIER .)
    GEQ             reduce using rule 108 (field_access -> primary DOT IDENTIFIER .)
    PLUS            reduce using rule 108 (field_access -> primary DOT IDENTIFIER .)
    MINUS           reduce using rule 108 (field_access -> primary DOT IDENTIFIER .)
    MULT            reduce using rule 108 (field_access -> primary DOT IDENTIFIER .)
    DIV             reduce using rule 108 (field_access -> primary DOT IDENTIFIER .)
    SEMICOLON       reduce using rule 108 (field_access -> primary DOT IDENTIFIER .)
    RPAREN          reduce using rule 108 (field_access -> primary DOT IDENTIFIER .)
    RSQUARE         reduce using rule 108 (field_access -> primary DOT IDENTIFIER .)
    COMMA           reduce using rule 108 (field_access -> primary DOT IDENTIFIER .)


state 173

    (42) stmt -> WHILE LPAREN expr . RPAREN stmt
    (62) expr -> expr . OR expr
    (63) expr -> expr . AND expr
    (64) expr -> expr . EQUALS expr
    (65) expr -> expr . NOTEQUALS expr
    (66) expr -> expr . LT expr
    (67) expr -> expr . GT expr
    (68) expr -> expr . LEQ expr
    (69) expr -> expr . GEQ expr
    (70) expr -> expr . PLUS expr
    (71) expr -> expr . MINUS expr
    (72) expr -> expr . MULT expr
    (73) expr -> expr . DIV expr

    RPAREN          shift and go to state 198
    OR              shift and go to state 168
    AND             shift and go to state 157
    EQUALS          shift and go to state 162
    NOTEQUALS       shift and go to state 158
    LT              shift and go to state 165
    GT              shift and go to state 160
    LEQ             shift and go to state 164
    GEQ             shift and go to state 159
    PLUS            shift and go to state 166
    MINUS           shift and go to state 163
    MULT            shift and go to state 169
    DIV             shift and go to state 167


state 174

    (100) primary -> NEW IDENTIFIER LPAREN . RPAREN
    (101) primary -> NEW IDENTIFIER LPAREN . arguments RPAREN
    (104) arguments -> . expr
    (105) arguments -> . arguments COMMA expr
    (59) expr -> . primary
    (60) expr -> . assign
    (61) expr -> . new_array
    (62) expr -> . expr OR expr
    (63) expr -> . expr AND expr
    (64) expr -> . expr EQUALS expr
    (65) expr -> . expr NOTEQUALS expr
    (66) expr -> . expr LT expr
    (67) expr -> . expr GT expr
    (68) expr -> . expr LEQ expr
    (69) expr -> . expr GEQ expr
    (70) expr -> . expr PLUS expr
    (71) expr -> . expr MINUS expr
    (72) expr -> . expr MULT expr
    (73) expr -> . expr DIV expr
    (74) expr -> . NOT expr
    (75) expr -> . MINUS expr
    (76) expr -> . PLUS expr
    (96) primary -> . literal
    (97) primary -> . THIS
    (98) primary -> . SUPER
    (99) primary -> . LPAREN expr RPAREN
    (100) primary -> . NEW IDENTIFIER LPAREN RPAREN
    (101) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (102) primary -> . lhs
    (103) primary -> . method_invocation
    (77) assign -> . lhs ASSIGN expr
    (78) assign -> . lhs PLUSPLUS
    (79) assign -> . PLUSPLUS lhs
    (80) assign -> . lhs MINUSMINUS
    (81) assign -> . MINUSMINUS lhs
    (82) new_array -> . NEW type expr_array_helper
    (90) literal -> . INTEGERCONSTANT
    (91) literal -> . FLOATCONSTANT
    (92) literal -> . STRINGCONSTANT
    (93) literal -> . NULL
    (94) literal -> . TRUE
    (95) literal -> . FALSE
    (106) lhs -> . field_access
    (107) lhs -> . array_access
    (111) method_invocation -> . field_access LPAREN RPAREN
    (112) method_invocation -> . field_access LPAREN arguments RPAREN
    (108) field_access -> . primary DOT IDENTIFIER
    (109) field_access -> . IDENTIFIER
    (110) array_access -> . primary LSQUARE expr RSQUARE

    RPAREN          shift and go to state 199
    NOT             shift and go to state 130
    MINUS           shift and go to state 121
    PLUS            shift and go to state 123
    THIS            shift and go to state 105
    SUPER           shift and go to state 108
    LPAREN          shift and go to state 96
    NEW             shift and go to state 120
    PLUSPLUS        shift and go to state 94
    MINUSMINUS      shift and go to state 98
    INTEGERCONSTANT shift and go to state 102
    FLOATCONSTANT   shift and go to state 100
    STRINGCONSTANT  shift and go to state 83
    NULL            shift and go to state 81
    TRUE            shift and go to state 85
    FALSE           shift and go to state 97
    IDENTIFIER      shift and go to state 125

    new_array                      shift and go to state 118
    field_access                   shift and go to state 126
    expr                           shift and go to state 177
    primary                        shift and go to state 119
    array_access                   shift and go to state 82
    literal                        shift and go to state 87
    lhs                            shift and go to state 129
    arguments                      shift and go to state 200
    method_invocation              shift and go to state 124
    assign                         shift and go to state 128

state 175

    (111) method_invocation -> field_access LPAREN RPAREN .

    SEMICOLON       reduce using rule 111 (method_invocation -> field_access LPAREN RPAREN .)
    DOT             reduce using rule 111 (method_invocation -> field_access LPAREN RPAREN .)
    LSQUARE         reduce using rule 111 (method_invocation -> field_access LPAREN RPAREN .)
    RSQUARE         reduce using rule 111 (method_invocation -> field_access LPAREN RPAREN .)
    OR              reduce using rule 111 (method_invocation -> field_access LPAREN RPAREN .)
    AND             reduce using rule 111 (method_invocation -> field_access LPAREN RPAREN .)
    EQUALS          reduce using rule 111 (method_invocation -> field_access LPAREN RPAREN .)
    NOTEQUALS       reduce using rule 111 (method_invocation -> field_access LPAREN RPAREN .)
    LT              reduce using rule 111 (method_invocation -> field_access LPAREN RPAREN .)
    GT              reduce using rule 111 (method_invocation -> field_access LPAREN RPAREN .)
    LEQ             reduce using rule 111 (method_invocation -> field_access LPAREN RPAREN .)
    GEQ             reduce using rule 111 (method_invocation -> field_access LPAREN RPAREN .)
    PLUS            reduce using rule 111 (method_invocation -> field_access LPAREN RPAREN .)
    MINUS           reduce using rule 111 (method_invocation -> field_access LPAREN RPAREN .)
    MULT            reduce using rule 111 (method_invocation -> field_access LPAREN RPAREN .)
    DIV             reduce using rule 111 (method_invocation -> field_access LPAREN RPAREN .)
    RPAREN          reduce using rule 111 (method_invocation -> field_access LPAREN RPAREN .)
    COMMA           reduce using rule 111 (method_invocation -> field_access LPAREN RPAREN .)


state 176

    (112) method_invocation -> field_access LPAREN arguments . RPAREN
    (105) arguments -> arguments . COMMA expr

    RPAREN          shift and go to state 201
    COMMA           shift and go to state 202


state 177

    (104) arguments -> expr .
    (62) expr -> expr . OR expr
    (63) expr -> expr . AND expr
    (64) expr -> expr . EQUALS expr
    (65) expr -> expr . NOTEQUALS expr
    (66) expr -> expr . LT expr
    (67) expr -> expr . GT expr
    (68) expr -> expr . LEQ expr
    (69) expr -> expr . GEQ expr
    (70) expr -> expr . PLUS expr
    (71) expr -> expr . MINUS expr
    (72) expr -> expr . MULT expr
    (73) expr -> expr . DIV expr

    RPAREN          reduce using rule 104 (arguments -> expr .)
    COMMA           reduce using rule 104 (arguments -> expr .)
    OR              shift and go to state 168
    AND             shift and go to state 157
    EQUALS          shift and go to state 162
    NOTEQUALS       shift and go to state 158
    LT              shift and go to state 165
    GT              shift and go to state 160
    LEQ             shift and go to state 164
    GEQ             shift and go to state 159
    PLUS            shift and go to state 166
    MINUS           shift and go to state 163
    MULT            shift and go to state 169
    DIV             shift and go to state 167


state 178

    (43) stmt -> FOR LPAREN SEMICOLON . SEMICOLON RPAREN stmt
    (48) stmt -> FOR LPAREN SEMICOLON . expr SEMICOLON RPAREN stmt
    (49) stmt -> FOR LPAREN SEMICOLON . expr SEMICOLON stmt_expr RPAREN stmt
    (50) stmt -> FOR LPAREN SEMICOLON . SEMICOLON stmt_expr RPAREN stmt
    (59) expr -> . primary
    (60) expr -> . assign
    (61) expr -> . new_array
    (62) expr -> . expr OR expr
    (63) expr -> . expr AND expr
    (64) expr -> . expr EQUALS expr
    (65) expr -> . expr NOTEQUALS expr
    (66) expr -> . expr LT expr
    (67) expr -> . expr GT expr
    (68) expr -> . expr LEQ expr
    (69) expr -> . expr GEQ expr
    (70) expr -> . expr PLUS expr
    (71) expr -> . expr MINUS expr
    (72) expr -> . expr MULT expr
    (73) expr -> . expr DIV expr
    (74) expr -> . NOT expr
    (75) expr -> . MINUS expr
    (76) expr -> . PLUS expr
    (96) primary -> . literal
    (97) primary -> . THIS
    (98) primary -> . SUPER
    (99) primary -> . LPAREN expr RPAREN
    (100) primary -> . NEW IDENTIFIER LPAREN RPAREN
    (101) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (102) primary -> . lhs
    (103) primary -> . method_invocation
    (77) assign -> . lhs ASSIGN expr
    (78) assign -> . lhs PLUSPLUS
    (79) assign -> . PLUSPLUS lhs
    (80) assign -> . lhs MINUSMINUS
    (81) assign -> . MINUSMINUS lhs
    (82) new_array -> . NEW type expr_array_helper
    (90) literal -> . INTEGERCONSTANT
    (91) literal -> . FLOATCONSTANT
    (92) literal -> . STRINGCONSTANT
    (93) literal -> . NULL
    (94) literal -> . TRUE
    (95) literal -> . FALSE
    (106) lhs -> . field_access
    (107) lhs -> . array_access
    (111) method_invocation -> . field_access LPAREN RPAREN
    (112) method_invocation -> . field_access LPAREN arguments RPAREN
    (108) field_access -> . primary DOT IDENTIFIER
    (109) field_access -> . IDENTIFIER
    (110) array_access -> . primary LSQUARE expr RSQUARE

    SEMICOLON       shift and go to state 203
    NOT             shift and go to state 130
    MINUS           shift and go to state 121
    PLUS            shift and go to state 123
    THIS            shift and go to state 105
    SUPER           shift and go to state 108
    LPAREN          shift and go to state 96
    NEW             shift and go to state 120
    PLUSPLUS        shift and go to state 94
    MINUSMINUS      shift and go to state 98
    INTEGERCONSTANT shift and go to state 102
    FLOATCONSTANT   shift and go to state 100
    STRINGCONSTANT  shift and go to state 83
    NULL            shift and go to state 81
    TRUE            shift and go to state 85
    FALSE           shift and go to state 97
    IDENTIFIER      shift and go to state 125

    new_array                      shift and go to state 118
    field_access                   shift and go to state 126
    expr                           shift and go to state 204
    primary                        shift and go to state 119
    literal                        shift and go to state 87
    array_access                   shift and go to state 82
    lhs                            shift and go to state 129
    method_invocation              shift and go to state 124
    assign                         shift and go to state 128

state 179

    (44) stmt -> FOR LPAREN stmt_expr . SEMICOLON SEMICOLON RPAREN stmt
    (45) stmt -> FOR LPAREN stmt_expr . SEMICOLON expr SEMICOLON RPAREN stmt
    (46) stmt -> FOR LPAREN stmt_expr . SEMICOLON SEMICOLON stmt_expr RPAREN stmt
    (47) stmt -> FOR LPAREN stmt_expr . SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt

    SEMICOLON       shift and go to state 205


state 180

    (99) primary -> LPAREN expr RPAREN .

    DOT             reduce using rule 99 (primary -> LPAREN expr RPAREN .)
    LSQUARE         reduce using rule 99 (primary -> LPAREN expr RPAREN .)
    OR              reduce using rule 99 (primary -> LPAREN expr RPAREN .)
    AND             reduce using rule 99 (primary -> LPAREN expr RPAREN .)
    EQUALS          reduce using rule 99 (primary -> LPAREN expr RPAREN .)
    NOTEQUALS       reduce using rule 99 (primary -> LPAREN expr RPAREN .)
    LT              reduce using rule 99 (primary -> LPAREN expr RPAREN .)
    GT              reduce using rule 99 (primary -> LPAREN expr RPAREN .)
    LEQ             reduce using rule 99 (primary -> LPAREN expr RPAREN .)
    GEQ             reduce using rule 99 (primary -> LPAREN expr RPAREN .)
    PLUS            reduce using rule 99 (primary -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 99 (primary -> LPAREN expr RPAREN .)
    MULT            reduce using rule 99 (primary -> LPAREN expr RPAREN .)
    DIV             reduce using rule 99 (primary -> LPAREN expr RPAREN .)
    SEMICOLON       reduce using rule 99 (primary -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 99 (primary -> LPAREN expr RPAREN .)
    RSQUARE         reduce using rule 99 (primary -> LPAREN expr RPAREN .)
    COMMA           reduce using rule 99 (primary -> LPAREN expr RPAREN .)


state 181

    (40) stmt -> IF LPAREN expr . RPAREN stmt ELSE stmt
    (41) stmt -> IF LPAREN expr . RPAREN stmt
    (62) expr -> expr . OR expr
    (63) expr -> expr . AND expr
    (64) expr -> expr . EQUALS expr
    (65) expr -> expr . NOTEQUALS expr
    (66) expr -> expr . LT expr
    (67) expr -> expr . GT expr
    (68) expr -> expr . LEQ expr
    (69) expr -> expr . GEQ expr
    (70) expr -> expr . PLUS expr
    (71) expr -> expr . MINUS expr
    (72) expr -> expr . MULT expr
    (73) expr -> expr . DIV expr

    RPAREN          shift and go to state 206
    OR              shift and go to state 168
    AND             shift and go to state 157
    EQUALS          shift and go to state 162
    NOTEQUALS       shift and go to state 158
    LT              shift and go to state 165
    GT              shift and go to state 160
    LEQ             shift and go to state 164
    GEQ             shift and go to state 159
    PLUS            shift and go to state 166
    MINUS           shift and go to state 163
    MULT            shift and go to state 169
    DIV             shift and go to state 167


state 182

    (77) assign -> lhs ASSIGN expr .
    (62) expr -> expr . OR expr
    (63) expr -> expr . AND expr
    (64) expr -> expr . EQUALS expr
    (65) expr -> expr . NOTEQUALS expr
    (66) expr -> expr . LT expr
    (67) expr -> expr . GT expr
    (68) expr -> expr . LEQ expr
    (69) expr -> expr . GEQ expr
    (70) expr -> expr . PLUS expr
    (71) expr -> expr . MINUS expr
    (72) expr -> expr . MULT expr
    (73) expr -> expr . DIV expr

    RPAREN          reduce using rule 77 (assign -> lhs ASSIGN expr .)
    COMMA           reduce using rule 77 (assign -> lhs ASSIGN expr .)
    SEMICOLON       reduce using rule 77 (assign -> lhs ASSIGN expr .)
    RSQUARE         reduce using rule 77 (assign -> lhs ASSIGN expr .)
    OR              shift and go to state 168
    AND             shift and go to state 157
    EQUALS          shift and go to state 162
    NOTEQUALS       shift and go to state 158
    LT              shift and go to state 165
    GT              shift and go to state 160
    LEQ             shift and go to state 164
    GEQ             shift and go to state 159
    PLUS            shift and go to state 166
    MINUS           shift and go to state 163
    MULT            shift and go to state 169
    DIV             shift and go to state 167

  ! OR              [ reduce using rule 77 (assign -> lhs ASSIGN expr .) ]
  ! AND             [ reduce using rule 77 (assign -> lhs ASSIGN expr .) ]
  ! EQUALS          [ reduce using rule 77 (assign -> lhs ASSIGN expr .) ]
  ! NOTEQUALS       [ reduce using rule 77 (assign -> lhs ASSIGN expr .) ]
  ! LT              [ reduce using rule 77 (assign -> lhs ASSIGN expr .) ]
  ! GT              [ reduce using rule 77 (assign -> lhs ASSIGN expr .) ]
  ! LEQ             [ reduce using rule 77 (assign -> lhs ASSIGN expr .) ]
  ! GEQ             [ reduce using rule 77 (assign -> lhs ASSIGN expr .) ]
  ! PLUS            [ reduce using rule 77 (assign -> lhs ASSIGN expr .) ]
  ! MINUS           [ reduce using rule 77 (assign -> lhs ASSIGN expr .) ]
  ! MULT            [ reduce using rule 77 (assign -> lhs ASSIGN expr .) ]
  ! DIV             [ reduce using rule 77 (assign -> lhs ASSIGN expr .) ]


state 183

    (82) new_array -> NEW type expr_array_helper .

    SEMICOLON       reduce using rule 82 (new_array -> NEW type expr_array_helper .)
    OR              reduce using rule 82 (new_array -> NEW type expr_array_helper .)
    AND             reduce using rule 82 (new_array -> NEW type expr_array_helper .)
    EQUALS          reduce using rule 82 (new_array -> NEW type expr_array_helper .)
    NOTEQUALS       reduce using rule 82 (new_array -> NEW type expr_array_helper .)
    LT              reduce using rule 82 (new_array -> NEW type expr_array_helper .)
    GT              reduce using rule 82 (new_array -> NEW type expr_array_helper .)
    LEQ             reduce using rule 82 (new_array -> NEW type expr_array_helper .)
    GEQ             reduce using rule 82 (new_array -> NEW type expr_array_helper .)
    PLUS            reduce using rule 82 (new_array -> NEW type expr_array_helper .)
    MINUS           reduce using rule 82 (new_array -> NEW type expr_array_helper .)
    MULT            reduce using rule 82 (new_array -> NEW type expr_array_helper .)
    DIV             reduce using rule 82 (new_array -> NEW type expr_array_helper .)
    RPAREN          reduce using rule 82 (new_array -> NEW type expr_array_helper .)
    RSQUARE         reduce using rule 82 (new_array -> NEW type expr_array_helper .)
    COMMA           reduce using rule 82 (new_array -> NEW type expr_array_helper .)


state 184

    (83) expr_array_helper -> LSQUARE . expr RSQUARE
    (84) expr_array_helper -> LSQUARE . expr RSQUARE expr_array_helper
    (85) expr_array_helper -> LSQUARE . expr RSQUARE expr_array_helper2
    (59) expr -> . primary
    (60) expr -> . assign
    (61) expr -> . new_array
    (62) expr -> . expr OR expr
    (63) expr -> . expr AND expr
    (64) expr -> . expr EQUALS expr
    (65) expr -> . expr NOTEQUALS expr
    (66) expr -> . expr LT expr
    (67) expr -> . expr GT expr
    (68) expr -> . expr LEQ expr
    (69) expr -> . expr GEQ expr
    (70) expr -> . expr PLUS expr
    (71) expr -> . expr MINUS expr
    (72) expr -> . expr MULT expr
    (73) expr -> . expr DIV expr
    (74) expr -> . NOT expr
    (75) expr -> . MINUS expr
    (76) expr -> . PLUS expr
    (96) primary -> . literal
    (97) primary -> . THIS
    (98) primary -> . SUPER
    (99) primary -> . LPAREN expr RPAREN
    (100) primary -> . NEW IDENTIFIER LPAREN RPAREN
    (101) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (102) primary -> . lhs
    (103) primary -> . method_invocation
    (77) assign -> . lhs ASSIGN expr
    (78) assign -> . lhs PLUSPLUS
    (79) assign -> . PLUSPLUS lhs
    (80) assign -> . lhs MINUSMINUS
    (81) assign -> . MINUSMINUS lhs
    (82) new_array -> . NEW type expr_array_helper
    (90) literal -> . INTEGERCONSTANT
    (91) literal -> . FLOATCONSTANT
    (92) literal -> . STRINGCONSTANT
    (93) literal -> . NULL
    (94) literal -> . TRUE
    (95) literal -> . FALSE
    (106) lhs -> . field_access
    (107) lhs -> . array_access
    (111) method_invocation -> . field_access LPAREN RPAREN
    (112) method_invocation -> . field_access LPAREN arguments RPAREN
    (108) field_access -> . primary DOT IDENTIFIER
    (109) field_access -> . IDENTIFIER
    (110) array_access -> . primary LSQUARE expr RSQUARE

    NOT             shift and go to state 130
    MINUS           shift and go to state 121
    PLUS            shift and go to state 123
    THIS            shift and go to state 105
    SUPER           shift and go to state 108
    LPAREN          shift and go to state 96
    NEW             shift and go to state 120
    PLUSPLUS        shift and go to state 94
    MINUSMINUS      shift and go to state 98
    INTEGERCONSTANT shift and go to state 102
    FLOATCONSTANT   shift and go to state 100
    STRINGCONSTANT  shift and go to state 83
    NULL            shift and go to state 81
    TRUE            shift and go to state 85
    FALSE           shift and go to state 97
    IDENTIFIER      shift and go to state 125

    new_array                      shift and go to state 118
    field_access                   shift and go to state 126
    expr                           shift and go to state 207
    primary                        shift and go to state 119
    array_access                   shift and go to state 82
    literal                        shift and go to state 87
    lhs                            shift and go to state 129
    method_invocation              shift and go to state 124
    assign                         shift and go to state 128

state 185

    (63) expr -> expr AND expr .
    (62) expr -> expr . OR expr
    (63) expr -> expr . AND expr
    (64) expr -> expr . EQUALS expr
    (65) expr -> expr . NOTEQUALS expr
    (66) expr -> expr . LT expr
    (67) expr -> expr . GT expr
    (68) expr -> expr . LEQ expr
    (69) expr -> expr . GEQ expr
    (70) expr -> expr . PLUS expr
    (71) expr -> expr . MINUS expr
    (72) expr -> expr . MULT expr
    (73) expr -> expr . DIV expr

    OR              reduce using rule 63 (expr -> expr AND expr .)
    AND             reduce using rule 63 (expr -> expr AND expr .)
    RPAREN          reduce using rule 63 (expr -> expr AND expr .)
    COMMA           reduce using rule 63 (expr -> expr AND expr .)
    SEMICOLON       reduce using rule 63 (expr -> expr AND expr .)
    RSQUARE         reduce using rule 63 (expr -> expr AND expr .)
    EQUALS          shift and go to state 162
    NOTEQUALS       shift and go to state 158
    LT              shift and go to state 165
    GT              shift and go to state 160
    LEQ             shift and go to state 164
    GEQ             shift and go to state 159
    PLUS            shift and go to state 166
    MINUS           shift and go to state 163
    MULT            shift and go to state 169
    DIV             shift and go to state 167

  ! EQUALS          [ reduce using rule 63 (expr -> expr AND expr .) ]
  ! NOTEQUALS       [ reduce using rule 63 (expr -> expr AND expr .) ]
  ! LT              [ reduce using rule 63 (expr -> expr AND expr .) ]
  ! GT              [ reduce using rule 63 (expr -> expr AND expr .) ]
  ! LEQ             [ reduce using rule 63 (expr -> expr AND expr .) ]
  ! GEQ             [ reduce using rule 63 (expr -> expr AND expr .) ]
  ! PLUS            [ reduce using rule 63 (expr -> expr AND expr .) ]
  ! MINUS           [ reduce using rule 63 (expr -> expr AND expr .) ]
  ! MULT            [ reduce using rule 63 (expr -> expr AND expr .) ]
  ! DIV             [ reduce using rule 63 (expr -> expr AND expr .) ]
  ! OR              [ shift and go to state 168 ]
  ! AND             [ shift and go to state 157 ]


state 186

    (65) expr -> expr NOTEQUALS expr .
    (62) expr -> expr . OR expr
    (63) expr -> expr . AND expr
    (64) expr -> expr . EQUALS expr
    (65) expr -> expr . NOTEQUALS expr
    (66) expr -> expr . LT expr
    (67) expr -> expr . GT expr
    (68) expr -> expr . LEQ expr
    (69) expr -> expr . GEQ expr
    (70) expr -> expr . PLUS expr
    (71) expr -> expr . MINUS expr
    (72) expr -> expr . MULT expr
    (73) expr -> expr . DIV expr

    OR              reduce using rule 65 (expr -> expr NOTEQUALS expr .)
    AND             reduce using rule 65 (expr -> expr NOTEQUALS expr .)
    EQUALS          reduce using rule 65 (expr -> expr NOTEQUALS expr .)
    NOTEQUALS       reduce using rule 65 (expr -> expr NOTEQUALS expr .)
    RPAREN          reduce using rule 65 (expr -> expr NOTEQUALS expr .)
    COMMA           reduce using rule 65 (expr -> expr NOTEQUALS expr .)
    SEMICOLON       reduce using rule 65 (expr -> expr NOTEQUALS expr .)
    RSQUARE         reduce using rule 65 (expr -> expr NOTEQUALS expr .)
    LT              shift and go to state 165
    GT              shift and go to state 160
    LEQ             shift and go to state 164
    GEQ             shift and go to state 159
    PLUS            shift and go to state 166
    MINUS           shift and go to state 163
    MULT            shift and go to state 169
    DIV             shift and go to state 167

  ! LT              [ reduce using rule 65 (expr -> expr NOTEQUALS expr .) ]
  ! GT              [ reduce using rule 65 (expr -> expr NOTEQUALS expr .) ]
  ! LEQ             [ reduce using rule 65 (expr -> expr NOTEQUALS expr .) ]
  ! GEQ             [ reduce using rule 65 (expr -> expr NOTEQUALS expr .) ]
  ! PLUS            [ reduce using rule 65 (expr -> expr NOTEQUALS expr .) ]
  ! MINUS           [ reduce using rule 65 (expr -> expr NOTEQUALS expr .) ]
  ! MULT            [ reduce using rule 65 (expr -> expr NOTEQUALS expr .) ]
  ! DIV             [ reduce using rule 65 (expr -> expr NOTEQUALS expr .) ]
  ! OR              [ shift and go to state 168 ]
  ! AND             [ shift and go to state 157 ]
  ! EQUALS          [ shift and go to state 162 ]
  ! NOTEQUALS       [ shift and go to state 158 ]


state 187

    (69) expr -> expr GEQ expr .
    (62) expr -> expr . OR expr
    (63) expr -> expr . AND expr
    (64) expr -> expr . EQUALS expr
    (65) expr -> expr . NOTEQUALS expr
    (66) expr -> expr . LT expr
    (67) expr -> expr . GT expr
    (68) expr -> expr . LEQ expr
    (69) expr -> expr . GEQ expr
    (70) expr -> expr . PLUS expr
    (71) expr -> expr . MINUS expr
    (72) expr -> expr . MULT expr
    (73) expr -> expr . DIV expr

    OR              reduce using rule 69 (expr -> expr GEQ expr .)
    AND             reduce using rule 69 (expr -> expr GEQ expr .)
    EQUALS          reduce using rule 69 (expr -> expr GEQ expr .)
    NOTEQUALS       reduce using rule 69 (expr -> expr GEQ expr .)
    LT              reduce using rule 69 (expr -> expr GEQ expr .)
    GT              reduce using rule 69 (expr -> expr GEQ expr .)
    LEQ             reduce using rule 69 (expr -> expr GEQ expr .)
    GEQ             reduce using rule 69 (expr -> expr GEQ expr .)
    RPAREN          reduce using rule 69 (expr -> expr GEQ expr .)
    COMMA           reduce using rule 69 (expr -> expr GEQ expr .)
    SEMICOLON       reduce using rule 69 (expr -> expr GEQ expr .)
    RSQUARE         reduce using rule 69 (expr -> expr GEQ expr .)
    PLUS            shift and go to state 166
    MINUS           shift and go to state 163
    MULT            shift and go to state 169
    DIV             shift and go to state 167

  ! PLUS            [ reduce using rule 69 (expr -> expr GEQ expr .) ]
  ! MINUS           [ reduce using rule 69 (expr -> expr GEQ expr .) ]
  ! MULT            [ reduce using rule 69 (expr -> expr GEQ expr .) ]
  ! DIV             [ reduce using rule 69 (expr -> expr GEQ expr .) ]
  ! OR              [ shift and go to state 168 ]
  ! AND             [ shift and go to state 157 ]
  ! EQUALS          [ shift and go to state 162 ]
  ! NOTEQUALS       [ shift and go to state 158 ]
  ! LT              [ shift and go to state 165 ]
  ! GT              [ shift and go to state 160 ]
  ! LEQ             [ shift and go to state 164 ]
  ! GEQ             [ shift and go to state 159 ]


state 188

    (67) expr -> expr GT expr .
    (62) expr -> expr . OR expr
    (63) expr -> expr . AND expr
    (64) expr -> expr . EQUALS expr
    (65) expr -> expr . NOTEQUALS expr
    (66) expr -> expr . LT expr
    (67) expr -> expr . GT expr
    (68) expr -> expr . LEQ expr
    (69) expr -> expr . GEQ expr
    (70) expr -> expr . PLUS expr
    (71) expr -> expr . MINUS expr
    (72) expr -> expr . MULT expr
    (73) expr -> expr . DIV expr

    OR              reduce using rule 67 (expr -> expr GT expr .)
    AND             reduce using rule 67 (expr -> expr GT expr .)
    EQUALS          reduce using rule 67 (expr -> expr GT expr .)
    NOTEQUALS       reduce using rule 67 (expr -> expr GT expr .)
    LT              reduce using rule 67 (expr -> expr GT expr .)
    GT              reduce using rule 67 (expr -> expr GT expr .)
    LEQ             reduce using rule 67 (expr -> expr GT expr .)
    GEQ             reduce using rule 67 (expr -> expr GT expr .)
    RPAREN          reduce using rule 67 (expr -> expr GT expr .)
    COMMA           reduce using rule 67 (expr -> expr GT expr .)
    SEMICOLON       reduce using rule 67 (expr -> expr GT expr .)
    RSQUARE         reduce using rule 67 (expr -> expr GT expr .)
    PLUS            shift and go to state 166
    MINUS           shift and go to state 163
    MULT            shift and go to state 169
    DIV             shift and go to state 167

  ! PLUS            [ reduce using rule 67 (expr -> expr GT expr .) ]
  ! MINUS           [ reduce using rule 67 (expr -> expr GT expr .) ]
  ! MULT            [ reduce using rule 67 (expr -> expr GT expr .) ]
  ! DIV             [ reduce using rule 67 (expr -> expr GT expr .) ]
  ! OR              [ shift and go to state 168 ]
  ! AND             [ shift and go to state 157 ]
  ! EQUALS          [ shift and go to state 162 ]
  ! NOTEQUALS       [ shift and go to state 158 ]
  ! LT              [ shift and go to state 165 ]
  ! GT              [ shift and go to state 160 ]
  ! LEQ             [ shift and go to state 164 ]
  ! GEQ             [ shift and go to state 159 ]


state 189

    (64) expr -> expr EQUALS expr .
    (62) expr -> expr . OR expr
    (63) expr -> expr . AND expr
    (64) expr -> expr . EQUALS expr
    (65) expr -> expr . NOTEQUALS expr
    (66) expr -> expr . LT expr
    (67) expr -> expr . GT expr
    (68) expr -> expr . LEQ expr
    (69) expr -> expr . GEQ expr
    (70) expr -> expr . PLUS expr
    (71) expr -> expr . MINUS expr
    (72) expr -> expr . MULT expr
    (73) expr -> expr . DIV expr

    OR              reduce using rule 64 (expr -> expr EQUALS expr .)
    AND             reduce using rule 64 (expr -> expr EQUALS expr .)
    EQUALS          reduce using rule 64 (expr -> expr EQUALS expr .)
    NOTEQUALS       reduce using rule 64 (expr -> expr EQUALS expr .)
    RPAREN          reduce using rule 64 (expr -> expr EQUALS expr .)
    COMMA           reduce using rule 64 (expr -> expr EQUALS expr .)
    SEMICOLON       reduce using rule 64 (expr -> expr EQUALS expr .)
    RSQUARE         reduce using rule 64 (expr -> expr EQUALS expr .)
    LT              shift and go to state 165
    GT              shift and go to state 160
    LEQ             shift and go to state 164
    GEQ             shift and go to state 159
    PLUS            shift and go to state 166
    MINUS           shift and go to state 163
    MULT            shift and go to state 169
    DIV             shift and go to state 167

  ! LT              [ reduce using rule 64 (expr -> expr EQUALS expr .) ]
  ! GT              [ reduce using rule 64 (expr -> expr EQUALS expr .) ]
  ! LEQ             [ reduce using rule 64 (expr -> expr EQUALS expr .) ]
  ! GEQ             [ reduce using rule 64 (expr -> expr EQUALS expr .) ]
  ! PLUS            [ reduce using rule 64 (expr -> expr EQUALS expr .) ]
  ! MINUS           [ reduce using rule 64 (expr -> expr EQUALS expr .) ]
  ! MULT            [ reduce using rule 64 (expr -> expr EQUALS expr .) ]
  ! DIV             [ reduce using rule 64 (expr -> expr EQUALS expr .) ]
  ! OR              [ shift and go to state 168 ]
  ! AND             [ shift and go to state 157 ]
  ! EQUALS          [ shift and go to state 162 ]
  ! NOTEQUALS       [ shift and go to state 158 ]


state 190

    (71) expr -> expr MINUS expr .
    (62) expr -> expr . OR expr
    (63) expr -> expr . AND expr
    (64) expr -> expr . EQUALS expr
    (65) expr -> expr . NOTEQUALS expr
    (66) expr -> expr . LT expr
    (67) expr -> expr . GT expr
    (68) expr -> expr . LEQ expr
    (69) expr -> expr . GEQ expr
    (70) expr -> expr . PLUS expr
    (71) expr -> expr . MINUS expr
    (72) expr -> expr . MULT expr
    (73) expr -> expr . DIV expr

    OR              reduce using rule 71 (expr -> expr MINUS expr .)
    AND             reduce using rule 71 (expr -> expr MINUS expr .)
    EQUALS          reduce using rule 71 (expr -> expr MINUS expr .)
    NOTEQUALS       reduce using rule 71 (expr -> expr MINUS expr .)
    LT              reduce using rule 71 (expr -> expr MINUS expr .)
    GT              reduce using rule 71 (expr -> expr MINUS expr .)
    LEQ             reduce using rule 71 (expr -> expr MINUS expr .)
    GEQ             reduce using rule 71 (expr -> expr MINUS expr .)
    PLUS            reduce using rule 71 (expr -> expr MINUS expr .)
    MINUS           reduce using rule 71 (expr -> expr MINUS expr .)
    RPAREN          reduce using rule 71 (expr -> expr MINUS expr .)
    COMMA           reduce using rule 71 (expr -> expr MINUS expr .)
    SEMICOLON       reduce using rule 71 (expr -> expr MINUS expr .)
    RSQUARE         reduce using rule 71 (expr -> expr MINUS expr .)
    MULT            shift and go to state 169
    DIV             shift and go to state 167

  ! MULT            [ reduce using rule 71 (expr -> expr MINUS expr .) ]
  ! DIV             [ reduce using rule 71 (expr -> expr MINUS expr .) ]
  ! OR              [ shift and go to state 168 ]
  ! AND             [ shift and go to state 157 ]
  ! EQUALS          [ shift and go to state 162 ]
  ! NOTEQUALS       [ shift and go to state 158 ]
  ! LT              [ shift and go to state 165 ]
  ! GT              [ shift and go to state 160 ]
  ! LEQ             [ shift and go to state 164 ]
  ! GEQ             [ shift and go to state 159 ]
  ! PLUS            [ shift and go to state 166 ]
  ! MINUS           [ shift and go to state 163 ]


state 191

    (68) expr -> expr LEQ expr .
    (62) expr -> expr . OR expr
    (63) expr -> expr . AND expr
    (64) expr -> expr . EQUALS expr
    (65) expr -> expr . NOTEQUALS expr
    (66) expr -> expr . LT expr
    (67) expr -> expr . GT expr
    (68) expr -> expr . LEQ expr
    (69) expr -> expr . GEQ expr
    (70) expr -> expr . PLUS expr
    (71) expr -> expr . MINUS expr
    (72) expr -> expr . MULT expr
    (73) expr -> expr . DIV expr

    OR              reduce using rule 68 (expr -> expr LEQ expr .)
    AND             reduce using rule 68 (expr -> expr LEQ expr .)
    EQUALS          reduce using rule 68 (expr -> expr LEQ expr .)
    NOTEQUALS       reduce using rule 68 (expr -> expr LEQ expr .)
    LT              reduce using rule 68 (expr -> expr LEQ expr .)
    GT              reduce using rule 68 (expr -> expr LEQ expr .)
    LEQ             reduce using rule 68 (expr -> expr LEQ expr .)
    GEQ             reduce using rule 68 (expr -> expr LEQ expr .)
    RPAREN          reduce using rule 68 (expr -> expr LEQ expr .)
    COMMA           reduce using rule 68 (expr -> expr LEQ expr .)
    SEMICOLON       reduce using rule 68 (expr -> expr LEQ expr .)
    RSQUARE         reduce using rule 68 (expr -> expr LEQ expr .)
    PLUS            shift and go to state 166
    MINUS           shift and go to state 163
    MULT            shift and go to state 169
    DIV             shift and go to state 167

  ! PLUS            [ reduce using rule 68 (expr -> expr LEQ expr .) ]
  ! MINUS           [ reduce using rule 68 (expr -> expr LEQ expr .) ]
  ! MULT            [ reduce using rule 68 (expr -> expr LEQ expr .) ]
  ! DIV             [ reduce using rule 68 (expr -> expr LEQ expr .) ]
  ! OR              [ shift and go to state 168 ]
  ! AND             [ shift and go to state 157 ]
  ! EQUALS          [ shift and go to state 162 ]
  ! NOTEQUALS       [ shift and go to state 158 ]
  ! LT              [ shift and go to state 165 ]
  ! GT              [ shift and go to state 160 ]
  ! LEQ             [ shift and go to state 164 ]
  ! GEQ             [ shift and go to state 159 ]


state 192

    (66) expr -> expr LT expr .
    (62) expr -> expr . OR expr
    (63) expr -> expr . AND expr
    (64) expr -> expr . EQUALS expr
    (65) expr -> expr . NOTEQUALS expr
    (66) expr -> expr . LT expr
    (67) expr -> expr . GT expr
    (68) expr -> expr . LEQ expr
    (69) expr -> expr . GEQ expr
    (70) expr -> expr . PLUS expr
    (71) expr -> expr . MINUS expr
    (72) expr -> expr . MULT expr
    (73) expr -> expr . DIV expr

    OR              reduce using rule 66 (expr -> expr LT expr .)
    AND             reduce using rule 66 (expr -> expr LT expr .)
    EQUALS          reduce using rule 66 (expr -> expr LT expr .)
    NOTEQUALS       reduce using rule 66 (expr -> expr LT expr .)
    LT              reduce using rule 66 (expr -> expr LT expr .)
    GT              reduce using rule 66 (expr -> expr LT expr .)
    LEQ             reduce using rule 66 (expr -> expr LT expr .)
    GEQ             reduce using rule 66 (expr -> expr LT expr .)
    RPAREN          reduce using rule 66 (expr -> expr LT expr .)
    COMMA           reduce using rule 66 (expr -> expr LT expr .)
    SEMICOLON       reduce using rule 66 (expr -> expr LT expr .)
    RSQUARE         reduce using rule 66 (expr -> expr LT expr .)
    PLUS            shift and go to state 166
    MINUS           shift and go to state 163
    MULT            shift and go to state 169
    DIV             shift and go to state 167

  ! PLUS            [ reduce using rule 66 (expr -> expr LT expr .) ]
  ! MINUS           [ reduce using rule 66 (expr -> expr LT expr .) ]
  ! MULT            [ reduce using rule 66 (expr -> expr LT expr .) ]
  ! DIV             [ reduce using rule 66 (expr -> expr LT expr .) ]
  ! OR              [ shift and go to state 168 ]
  ! AND             [ shift and go to state 157 ]
  ! EQUALS          [ shift and go to state 162 ]
  ! NOTEQUALS       [ shift and go to state 158 ]
  ! LT              [ shift and go to state 165 ]
  ! GT              [ shift and go to state 160 ]
  ! LEQ             [ shift and go to state 164 ]
  ! GEQ             [ shift and go to state 159 ]


state 193

    (70) expr -> expr PLUS expr .
    (62) expr -> expr . OR expr
    (63) expr -> expr . AND expr
    (64) expr -> expr . EQUALS expr
    (65) expr -> expr . NOTEQUALS expr
    (66) expr -> expr . LT expr
    (67) expr -> expr . GT expr
    (68) expr -> expr . LEQ expr
    (69) expr -> expr . GEQ expr
    (70) expr -> expr . PLUS expr
    (71) expr -> expr . MINUS expr
    (72) expr -> expr . MULT expr
    (73) expr -> expr . DIV expr

    OR              reduce using rule 70 (expr -> expr PLUS expr .)
    AND             reduce using rule 70 (expr -> expr PLUS expr .)
    EQUALS          reduce using rule 70 (expr -> expr PLUS expr .)
    NOTEQUALS       reduce using rule 70 (expr -> expr PLUS expr .)
    LT              reduce using rule 70 (expr -> expr PLUS expr .)
    GT              reduce using rule 70 (expr -> expr PLUS expr .)
    LEQ             reduce using rule 70 (expr -> expr PLUS expr .)
    GEQ             reduce using rule 70 (expr -> expr PLUS expr .)
    PLUS            reduce using rule 70 (expr -> expr PLUS expr .)
    MINUS           reduce using rule 70 (expr -> expr PLUS expr .)
    RPAREN          reduce using rule 70 (expr -> expr PLUS expr .)
    COMMA           reduce using rule 70 (expr -> expr PLUS expr .)
    SEMICOLON       reduce using rule 70 (expr -> expr PLUS expr .)
    RSQUARE         reduce using rule 70 (expr -> expr PLUS expr .)
    MULT            shift and go to state 169
    DIV             shift and go to state 167

  ! MULT            [ reduce using rule 70 (expr -> expr PLUS expr .) ]
  ! DIV             [ reduce using rule 70 (expr -> expr PLUS expr .) ]
  ! OR              [ shift and go to state 168 ]
  ! AND             [ shift and go to state 157 ]
  ! EQUALS          [ shift and go to state 162 ]
  ! NOTEQUALS       [ shift and go to state 158 ]
  ! LT              [ shift and go to state 165 ]
  ! GT              [ shift and go to state 160 ]
  ! LEQ             [ shift and go to state 164 ]
  ! GEQ             [ shift and go to state 159 ]
  ! PLUS            [ shift and go to state 166 ]
  ! MINUS           [ shift and go to state 163 ]


state 194

    (73) expr -> expr DIV expr .
    (62) expr -> expr . OR expr
    (63) expr -> expr . AND expr
    (64) expr -> expr . EQUALS expr
    (65) expr -> expr . NOTEQUALS expr
    (66) expr -> expr . LT expr
    (67) expr -> expr . GT expr
    (68) expr -> expr . LEQ expr
    (69) expr -> expr . GEQ expr
    (70) expr -> expr . PLUS expr
    (71) expr -> expr . MINUS expr
    (72) expr -> expr . MULT expr
    (73) expr -> expr . DIV expr

    OR              reduce using rule 73 (expr -> expr DIV expr .)
    AND             reduce using rule 73 (expr -> expr DIV expr .)
    EQUALS          reduce using rule 73 (expr -> expr DIV expr .)
    NOTEQUALS       reduce using rule 73 (expr -> expr DIV expr .)
    LT              reduce using rule 73 (expr -> expr DIV expr .)
    GT              reduce using rule 73 (expr -> expr DIV expr .)
    LEQ             reduce using rule 73 (expr -> expr DIV expr .)
    GEQ             reduce using rule 73 (expr -> expr DIV expr .)
    PLUS            reduce using rule 73 (expr -> expr DIV expr .)
    MINUS           reduce using rule 73 (expr -> expr DIV expr .)
    MULT            reduce using rule 73 (expr -> expr DIV expr .)
    DIV             reduce using rule 73 (expr -> expr DIV expr .)
    RPAREN          reduce using rule 73 (expr -> expr DIV expr .)
    COMMA           reduce using rule 73 (expr -> expr DIV expr .)
    SEMICOLON       reduce using rule 73 (expr -> expr DIV expr .)
    RSQUARE         reduce using rule 73 (expr -> expr DIV expr .)

  ! OR              [ shift and go to state 168 ]
  ! AND             [ shift and go to state 157 ]
  ! EQUALS          [ shift and go to state 162 ]
  ! NOTEQUALS       [ shift and go to state 158 ]
  ! LT              [ shift and go to state 165 ]
  ! GT              [ shift and go to state 160 ]
  ! LEQ             [ shift and go to state 164 ]
  ! GEQ             [ shift and go to state 159 ]
  ! PLUS            [ shift and go to state 166 ]
  ! MINUS           [ shift and go to state 163 ]
  ! MULT            [ shift and go to state 169 ]
  ! DIV             [ shift and go to state 167 ]


state 195

    (62) expr -> expr OR expr .
    (62) expr -> expr . OR expr
    (63) expr -> expr . AND expr
    (64) expr -> expr . EQUALS expr
    (65) expr -> expr . NOTEQUALS expr
    (66) expr -> expr . LT expr
    (67) expr -> expr . GT expr
    (68) expr -> expr . LEQ expr
    (69) expr -> expr . GEQ expr
    (70) expr -> expr . PLUS expr
    (71) expr -> expr . MINUS expr
    (72) expr -> expr . MULT expr
    (73) expr -> expr . DIV expr

    OR              reduce using rule 62 (expr -> expr OR expr .)
    RPAREN          reduce using rule 62 (expr -> expr OR expr .)
    COMMA           reduce using rule 62 (expr -> expr OR expr .)
    SEMICOLON       reduce using rule 62 (expr -> expr OR expr .)
    RSQUARE         reduce using rule 62 (expr -> expr OR expr .)
    AND             shift and go to state 157
    EQUALS          shift and go to state 162
    NOTEQUALS       shift and go to state 158
    LT              shift and go to state 165
    GT              shift and go to state 160
    LEQ             shift and go to state 164
    GEQ             shift and go to state 159
    PLUS            shift and go to state 166
    MINUS           shift and go to state 163
    MULT            shift and go to state 169
    DIV             shift and go to state 167

  ! AND             [ reduce using rule 62 (expr -> expr OR expr .) ]
  ! EQUALS          [ reduce using rule 62 (expr -> expr OR expr .) ]
  ! NOTEQUALS       [ reduce using rule 62 (expr -> expr OR expr .) ]
  ! LT              [ reduce using rule 62 (expr -> expr OR expr .) ]
  ! GT              [ reduce using rule 62 (expr -> expr OR expr .) ]
  ! LEQ             [ reduce using rule 62 (expr -> expr OR expr .) ]
  ! GEQ             [ reduce using rule 62 (expr -> expr OR expr .) ]
  ! PLUS            [ reduce using rule 62 (expr -> expr OR expr .) ]
  ! MINUS           [ reduce using rule 62 (expr -> expr OR expr .) ]
  ! MULT            [ reduce using rule 62 (expr -> expr OR expr .) ]
  ! DIV             [ reduce using rule 62 (expr -> expr OR expr .) ]
  ! OR              [ shift and go to state 168 ]


state 196

    (72) expr -> expr MULT expr .
    (62) expr -> expr . OR expr
    (63) expr -> expr . AND expr
    (64) expr -> expr . EQUALS expr
    (65) expr -> expr . NOTEQUALS expr
    (66) expr -> expr . LT expr
    (67) expr -> expr . GT expr
    (68) expr -> expr . LEQ expr
    (69) expr -> expr . GEQ expr
    (70) expr -> expr . PLUS expr
    (71) expr -> expr . MINUS expr
    (72) expr -> expr . MULT expr
    (73) expr -> expr . DIV expr

    OR              reduce using rule 72 (expr -> expr MULT expr .)
    AND             reduce using rule 72 (expr -> expr MULT expr .)
    EQUALS          reduce using rule 72 (expr -> expr MULT expr .)
    NOTEQUALS       reduce using rule 72 (expr -> expr MULT expr .)
    LT              reduce using rule 72 (expr -> expr MULT expr .)
    GT              reduce using rule 72 (expr -> expr MULT expr .)
    LEQ             reduce using rule 72 (expr -> expr MULT expr .)
    GEQ             reduce using rule 72 (expr -> expr MULT expr .)
    PLUS            reduce using rule 72 (expr -> expr MULT expr .)
    MINUS           reduce using rule 72 (expr -> expr MULT expr .)
    MULT            reduce using rule 72 (expr -> expr MULT expr .)
    DIV             reduce using rule 72 (expr -> expr MULT expr .)
    RPAREN          reduce using rule 72 (expr -> expr MULT expr .)
    COMMA           reduce using rule 72 (expr -> expr MULT expr .)
    SEMICOLON       reduce using rule 72 (expr -> expr MULT expr .)
    RSQUARE         reduce using rule 72 (expr -> expr MULT expr .)

  ! OR              [ shift and go to state 168 ]
  ! AND             [ shift and go to state 157 ]
  ! EQUALS          [ shift and go to state 162 ]
  ! NOTEQUALS       [ shift and go to state 158 ]
  ! LT              [ shift and go to state 165 ]
  ! GT              [ shift and go to state 160 ]
  ! LEQ             [ shift and go to state 164 ]
  ! GEQ             [ shift and go to state 159 ]
  ! PLUS            [ shift and go to state 166 ]
  ! MINUS           [ shift and go to state 163 ]
  ! MULT            [ shift and go to state 169 ]
  ! DIV             [ shift and go to state 167 ]


state 197

    (110) array_access -> primary LSQUARE expr RSQUARE .

    ASSIGN          reduce using rule 110 (array_access -> primary LSQUARE expr RSQUARE .)
    PLUSPLUS        reduce using rule 110 (array_access -> primary LSQUARE expr RSQUARE .)
    MINUSMINUS      reduce using rule 110 (array_access -> primary LSQUARE expr RSQUARE .)
    DOT             reduce using rule 110 (array_access -> primary LSQUARE expr RSQUARE .)
    LSQUARE         reduce using rule 110 (array_access -> primary LSQUARE expr RSQUARE .)
    RSQUARE         reduce using rule 110 (array_access -> primary LSQUARE expr RSQUARE .)
    OR              reduce using rule 110 (array_access -> primary LSQUARE expr RSQUARE .)
    AND             reduce using rule 110 (array_access -> primary LSQUARE expr RSQUARE .)
    EQUALS          reduce using rule 110 (array_access -> primary LSQUARE expr RSQUARE .)
    NOTEQUALS       reduce using rule 110 (array_access -> primary LSQUARE expr RSQUARE .)
    LT              reduce using rule 110 (array_access -> primary LSQUARE expr RSQUARE .)
    GT              reduce using rule 110 (array_access -> primary LSQUARE expr RSQUARE .)
    LEQ             reduce using rule 110 (array_access -> primary LSQUARE expr RSQUARE .)
    GEQ             reduce using rule 110 (array_access -> primary LSQUARE expr RSQUARE .)
    PLUS            reduce using rule 110 (array_access -> primary LSQUARE expr RSQUARE .)
    MINUS           reduce using rule 110 (array_access -> primary LSQUARE expr RSQUARE .)
    MULT            reduce using rule 110 (array_access -> primary LSQUARE expr RSQUARE .)
    DIV             reduce using rule 110 (array_access -> primary LSQUARE expr RSQUARE .)
    RPAREN          reduce using rule 110 (array_access -> primary LSQUARE expr RSQUARE .)
    COMMA           reduce using rule 110 (array_access -> primary LSQUARE expr RSQUARE .)
    SEMICOLON       reduce using rule 110 (array_access -> primary LSQUARE expr RSQUARE .)


state 198

    (42) stmt -> WHILE LPAREN expr RPAREN . stmt
    (40) stmt -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (41) stmt -> . IF LPAREN expr RPAREN stmt
    (42) stmt -> . WHILE LPAREN expr RPAREN stmt
    (43) stmt -> . FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt
    (44) stmt -> . FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt
    (45) stmt -> . FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt
    (46) stmt -> . FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt
    (47) stmt -> . FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (48) stmt -> . FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt
    (49) stmt -> . FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (50) stmt -> . FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt
    (51) stmt -> . block
    (52) stmt -> . var_decl
    (53) stmt -> . stmt_expr SEMICOLON
    (54) stmt -> . RETURN expr SEMICOLON
    (55) stmt -> . RETURN SEMICOLON
    (56) stmt -> . BREAK SEMICOLON
    (57) stmt -> . CONTINUE SEMICOLON
    (58) stmt -> . SEMICOLON
    (36) block -> . LCURLY empty RCURLY
    (37) block -> . LCURLY stmthelper RCURLY
    (19) var_decl -> . type variables SEMICOLON
    (88) stmt_expr -> . assign
    (89) stmt_expr -> . method_invocation
    (20) type -> . INT
    (21) type -> . FLOAT
    (22) type -> . BOOLEAN
    (23) type -> . IDENTIFIER
    (77) assign -> . lhs ASSIGN expr
    (78) assign -> . lhs PLUSPLUS
    (79) assign -> . PLUSPLUS lhs
    (80) assign -> . lhs MINUSMINUS
    (81) assign -> . MINUSMINUS lhs
    (111) method_invocation -> . field_access LPAREN RPAREN
    (112) method_invocation -> . field_access LPAREN arguments RPAREN
    (106) lhs -> . field_access
    (107) lhs -> . array_access
    (108) field_access -> . primary DOT IDENTIFIER
    (109) field_access -> . IDENTIFIER
    (110) array_access -> . primary LSQUARE expr RSQUARE
    (96) primary -> . literal
    (97) primary -> . THIS
    (98) primary -> . SUPER
    (99) primary -> . LPAREN expr RPAREN
    (100) primary -> . NEW IDENTIFIER LPAREN RPAREN
    (101) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (102) primary -> . lhs
    (103) primary -> . method_invocation
    (90) literal -> . INTEGERCONSTANT
    (91) literal -> . FLOATCONSTANT
    (92) literal -> . STRINGCONSTANT
    (93) literal -> . NULL
    (94) literal -> . TRUE
    (95) literal -> . FALSE

    IF              shift and go to state 99
    WHILE           shift and go to state 79
    FOR             shift and go to state 93
    RETURN          shift and go to state 77
    BREAK           shift and go to state 104
    CONTINUE        shift and go to state 106
    SEMICOLON       shift and go to state 84
    LCURLY          shift and go to state 63
    INT             shift and go to state 16
    FLOAT           shift and go to state 18
    BOOLEAN         shift and go to state 20
    IDENTIFIER      shift and go to state 89
    PLUSPLUS        shift and go to state 94
    MINUSMINUS      shift and go to state 98
    THIS            shift and go to state 105
    SUPER           shift and go to state 108
    LPAREN          shift and go to state 96
    NEW             shift and go to state 80
    INTEGERCONSTANT shift and go to state 102
    FLOATCONSTANT   shift and go to state 100
    STRINGCONSTANT  shift and go to state 83
    NULL            shift and go to state 81
    TRUE            shift and go to state 85
    FALSE           shift and go to state 97

    field_access                   shift and go to state 92
    primary                        shift and go to state 78
    var_decl                       shift and go to state 103
    stmt                           shift and go to state 208
    stmt_expr                      shift and go to state 86
    literal                        shift and go to state 87
    array_access                   shift and go to state 82
    lhs                            shift and go to state 107
    block                          shift and go to state 110
    method_invocation              shift and go to state 88
    type                           shift and go to state 90
    assign                         shift and go to state 109

state 199

    (100) primary -> NEW IDENTIFIER LPAREN RPAREN .

    DOT             reduce using rule 100 (primary -> NEW IDENTIFIER LPAREN RPAREN .)
    LSQUARE         reduce using rule 100 (primary -> NEW IDENTIFIER LPAREN RPAREN .)
    OR              reduce using rule 100 (primary -> NEW IDENTIFIER LPAREN RPAREN .)
    AND             reduce using rule 100 (primary -> NEW IDENTIFIER LPAREN RPAREN .)
    EQUALS          reduce using rule 100 (primary -> NEW IDENTIFIER LPAREN RPAREN .)
    NOTEQUALS       reduce using rule 100 (primary -> NEW IDENTIFIER LPAREN RPAREN .)
    LT              reduce using rule 100 (primary -> NEW IDENTIFIER LPAREN RPAREN .)
    GT              reduce using rule 100 (primary -> NEW IDENTIFIER LPAREN RPAREN .)
    LEQ             reduce using rule 100 (primary -> NEW IDENTIFIER LPAREN RPAREN .)
    GEQ             reduce using rule 100 (primary -> NEW IDENTIFIER LPAREN RPAREN .)
    PLUS            reduce using rule 100 (primary -> NEW IDENTIFIER LPAREN RPAREN .)
    MINUS           reduce using rule 100 (primary -> NEW IDENTIFIER LPAREN RPAREN .)
    MULT            reduce using rule 100 (primary -> NEW IDENTIFIER LPAREN RPAREN .)
    DIV             reduce using rule 100 (primary -> NEW IDENTIFIER LPAREN RPAREN .)
    SEMICOLON       reduce using rule 100 (primary -> NEW IDENTIFIER LPAREN RPAREN .)
    RPAREN          reduce using rule 100 (primary -> NEW IDENTIFIER LPAREN RPAREN .)
    RSQUARE         reduce using rule 100 (primary -> NEW IDENTIFIER LPAREN RPAREN .)
    COMMA           reduce using rule 100 (primary -> NEW IDENTIFIER LPAREN RPAREN .)


state 200

    (101) primary -> NEW IDENTIFIER LPAREN arguments . RPAREN
    (105) arguments -> arguments . COMMA expr

    RPAREN          shift and go to state 209
    COMMA           shift and go to state 202


state 201

    (112) method_invocation -> field_access LPAREN arguments RPAREN .

    SEMICOLON       reduce using rule 112 (method_invocation -> field_access LPAREN arguments RPAREN .)
    DOT             reduce using rule 112 (method_invocation -> field_access LPAREN arguments RPAREN .)
    LSQUARE         reduce using rule 112 (method_invocation -> field_access LPAREN arguments RPAREN .)
    RSQUARE         reduce using rule 112 (method_invocation -> field_access LPAREN arguments RPAREN .)
    OR              reduce using rule 112 (method_invocation -> field_access LPAREN arguments RPAREN .)
    AND             reduce using rule 112 (method_invocation -> field_access LPAREN arguments RPAREN .)
    EQUALS          reduce using rule 112 (method_invocation -> field_access LPAREN arguments RPAREN .)
    NOTEQUALS       reduce using rule 112 (method_invocation -> field_access LPAREN arguments RPAREN .)
    LT              reduce using rule 112 (method_invocation -> field_access LPAREN arguments RPAREN .)
    GT              reduce using rule 112 (method_invocation -> field_access LPAREN arguments RPAREN .)
    LEQ             reduce using rule 112 (method_invocation -> field_access LPAREN arguments RPAREN .)
    GEQ             reduce using rule 112 (method_invocation -> field_access LPAREN arguments RPAREN .)
    PLUS            reduce using rule 112 (method_invocation -> field_access LPAREN arguments RPAREN .)
    MINUS           reduce using rule 112 (method_invocation -> field_access LPAREN arguments RPAREN .)
    MULT            reduce using rule 112 (method_invocation -> field_access LPAREN arguments RPAREN .)
    DIV             reduce using rule 112 (method_invocation -> field_access LPAREN arguments RPAREN .)
    RPAREN          reduce using rule 112 (method_invocation -> field_access LPAREN arguments RPAREN .)
    COMMA           reduce using rule 112 (method_invocation -> field_access LPAREN arguments RPAREN .)


state 202

    (105) arguments -> arguments COMMA . expr
    (59) expr -> . primary
    (60) expr -> . assign
    (61) expr -> . new_array
    (62) expr -> . expr OR expr
    (63) expr -> . expr AND expr
    (64) expr -> . expr EQUALS expr
    (65) expr -> . expr NOTEQUALS expr
    (66) expr -> . expr LT expr
    (67) expr -> . expr GT expr
    (68) expr -> . expr LEQ expr
    (69) expr -> . expr GEQ expr
    (70) expr -> . expr PLUS expr
    (71) expr -> . expr MINUS expr
    (72) expr -> . expr MULT expr
    (73) expr -> . expr DIV expr
    (74) expr -> . NOT expr
    (75) expr -> . MINUS expr
    (76) expr -> . PLUS expr
    (96) primary -> . literal
    (97) primary -> . THIS
    (98) primary -> . SUPER
    (99) primary -> . LPAREN expr RPAREN
    (100) primary -> . NEW IDENTIFIER LPAREN RPAREN
    (101) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (102) primary -> . lhs
    (103) primary -> . method_invocation
    (77) assign -> . lhs ASSIGN expr
    (78) assign -> . lhs PLUSPLUS
    (79) assign -> . PLUSPLUS lhs
    (80) assign -> . lhs MINUSMINUS
    (81) assign -> . MINUSMINUS lhs
    (82) new_array -> . NEW type expr_array_helper
    (90) literal -> . INTEGERCONSTANT
    (91) literal -> . FLOATCONSTANT
    (92) literal -> . STRINGCONSTANT
    (93) literal -> . NULL
    (94) literal -> . TRUE
    (95) literal -> . FALSE
    (106) lhs -> . field_access
    (107) lhs -> . array_access
    (111) method_invocation -> . field_access LPAREN RPAREN
    (112) method_invocation -> . field_access LPAREN arguments RPAREN
    (108) field_access -> . primary DOT IDENTIFIER
    (109) field_access -> . IDENTIFIER
    (110) array_access -> . primary LSQUARE expr RSQUARE

    NOT             shift and go to state 130
    MINUS           shift and go to state 121
    PLUS            shift and go to state 123
    THIS            shift and go to state 105
    SUPER           shift and go to state 108
    LPAREN          shift and go to state 96
    NEW             shift and go to state 120
    PLUSPLUS        shift and go to state 94
    MINUSMINUS      shift and go to state 98
    INTEGERCONSTANT shift and go to state 102
    FLOATCONSTANT   shift and go to state 100
    STRINGCONSTANT  shift and go to state 83
    NULL            shift and go to state 81
    TRUE            shift and go to state 85
    FALSE           shift and go to state 97
    IDENTIFIER      shift and go to state 125

    new_array                      shift and go to state 118
    field_access                   shift and go to state 126
    expr                           shift and go to state 210
    primary                        shift and go to state 119
    array_access                   shift and go to state 82
    literal                        shift and go to state 87
    lhs                            shift and go to state 129
    method_invocation              shift and go to state 124
    assign                         shift and go to state 128

state 203

    (43) stmt -> FOR LPAREN SEMICOLON SEMICOLON . RPAREN stmt
    (50) stmt -> FOR LPAREN SEMICOLON SEMICOLON . stmt_expr RPAREN stmt
    (88) stmt_expr -> . assign
    (89) stmt_expr -> . method_invocation
    (77) assign -> . lhs ASSIGN expr
    (78) assign -> . lhs PLUSPLUS
    (79) assign -> . PLUSPLUS lhs
    (80) assign -> . lhs MINUSMINUS
    (81) assign -> . MINUSMINUS lhs
    (111) method_invocation -> . field_access LPAREN RPAREN
    (112) method_invocation -> . field_access LPAREN arguments RPAREN
    (106) lhs -> . field_access
    (107) lhs -> . array_access
    (108) field_access -> . primary DOT IDENTIFIER
    (109) field_access -> . IDENTIFIER
    (110) array_access -> . primary LSQUARE expr RSQUARE
    (96) primary -> . literal
    (97) primary -> . THIS
    (98) primary -> . SUPER
    (99) primary -> . LPAREN expr RPAREN
    (100) primary -> . NEW IDENTIFIER LPAREN RPAREN
    (101) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (102) primary -> . lhs
    (103) primary -> . method_invocation
    (90) literal -> . INTEGERCONSTANT
    (91) literal -> . FLOATCONSTANT
    (92) literal -> . STRINGCONSTANT
    (93) literal -> . NULL
    (94) literal -> . TRUE
    (95) literal -> . FALSE

    RPAREN          shift and go to state 211
    PLUSPLUS        shift and go to state 94
    MINUSMINUS      shift and go to state 98
    IDENTIFIER      shift and go to state 125
    THIS            shift and go to state 105
    SUPER           shift and go to state 108
    LPAREN          shift and go to state 96
    NEW             shift and go to state 80
    INTEGERCONSTANT shift and go to state 102
    FLOATCONSTANT   shift and go to state 100
    STRINGCONSTANT  shift and go to state 83
    NULL            shift and go to state 81
    TRUE            shift and go to state 85
    FALSE           shift and go to state 97

    field_access                   shift and go to state 92
    primary                        shift and go to state 78
    stmt_expr                      shift and go to state 212
    literal                        shift and go to state 87
    lhs                            shift and go to state 107
    method_invocation              shift and go to state 88
    array_access                   shift and go to state 82
    assign                         shift and go to state 109

state 204

    (48) stmt -> FOR LPAREN SEMICOLON expr . SEMICOLON RPAREN stmt
    (49) stmt -> FOR LPAREN SEMICOLON expr . SEMICOLON stmt_expr RPAREN stmt
    (62) expr -> expr . OR expr
    (63) expr -> expr . AND expr
    (64) expr -> expr . EQUALS expr
    (65) expr -> expr . NOTEQUALS expr
    (66) expr -> expr . LT expr
    (67) expr -> expr . GT expr
    (68) expr -> expr . LEQ expr
    (69) expr -> expr . GEQ expr
    (70) expr -> expr . PLUS expr
    (71) expr -> expr . MINUS expr
    (72) expr -> expr . MULT expr
    (73) expr -> expr . DIV expr

    SEMICOLON       shift and go to state 213
    OR              shift and go to state 168
    AND             shift and go to state 157
    EQUALS          shift and go to state 162
    NOTEQUALS       shift and go to state 158
    LT              shift and go to state 165
    GT              shift and go to state 160
    LEQ             shift and go to state 164
    GEQ             shift and go to state 159
    PLUS            shift and go to state 166
    MINUS           shift and go to state 163
    MULT            shift and go to state 169
    DIV             shift and go to state 167


state 205

    (44) stmt -> FOR LPAREN stmt_expr SEMICOLON . SEMICOLON RPAREN stmt
    (45) stmt -> FOR LPAREN stmt_expr SEMICOLON . expr SEMICOLON RPAREN stmt
    (46) stmt -> FOR LPAREN stmt_expr SEMICOLON . SEMICOLON stmt_expr RPAREN stmt
    (47) stmt -> FOR LPAREN stmt_expr SEMICOLON . expr SEMICOLON stmt_expr RPAREN stmt
    (59) expr -> . primary
    (60) expr -> . assign
    (61) expr -> . new_array
    (62) expr -> . expr OR expr
    (63) expr -> . expr AND expr
    (64) expr -> . expr EQUALS expr
    (65) expr -> . expr NOTEQUALS expr
    (66) expr -> . expr LT expr
    (67) expr -> . expr GT expr
    (68) expr -> . expr LEQ expr
    (69) expr -> . expr GEQ expr
    (70) expr -> . expr PLUS expr
    (71) expr -> . expr MINUS expr
    (72) expr -> . expr MULT expr
    (73) expr -> . expr DIV expr
    (74) expr -> . NOT expr
    (75) expr -> . MINUS expr
    (76) expr -> . PLUS expr
    (96) primary -> . literal
    (97) primary -> . THIS
    (98) primary -> . SUPER
    (99) primary -> . LPAREN expr RPAREN
    (100) primary -> . NEW IDENTIFIER LPAREN RPAREN
    (101) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (102) primary -> . lhs
    (103) primary -> . method_invocation
    (77) assign -> . lhs ASSIGN expr
    (78) assign -> . lhs PLUSPLUS
    (79) assign -> . PLUSPLUS lhs
    (80) assign -> . lhs MINUSMINUS
    (81) assign -> . MINUSMINUS lhs
    (82) new_array -> . NEW type expr_array_helper
    (90) literal -> . INTEGERCONSTANT
    (91) literal -> . FLOATCONSTANT
    (92) literal -> . STRINGCONSTANT
    (93) literal -> . NULL
    (94) literal -> . TRUE
    (95) literal -> . FALSE
    (106) lhs -> . field_access
    (107) lhs -> . array_access
    (111) method_invocation -> . field_access LPAREN RPAREN
    (112) method_invocation -> . field_access LPAREN arguments RPAREN
    (108) field_access -> . primary DOT IDENTIFIER
    (109) field_access -> . IDENTIFIER
    (110) array_access -> . primary LSQUARE expr RSQUARE

    SEMICOLON       shift and go to state 214
    NOT             shift and go to state 130
    MINUS           shift and go to state 121
    PLUS            shift and go to state 123
    THIS            shift and go to state 105
    SUPER           shift and go to state 108
    LPAREN          shift and go to state 96
    NEW             shift and go to state 120
    PLUSPLUS        shift and go to state 94
    MINUSMINUS      shift and go to state 98
    INTEGERCONSTANT shift and go to state 102
    FLOATCONSTANT   shift and go to state 100
    STRINGCONSTANT  shift and go to state 83
    NULL            shift and go to state 81
    TRUE            shift and go to state 85
    FALSE           shift and go to state 97
    IDENTIFIER      shift and go to state 125

    new_array                      shift and go to state 118
    field_access                   shift and go to state 126
    expr                           shift and go to state 215
    primary                        shift and go to state 119
    literal                        shift and go to state 87
    array_access                   shift and go to state 82
    lhs                            shift and go to state 129
    method_invocation              shift and go to state 124
    assign                         shift and go to state 128

state 206

    (40) stmt -> IF LPAREN expr RPAREN . stmt ELSE stmt
    (41) stmt -> IF LPAREN expr RPAREN . stmt
    (40) stmt -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (41) stmt -> . IF LPAREN expr RPAREN stmt
    (42) stmt -> . WHILE LPAREN expr RPAREN stmt
    (43) stmt -> . FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt
    (44) stmt -> . FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt
    (45) stmt -> . FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt
    (46) stmt -> . FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt
    (47) stmt -> . FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (48) stmt -> . FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt
    (49) stmt -> . FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (50) stmt -> . FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt
    (51) stmt -> . block
    (52) stmt -> . var_decl
    (53) stmt -> . stmt_expr SEMICOLON
    (54) stmt -> . RETURN expr SEMICOLON
    (55) stmt -> . RETURN SEMICOLON
    (56) stmt -> . BREAK SEMICOLON
    (57) stmt -> . CONTINUE SEMICOLON
    (58) stmt -> . SEMICOLON
    (36) block -> . LCURLY empty RCURLY
    (37) block -> . LCURLY stmthelper RCURLY
    (19) var_decl -> . type variables SEMICOLON
    (88) stmt_expr -> . assign
    (89) stmt_expr -> . method_invocation
    (20) type -> . INT
    (21) type -> . FLOAT
    (22) type -> . BOOLEAN
    (23) type -> . IDENTIFIER
    (77) assign -> . lhs ASSIGN expr
    (78) assign -> . lhs PLUSPLUS
    (79) assign -> . PLUSPLUS lhs
    (80) assign -> . lhs MINUSMINUS
    (81) assign -> . MINUSMINUS lhs
    (111) method_invocation -> . field_access LPAREN RPAREN
    (112) method_invocation -> . field_access LPAREN arguments RPAREN
    (106) lhs -> . field_access
    (107) lhs -> . array_access
    (108) field_access -> . primary DOT IDENTIFIER
    (109) field_access -> . IDENTIFIER
    (110) array_access -> . primary LSQUARE expr RSQUARE
    (96) primary -> . literal
    (97) primary -> . THIS
    (98) primary -> . SUPER
    (99) primary -> . LPAREN expr RPAREN
    (100) primary -> . NEW IDENTIFIER LPAREN RPAREN
    (101) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (102) primary -> . lhs
    (103) primary -> . method_invocation
    (90) literal -> . INTEGERCONSTANT
    (91) literal -> . FLOATCONSTANT
    (92) literal -> . STRINGCONSTANT
    (93) literal -> . NULL
    (94) literal -> . TRUE
    (95) literal -> . FALSE

    IF              shift and go to state 99
    WHILE           shift and go to state 79
    FOR             shift and go to state 93
    RETURN          shift and go to state 77
    BREAK           shift and go to state 104
    CONTINUE        shift and go to state 106
    SEMICOLON       shift and go to state 84
    LCURLY          shift and go to state 63
    INT             shift and go to state 16
    FLOAT           shift and go to state 18
    BOOLEAN         shift and go to state 20
    IDENTIFIER      shift and go to state 89
    PLUSPLUS        shift and go to state 94
    MINUSMINUS      shift and go to state 98
    THIS            shift and go to state 105
    SUPER           shift and go to state 108
    LPAREN          shift and go to state 96
    NEW             shift and go to state 80
    INTEGERCONSTANT shift and go to state 102
    FLOATCONSTANT   shift and go to state 100
    STRINGCONSTANT  shift and go to state 83
    NULL            shift and go to state 81
    TRUE            shift and go to state 85
    FALSE           shift and go to state 97

    field_access                   shift and go to state 92
    primary                        shift and go to state 78
    var_decl                       shift and go to state 103
    stmt                           shift and go to state 216
    stmt_expr                      shift and go to state 86
    literal                        shift and go to state 87
    array_access                   shift and go to state 82
    lhs                            shift and go to state 107
    block                          shift and go to state 110
    method_invocation              shift and go to state 88
    type                           shift and go to state 90
    assign                         shift and go to state 109

state 207

    (83) expr_array_helper -> LSQUARE expr . RSQUARE
    (84) expr_array_helper -> LSQUARE expr . RSQUARE expr_array_helper
    (85) expr_array_helper -> LSQUARE expr . RSQUARE expr_array_helper2
    (62) expr -> expr . OR expr
    (63) expr -> expr . AND expr
    (64) expr -> expr . EQUALS expr
    (65) expr -> expr . NOTEQUALS expr
    (66) expr -> expr . LT expr
    (67) expr -> expr . GT expr
    (68) expr -> expr . LEQ expr
    (69) expr -> expr . GEQ expr
    (70) expr -> expr . PLUS expr
    (71) expr -> expr . MINUS expr
    (72) expr -> expr . MULT expr
    (73) expr -> expr . DIV expr

    RSQUARE         shift and go to state 217
    OR              shift and go to state 168
    AND             shift and go to state 157
    EQUALS          shift and go to state 162
    NOTEQUALS       shift and go to state 158
    LT              shift and go to state 165
    GT              shift and go to state 160
    LEQ             shift and go to state 164
    GEQ             shift and go to state 159
    PLUS            shift and go to state 166
    MINUS           shift and go to state 163
    MULT            shift and go to state 169
    DIV             shift and go to state 167


state 208

    (42) stmt -> WHILE LPAREN expr RPAREN stmt .

    RCURLY          reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    IF              reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    WHILE           reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    FOR             reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    RETURN          reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    BREAK           reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    CONTINUE        reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    SEMICOLON       reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    LCURLY          reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    INT             reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    FLOAT           reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    BOOLEAN         reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    IDENTIFIER      reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    PLUSPLUS        reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    MINUSMINUS      reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    THIS            reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    SUPER           reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    LPAREN          reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    NEW             reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    INTEGERCONSTANT reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    FLOATCONSTANT   reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    STRINGCONSTANT  reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    NULL            reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    TRUE            reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    FALSE           reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    ELSE            reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)


state 209

    (101) primary -> NEW IDENTIFIER LPAREN arguments RPAREN .

    DOT             reduce using rule 101 (primary -> NEW IDENTIFIER LPAREN arguments RPAREN .)
    LSQUARE         reduce using rule 101 (primary -> NEW IDENTIFIER LPAREN arguments RPAREN .)
    OR              reduce using rule 101 (primary -> NEW IDENTIFIER LPAREN arguments RPAREN .)
    AND             reduce using rule 101 (primary -> NEW IDENTIFIER LPAREN arguments RPAREN .)
    EQUALS          reduce using rule 101 (primary -> NEW IDENTIFIER LPAREN arguments RPAREN .)
    NOTEQUALS       reduce using rule 101 (primary -> NEW IDENTIFIER LPAREN arguments RPAREN .)
    LT              reduce using rule 101 (primary -> NEW IDENTIFIER LPAREN arguments RPAREN .)
    GT              reduce using rule 101 (primary -> NEW IDENTIFIER LPAREN arguments RPAREN .)
    LEQ             reduce using rule 101 (primary -> NEW IDENTIFIER LPAREN arguments RPAREN .)
    GEQ             reduce using rule 101 (primary -> NEW IDENTIFIER LPAREN arguments RPAREN .)
    PLUS            reduce using rule 101 (primary -> NEW IDENTIFIER LPAREN arguments RPAREN .)
    MINUS           reduce using rule 101 (primary -> NEW IDENTIFIER LPAREN arguments RPAREN .)
    MULT            reduce using rule 101 (primary -> NEW IDENTIFIER LPAREN arguments RPAREN .)
    DIV             reduce using rule 101 (primary -> NEW IDENTIFIER LPAREN arguments RPAREN .)
    SEMICOLON       reduce using rule 101 (primary -> NEW IDENTIFIER LPAREN arguments RPAREN .)
    RPAREN          reduce using rule 101 (primary -> NEW IDENTIFIER LPAREN arguments RPAREN .)
    RSQUARE         reduce using rule 101 (primary -> NEW IDENTIFIER LPAREN arguments RPAREN .)
    COMMA           reduce using rule 101 (primary -> NEW IDENTIFIER LPAREN arguments RPAREN .)


state 210

    (105) arguments -> arguments COMMA expr .
    (62) expr -> expr . OR expr
    (63) expr -> expr . AND expr
    (64) expr -> expr . EQUALS expr
    (65) expr -> expr . NOTEQUALS expr
    (66) expr -> expr . LT expr
    (67) expr -> expr . GT expr
    (68) expr -> expr . LEQ expr
    (69) expr -> expr . GEQ expr
    (70) expr -> expr . PLUS expr
    (71) expr -> expr . MINUS expr
    (72) expr -> expr . MULT expr
    (73) expr -> expr . DIV expr

    RPAREN          reduce using rule 105 (arguments -> arguments COMMA expr .)
    COMMA           reduce using rule 105 (arguments -> arguments COMMA expr .)
    OR              shift and go to state 168
    AND             shift and go to state 157
    EQUALS          shift and go to state 162
    NOTEQUALS       shift and go to state 158
    LT              shift and go to state 165
    GT              shift and go to state 160
    LEQ             shift and go to state 164
    GEQ             shift and go to state 159
    PLUS            shift and go to state 166
    MINUS           shift and go to state 163
    MULT            shift and go to state 169
    DIV             shift and go to state 167


state 211

    (43) stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN . stmt
    (40) stmt -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (41) stmt -> . IF LPAREN expr RPAREN stmt
    (42) stmt -> . WHILE LPAREN expr RPAREN stmt
    (43) stmt -> . FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt
    (44) stmt -> . FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt
    (45) stmt -> . FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt
    (46) stmt -> . FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt
    (47) stmt -> . FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (48) stmt -> . FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt
    (49) stmt -> . FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (50) stmt -> . FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt
    (51) stmt -> . block
    (52) stmt -> . var_decl
    (53) stmt -> . stmt_expr SEMICOLON
    (54) stmt -> . RETURN expr SEMICOLON
    (55) stmt -> . RETURN SEMICOLON
    (56) stmt -> . BREAK SEMICOLON
    (57) stmt -> . CONTINUE SEMICOLON
    (58) stmt -> . SEMICOLON
    (36) block -> . LCURLY empty RCURLY
    (37) block -> . LCURLY stmthelper RCURLY
    (19) var_decl -> . type variables SEMICOLON
    (88) stmt_expr -> . assign
    (89) stmt_expr -> . method_invocation
    (20) type -> . INT
    (21) type -> . FLOAT
    (22) type -> . BOOLEAN
    (23) type -> . IDENTIFIER
    (77) assign -> . lhs ASSIGN expr
    (78) assign -> . lhs PLUSPLUS
    (79) assign -> . PLUSPLUS lhs
    (80) assign -> . lhs MINUSMINUS
    (81) assign -> . MINUSMINUS lhs
    (111) method_invocation -> . field_access LPAREN RPAREN
    (112) method_invocation -> . field_access LPAREN arguments RPAREN
    (106) lhs -> . field_access
    (107) lhs -> . array_access
    (108) field_access -> . primary DOT IDENTIFIER
    (109) field_access -> . IDENTIFIER
    (110) array_access -> . primary LSQUARE expr RSQUARE
    (96) primary -> . literal
    (97) primary -> . THIS
    (98) primary -> . SUPER
    (99) primary -> . LPAREN expr RPAREN
    (100) primary -> . NEW IDENTIFIER LPAREN RPAREN
    (101) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (102) primary -> . lhs
    (103) primary -> . method_invocation
    (90) literal -> . INTEGERCONSTANT
    (91) literal -> . FLOATCONSTANT
    (92) literal -> . STRINGCONSTANT
    (93) literal -> . NULL
    (94) literal -> . TRUE
    (95) literal -> . FALSE

    IF              shift and go to state 99
    WHILE           shift and go to state 79
    FOR             shift and go to state 93
    RETURN          shift and go to state 77
    BREAK           shift and go to state 104
    CONTINUE        shift and go to state 106
    SEMICOLON       shift and go to state 84
    LCURLY          shift and go to state 63
    INT             shift and go to state 16
    FLOAT           shift and go to state 18
    BOOLEAN         shift and go to state 20
    IDENTIFIER      shift and go to state 89
    PLUSPLUS        shift and go to state 94
    MINUSMINUS      shift and go to state 98
    THIS            shift and go to state 105
    SUPER           shift and go to state 108
    LPAREN          shift and go to state 96
    NEW             shift and go to state 80
    INTEGERCONSTANT shift and go to state 102
    FLOATCONSTANT   shift and go to state 100
    STRINGCONSTANT  shift and go to state 83
    NULL            shift and go to state 81
    TRUE            shift and go to state 85
    FALSE           shift and go to state 97

    field_access                   shift and go to state 92
    primary                        shift and go to state 78
    var_decl                       shift and go to state 103
    stmt                           shift and go to state 218
    stmt_expr                      shift and go to state 86
    literal                        shift and go to state 87
    array_access                   shift and go to state 82
    lhs                            shift and go to state 107
    block                          shift and go to state 110
    method_invocation              shift and go to state 88
    type                           shift and go to state 90
    assign                         shift and go to state 109

state 212

    (50) stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expr . RPAREN stmt

    RPAREN          shift and go to state 219


state 213

    (48) stmt -> FOR LPAREN SEMICOLON expr SEMICOLON . RPAREN stmt
    (49) stmt -> FOR LPAREN SEMICOLON expr SEMICOLON . stmt_expr RPAREN stmt
    (88) stmt_expr -> . assign
    (89) stmt_expr -> . method_invocation
    (77) assign -> . lhs ASSIGN expr
    (78) assign -> . lhs PLUSPLUS
    (79) assign -> . PLUSPLUS lhs
    (80) assign -> . lhs MINUSMINUS
    (81) assign -> . MINUSMINUS lhs
    (111) method_invocation -> . field_access LPAREN RPAREN
    (112) method_invocation -> . field_access LPAREN arguments RPAREN
    (106) lhs -> . field_access
    (107) lhs -> . array_access
    (108) field_access -> . primary DOT IDENTIFIER
    (109) field_access -> . IDENTIFIER
    (110) array_access -> . primary LSQUARE expr RSQUARE
    (96) primary -> . literal
    (97) primary -> . THIS
    (98) primary -> . SUPER
    (99) primary -> . LPAREN expr RPAREN
    (100) primary -> . NEW IDENTIFIER LPAREN RPAREN
    (101) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (102) primary -> . lhs
    (103) primary -> . method_invocation
    (90) literal -> . INTEGERCONSTANT
    (91) literal -> . FLOATCONSTANT
    (92) literal -> . STRINGCONSTANT
    (93) literal -> . NULL
    (94) literal -> . TRUE
    (95) literal -> . FALSE

    RPAREN          shift and go to state 220
    PLUSPLUS        shift and go to state 94
    MINUSMINUS      shift and go to state 98
    IDENTIFIER      shift and go to state 125
    THIS            shift and go to state 105
    SUPER           shift and go to state 108
    LPAREN          shift and go to state 96
    NEW             shift and go to state 80
    INTEGERCONSTANT shift and go to state 102
    FLOATCONSTANT   shift and go to state 100
    STRINGCONSTANT  shift and go to state 83
    NULL            shift and go to state 81
    TRUE            shift and go to state 85
    FALSE           shift and go to state 97

    field_access                   shift and go to state 92
    primary                        shift and go to state 78
    stmt_expr                      shift and go to state 221
    literal                        shift and go to state 87
    lhs                            shift and go to state 107
    method_invocation              shift and go to state 88
    array_access                   shift and go to state 82
    assign                         shift and go to state 109

state 214

    (44) stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON . RPAREN stmt
    (46) stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON . stmt_expr RPAREN stmt
    (88) stmt_expr -> . assign
    (89) stmt_expr -> . method_invocation
    (77) assign -> . lhs ASSIGN expr
    (78) assign -> . lhs PLUSPLUS
    (79) assign -> . PLUSPLUS lhs
    (80) assign -> . lhs MINUSMINUS
    (81) assign -> . MINUSMINUS lhs
    (111) method_invocation -> . field_access LPAREN RPAREN
    (112) method_invocation -> . field_access LPAREN arguments RPAREN
    (106) lhs -> . field_access
    (107) lhs -> . array_access
    (108) field_access -> . primary DOT IDENTIFIER
    (109) field_access -> . IDENTIFIER
    (110) array_access -> . primary LSQUARE expr RSQUARE
    (96) primary -> . literal
    (97) primary -> . THIS
    (98) primary -> . SUPER
    (99) primary -> . LPAREN expr RPAREN
    (100) primary -> . NEW IDENTIFIER LPAREN RPAREN
    (101) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (102) primary -> . lhs
    (103) primary -> . method_invocation
    (90) literal -> . INTEGERCONSTANT
    (91) literal -> . FLOATCONSTANT
    (92) literal -> . STRINGCONSTANT
    (93) literal -> . NULL
    (94) literal -> . TRUE
    (95) literal -> . FALSE

    RPAREN          shift and go to state 222
    PLUSPLUS        shift and go to state 94
    MINUSMINUS      shift and go to state 98
    IDENTIFIER      shift and go to state 125
    THIS            shift and go to state 105
    SUPER           shift and go to state 108
    LPAREN          shift and go to state 96
    NEW             shift and go to state 80
    INTEGERCONSTANT shift and go to state 102
    FLOATCONSTANT   shift and go to state 100
    STRINGCONSTANT  shift and go to state 83
    NULL            shift and go to state 81
    TRUE            shift and go to state 85
    FALSE           shift and go to state 97

    field_access                   shift and go to state 92
    primary                        shift and go to state 78
    stmt_expr                      shift and go to state 223
    literal                        shift and go to state 87
    lhs                            shift and go to state 107
    method_invocation              shift and go to state 88
    array_access                   shift and go to state 82
    assign                         shift and go to state 109

state 215

    (45) stmt -> FOR LPAREN stmt_expr SEMICOLON expr . SEMICOLON RPAREN stmt
    (47) stmt -> FOR LPAREN stmt_expr SEMICOLON expr . SEMICOLON stmt_expr RPAREN stmt
    (62) expr -> expr . OR expr
    (63) expr -> expr . AND expr
    (64) expr -> expr . EQUALS expr
    (65) expr -> expr . NOTEQUALS expr
    (66) expr -> expr . LT expr
    (67) expr -> expr . GT expr
    (68) expr -> expr . LEQ expr
    (69) expr -> expr . GEQ expr
    (70) expr -> expr . PLUS expr
    (71) expr -> expr . MINUS expr
    (72) expr -> expr . MULT expr
    (73) expr -> expr . DIV expr

    SEMICOLON       shift and go to state 224
    OR              shift and go to state 168
    AND             shift and go to state 157
    EQUALS          shift and go to state 162
    NOTEQUALS       shift and go to state 158
    LT              shift and go to state 165
    GT              shift and go to state 160
    LEQ             shift and go to state 164
    GEQ             shift and go to state 159
    PLUS            shift and go to state 166
    MINUS           shift and go to state 163
    MULT            shift and go to state 169
    DIV             shift and go to state 167


state 216

    (40) stmt -> IF LPAREN expr RPAREN stmt . ELSE stmt
    (41) stmt -> IF LPAREN expr RPAREN stmt .

    ELSE            shift and go to state 225
    RCURLY          reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt .)
    IF              reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt .)
    WHILE           reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt .)
    FOR             reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt .)
    RETURN          reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt .)
    BREAK           reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt .)
    CONTINUE        reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt .)
    SEMICOLON       reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt .)
    LCURLY          reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt .)
    INT             reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt .)
    FLOAT           reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt .)
    BOOLEAN         reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt .)
    IDENTIFIER      reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt .)
    PLUSPLUS        reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt .)
    MINUSMINUS      reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt .)
    THIS            reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt .)
    SUPER           reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt .)
    LPAREN          reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt .)
    NEW             reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt .)
    INTEGERCONSTANT reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt .)
    FLOATCONSTANT   reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt .)
    STRINGCONSTANT  reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt .)
    NULL            reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt .)
    TRUE            reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt .)
    FALSE           reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt .)

  ! ELSE            [ reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt .) ]


state 217

    (83) expr_array_helper -> LSQUARE expr RSQUARE .
    (84) expr_array_helper -> LSQUARE expr RSQUARE . expr_array_helper
    (85) expr_array_helper -> LSQUARE expr RSQUARE . expr_array_helper2
    (83) expr_array_helper -> . LSQUARE expr RSQUARE
    (84) expr_array_helper -> . LSQUARE expr RSQUARE expr_array_helper
    (85) expr_array_helper -> . LSQUARE expr RSQUARE expr_array_helper2
    (86) expr_array_helper2 -> . LSQUARE RSQUARE
    (87) expr_array_helper2 -> . LSQUARE RSQUARE expr_array_helper2

    SEMICOLON       reduce using rule 83 (expr_array_helper -> LSQUARE expr RSQUARE .)
    OR              reduce using rule 83 (expr_array_helper -> LSQUARE expr RSQUARE .)
    AND             reduce using rule 83 (expr_array_helper -> LSQUARE expr RSQUARE .)
    EQUALS          reduce using rule 83 (expr_array_helper -> LSQUARE expr RSQUARE .)
    NOTEQUALS       reduce using rule 83 (expr_array_helper -> LSQUARE expr RSQUARE .)
    LT              reduce using rule 83 (expr_array_helper -> LSQUARE expr RSQUARE .)
    GT              reduce using rule 83 (expr_array_helper -> LSQUARE expr RSQUARE .)
    LEQ             reduce using rule 83 (expr_array_helper -> LSQUARE expr RSQUARE .)
    GEQ             reduce using rule 83 (expr_array_helper -> LSQUARE expr RSQUARE .)
    PLUS            reduce using rule 83 (expr_array_helper -> LSQUARE expr RSQUARE .)
    MINUS           reduce using rule 83 (expr_array_helper -> LSQUARE expr RSQUARE .)
    MULT            reduce using rule 83 (expr_array_helper -> LSQUARE expr RSQUARE .)
    DIV             reduce using rule 83 (expr_array_helper -> LSQUARE expr RSQUARE .)
    RPAREN          reduce using rule 83 (expr_array_helper -> LSQUARE expr RSQUARE .)
    RSQUARE         reduce using rule 83 (expr_array_helper -> LSQUARE expr RSQUARE .)
    COMMA           reduce using rule 83 (expr_array_helper -> LSQUARE expr RSQUARE .)
    LSQUARE         shift and go to state 227

    expr_array_helper2             shift and go to state 226
    expr_array_helper              shift and go to state 228

state 218

    (43) stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .

    RCURLY          reduce using rule 43 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    IF              reduce using rule 43 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    WHILE           reduce using rule 43 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    FOR             reduce using rule 43 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    RETURN          reduce using rule 43 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    BREAK           reduce using rule 43 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    CONTINUE        reduce using rule 43 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    SEMICOLON       reduce using rule 43 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    LCURLY          reduce using rule 43 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    INT             reduce using rule 43 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    FLOAT           reduce using rule 43 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    BOOLEAN         reduce using rule 43 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    IDENTIFIER      reduce using rule 43 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    PLUSPLUS        reduce using rule 43 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    MINUSMINUS      reduce using rule 43 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    THIS            reduce using rule 43 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    SUPER           reduce using rule 43 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    LPAREN          reduce using rule 43 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    NEW             reduce using rule 43 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    INTEGERCONSTANT reduce using rule 43 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    FLOATCONSTANT   reduce using rule 43 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    STRINGCONSTANT  reduce using rule 43 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    NULL            reduce using rule 43 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    TRUE            reduce using rule 43 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    FALSE           reduce using rule 43 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    ELSE            reduce using rule 43 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)


state 219

    (50) stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN . stmt
    (40) stmt -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (41) stmt -> . IF LPAREN expr RPAREN stmt
    (42) stmt -> . WHILE LPAREN expr RPAREN stmt
    (43) stmt -> . FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt
    (44) stmt -> . FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt
    (45) stmt -> . FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt
    (46) stmt -> . FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt
    (47) stmt -> . FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (48) stmt -> . FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt
    (49) stmt -> . FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (50) stmt -> . FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt
    (51) stmt -> . block
    (52) stmt -> . var_decl
    (53) stmt -> . stmt_expr SEMICOLON
    (54) stmt -> . RETURN expr SEMICOLON
    (55) stmt -> . RETURN SEMICOLON
    (56) stmt -> . BREAK SEMICOLON
    (57) stmt -> . CONTINUE SEMICOLON
    (58) stmt -> . SEMICOLON
    (36) block -> . LCURLY empty RCURLY
    (37) block -> . LCURLY stmthelper RCURLY
    (19) var_decl -> . type variables SEMICOLON
    (88) stmt_expr -> . assign
    (89) stmt_expr -> . method_invocation
    (20) type -> . INT
    (21) type -> . FLOAT
    (22) type -> . BOOLEAN
    (23) type -> . IDENTIFIER
    (77) assign -> . lhs ASSIGN expr
    (78) assign -> . lhs PLUSPLUS
    (79) assign -> . PLUSPLUS lhs
    (80) assign -> . lhs MINUSMINUS
    (81) assign -> . MINUSMINUS lhs
    (111) method_invocation -> . field_access LPAREN RPAREN
    (112) method_invocation -> . field_access LPAREN arguments RPAREN
    (106) lhs -> . field_access
    (107) lhs -> . array_access
    (108) field_access -> . primary DOT IDENTIFIER
    (109) field_access -> . IDENTIFIER
    (110) array_access -> . primary LSQUARE expr RSQUARE
    (96) primary -> . literal
    (97) primary -> . THIS
    (98) primary -> . SUPER
    (99) primary -> . LPAREN expr RPAREN
    (100) primary -> . NEW IDENTIFIER LPAREN RPAREN
    (101) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (102) primary -> . lhs
    (103) primary -> . method_invocation
    (90) literal -> . INTEGERCONSTANT
    (91) literal -> . FLOATCONSTANT
    (92) literal -> . STRINGCONSTANT
    (93) literal -> . NULL
    (94) literal -> . TRUE
    (95) literal -> . FALSE

    IF              shift and go to state 99
    WHILE           shift and go to state 79
    FOR             shift and go to state 93
    RETURN          shift and go to state 77
    BREAK           shift and go to state 104
    CONTINUE        shift and go to state 106
    SEMICOLON       shift and go to state 84
    LCURLY          shift and go to state 63
    INT             shift and go to state 16
    FLOAT           shift and go to state 18
    BOOLEAN         shift and go to state 20
    IDENTIFIER      shift and go to state 89
    PLUSPLUS        shift and go to state 94
    MINUSMINUS      shift and go to state 98
    THIS            shift and go to state 105
    SUPER           shift and go to state 108
    LPAREN          shift and go to state 96
    NEW             shift and go to state 80
    INTEGERCONSTANT shift and go to state 102
    FLOATCONSTANT   shift and go to state 100
    STRINGCONSTANT  shift and go to state 83
    NULL            shift and go to state 81
    TRUE            shift and go to state 85
    FALSE           shift and go to state 97

    field_access                   shift and go to state 92
    primary                        shift and go to state 78
    var_decl                       shift and go to state 103
    stmt                           shift and go to state 229
    stmt_expr                      shift and go to state 86
    literal                        shift and go to state 87
    array_access                   shift and go to state 82
    lhs                            shift and go to state 107
    block                          shift and go to state 110
    method_invocation              shift and go to state 88
    type                           shift and go to state 90
    assign                         shift and go to state 109

state 220

    (48) stmt -> FOR LPAREN SEMICOLON expr SEMICOLON RPAREN . stmt
    (40) stmt -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (41) stmt -> . IF LPAREN expr RPAREN stmt
    (42) stmt -> . WHILE LPAREN expr RPAREN stmt
    (43) stmt -> . FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt
    (44) stmt -> . FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt
    (45) stmt -> . FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt
    (46) stmt -> . FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt
    (47) stmt -> . FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (48) stmt -> . FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt
    (49) stmt -> . FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (50) stmt -> . FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt
    (51) stmt -> . block
    (52) stmt -> . var_decl
    (53) stmt -> . stmt_expr SEMICOLON
    (54) stmt -> . RETURN expr SEMICOLON
    (55) stmt -> . RETURN SEMICOLON
    (56) stmt -> . BREAK SEMICOLON
    (57) stmt -> . CONTINUE SEMICOLON
    (58) stmt -> . SEMICOLON
    (36) block -> . LCURLY empty RCURLY
    (37) block -> . LCURLY stmthelper RCURLY
    (19) var_decl -> . type variables SEMICOLON
    (88) stmt_expr -> . assign
    (89) stmt_expr -> . method_invocation
    (20) type -> . INT
    (21) type -> . FLOAT
    (22) type -> . BOOLEAN
    (23) type -> . IDENTIFIER
    (77) assign -> . lhs ASSIGN expr
    (78) assign -> . lhs PLUSPLUS
    (79) assign -> . PLUSPLUS lhs
    (80) assign -> . lhs MINUSMINUS
    (81) assign -> . MINUSMINUS lhs
    (111) method_invocation -> . field_access LPAREN RPAREN
    (112) method_invocation -> . field_access LPAREN arguments RPAREN
    (106) lhs -> . field_access
    (107) lhs -> . array_access
    (108) field_access -> . primary DOT IDENTIFIER
    (109) field_access -> . IDENTIFIER
    (110) array_access -> . primary LSQUARE expr RSQUARE
    (96) primary -> . literal
    (97) primary -> . THIS
    (98) primary -> . SUPER
    (99) primary -> . LPAREN expr RPAREN
    (100) primary -> . NEW IDENTIFIER LPAREN RPAREN
    (101) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (102) primary -> . lhs
    (103) primary -> . method_invocation
    (90) literal -> . INTEGERCONSTANT
    (91) literal -> . FLOATCONSTANT
    (92) literal -> . STRINGCONSTANT
    (93) literal -> . NULL
    (94) literal -> . TRUE
    (95) literal -> . FALSE

    IF              shift and go to state 99
    WHILE           shift and go to state 79
    FOR             shift and go to state 93
    RETURN          shift and go to state 77
    BREAK           shift and go to state 104
    CONTINUE        shift and go to state 106
    SEMICOLON       shift and go to state 84
    LCURLY          shift and go to state 63
    INT             shift and go to state 16
    FLOAT           shift and go to state 18
    BOOLEAN         shift and go to state 20
    IDENTIFIER      shift and go to state 89
    PLUSPLUS        shift and go to state 94
    MINUSMINUS      shift and go to state 98
    THIS            shift and go to state 105
    SUPER           shift and go to state 108
    LPAREN          shift and go to state 96
    NEW             shift and go to state 80
    INTEGERCONSTANT shift and go to state 102
    FLOATCONSTANT   shift and go to state 100
    STRINGCONSTANT  shift and go to state 83
    NULL            shift and go to state 81
    TRUE            shift and go to state 85
    FALSE           shift and go to state 97

    field_access                   shift and go to state 92
    primary                        shift and go to state 78
    var_decl                       shift and go to state 103
    stmt                           shift and go to state 230
    stmt_expr                      shift and go to state 86
    literal                        shift and go to state 87
    array_access                   shift and go to state 82
    lhs                            shift and go to state 107
    block                          shift and go to state 110
    method_invocation              shift and go to state 88
    type                           shift and go to state 90
    assign                         shift and go to state 109

state 221

    (49) stmt -> FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr . RPAREN stmt

    RPAREN          shift and go to state 231


state 222

    (44) stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN . stmt
    (40) stmt -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (41) stmt -> . IF LPAREN expr RPAREN stmt
    (42) stmt -> . WHILE LPAREN expr RPAREN stmt
    (43) stmt -> . FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt
    (44) stmt -> . FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt
    (45) stmt -> . FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt
    (46) stmt -> . FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt
    (47) stmt -> . FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (48) stmt -> . FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt
    (49) stmt -> . FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (50) stmt -> . FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt
    (51) stmt -> . block
    (52) stmt -> . var_decl
    (53) stmt -> . stmt_expr SEMICOLON
    (54) stmt -> . RETURN expr SEMICOLON
    (55) stmt -> . RETURN SEMICOLON
    (56) stmt -> . BREAK SEMICOLON
    (57) stmt -> . CONTINUE SEMICOLON
    (58) stmt -> . SEMICOLON
    (36) block -> . LCURLY empty RCURLY
    (37) block -> . LCURLY stmthelper RCURLY
    (19) var_decl -> . type variables SEMICOLON
    (88) stmt_expr -> . assign
    (89) stmt_expr -> . method_invocation
    (20) type -> . INT
    (21) type -> . FLOAT
    (22) type -> . BOOLEAN
    (23) type -> . IDENTIFIER
    (77) assign -> . lhs ASSIGN expr
    (78) assign -> . lhs PLUSPLUS
    (79) assign -> . PLUSPLUS lhs
    (80) assign -> . lhs MINUSMINUS
    (81) assign -> . MINUSMINUS lhs
    (111) method_invocation -> . field_access LPAREN RPAREN
    (112) method_invocation -> . field_access LPAREN arguments RPAREN
    (106) lhs -> . field_access
    (107) lhs -> . array_access
    (108) field_access -> . primary DOT IDENTIFIER
    (109) field_access -> . IDENTIFIER
    (110) array_access -> . primary LSQUARE expr RSQUARE
    (96) primary -> . literal
    (97) primary -> . THIS
    (98) primary -> . SUPER
    (99) primary -> . LPAREN expr RPAREN
    (100) primary -> . NEW IDENTIFIER LPAREN RPAREN
    (101) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (102) primary -> . lhs
    (103) primary -> . method_invocation
    (90) literal -> . INTEGERCONSTANT
    (91) literal -> . FLOATCONSTANT
    (92) literal -> . STRINGCONSTANT
    (93) literal -> . NULL
    (94) literal -> . TRUE
    (95) literal -> . FALSE

    IF              shift and go to state 99
    WHILE           shift and go to state 79
    FOR             shift and go to state 93
    RETURN          shift and go to state 77
    BREAK           shift and go to state 104
    CONTINUE        shift and go to state 106
    SEMICOLON       shift and go to state 84
    LCURLY          shift and go to state 63
    INT             shift and go to state 16
    FLOAT           shift and go to state 18
    BOOLEAN         shift and go to state 20
    IDENTIFIER      shift and go to state 89
    PLUSPLUS        shift and go to state 94
    MINUSMINUS      shift and go to state 98
    THIS            shift and go to state 105
    SUPER           shift and go to state 108
    LPAREN          shift and go to state 96
    NEW             shift and go to state 80
    INTEGERCONSTANT shift and go to state 102
    FLOATCONSTANT   shift and go to state 100
    STRINGCONSTANT  shift and go to state 83
    NULL            shift and go to state 81
    TRUE            shift and go to state 85
    FALSE           shift and go to state 97

    field_access                   shift and go to state 92
    primary                        shift and go to state 78
    var_decl                       shift and go to state 103
    stmt                           shift and go to state 232
    stmt_expr                      shift and go to state 86
    literal                        shift and go to state 87
    array_access                   shift and go to state 82
    lhs                            shift and go to state 107
    block                          shift and go to state 110
    method_invocation              shift and go to state 88
    type                           shift and go to state 90
    assign                         shift and go to state 109

state 223

    (46) stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr . RPAREN stmt

    RPAREN          shift and go to state 233


state 224

    (45) stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON . RPAREN stmt
    (47) stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON . stmt_expr RPAREN stmt
    (88) stmt_expr -> . assign
    (89) stmt_expr -> . method_invocation
    (77) assign -> . lhs ASSIGN expr
    (78) assign -> . lhs PLUSPLUS
    (79) assign -> . PLUSPLUS lhs
    (80) assign -> . lhs MINUSMINUS
    (81) assign -> . MINUSMINUS lhs
    (111) method_invocation -> . field_access LPAREN RPAREN
    (112) method_invocation -> . field_access LPAREN arguments RPAREN
    (106) lhs -> . field_access
    (107) lhs -> . array_access
    (108) field_access -> . primary DOT IDENTIFIER
    (109) field_access -> . IDENTIFIER
    (110) array_access -> . primary LSQUARE expr RSQUARE
    (96) primary -> . literal
    (97) primary -> . THIS
    (98) primary -> . SUPER
    (99) primary -> . LPAREN expr RPAREN
    (100) primary -> . NEW IDENTIFIER LPAREN RPAREN
    (101) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (102) primary -> . lhs
    (103) primary -> . method_invocation
    (90) literal -> . INTEGERCONSTANT
    (91) literal -> . FLOATCONSTANT
    (92) literal -> . STRINGCONSTANT
    (93) literal -> . NULL
    (94) literal -> . TRUE
    (95) literal -> . FALSE

    RPAREN          shift and go to state 234
    PLUSPLUS        shift and go to state 94
    MINUSMINUS      shift and go to state 98
    IDENTIFIER      shift and go to state 125
    THIS            shift and go to state 105
    SUPER           shift and go to state 108
    LPAREN          shift and go to state 96
    NEW             shift and go to state 80
    INTEGERCONSTANT shift and go to state 102
    FLOATCONSTANT   shift and go to state 100
    STRINGCONSTANT  shift and go to state 83
    NULL            shift and go to state 81
    TRUE            shift and go to state 85
    FALSE           shift and go to state 97

    field_access                   shift and go to state 92
    primary                        shift and go to state 78
    stmt_expr                      shift and go to state 235
    literal                        shift and go to state 87
    lhs                            shift and go to state 107
    method_invocation              shift and go to state 88
    array_access                   shift and go to state 82
    assign                         shift and go to state 109

state 225

    (40) stmt -> IF LPAREN expr RPAREN stmt ELSE . stmt
    (40) stmt -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (41) stmt -> . IF LPAREN expr RPAREN stmt
    (42) stmt -> . WHILE LPAREN expr RPAREN stmt
    (43) stmt -> . FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt
    (44) stmt -> . FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt
    (45) stmt -> . FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt
    (46) stmt -> . FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt
    (47) stmt -> . FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (48) stmt -> . FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt
    (49) stmt -> . FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (50) stmt -> . FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt
    (51) stmt -> . block
    (52) stmt -> . var_decl
    (53) stmt -> . stmt_expr SEMICOLON
    (54) stmt -> . RETURN expr SEMICOLON
    (55) stmt -> . RETURN SEMICOLON
    (56) stmt -> . BREAK SEMICOLON
    (57) stmt -> . CONTINUE SEMICOLON
    (58) stmt -> . SEMICOLON
    (36) block -> . LCURLY empty RCURLY
    (37) block -> . LCURLY stmthelper RCURLY
    (19) var_decl -> . type variables SEMICOLON
    (88) stmt_expr -> . assign
    (89) stmt_expr -> . method_invocation
    (20) type -> . INT
    (21) type -> . FLOAT
    (22) type -> . BOOLEAN
    (23) type -> . IDENTIFIER
    (77) assign -> . lhs ASSIGN expr
    (78) assign -> . lhs PLUSPLUS
    (79) assign -> . PLUSPLUS lhs
    (80) assign -> . lhs MINUSMINUS
    (81) assign -> . MINUSMINUS lhs
    (111) method_invocation -> . field_access LPAREN RPAREN
    (112) method_invocation -> . field_access LPAREN arguments RPAREN
    (106) lhs -> . field_access
    (107) lhs -> . array_access
    (108) field_access -> . primary DOT IDENTIFIER
    (109) field_access -> . IDENTIFIER
    (110) array_access -> . primary LSQUARE expr RSQUARE
    (96) primary -> . literal
    (97) primary -> . THIS
    (98) primary -> . SUPER
    (99) primary -> . LPAREN expr RPAREN
    (100) primary -> . NEW IDENTIFIER LPAREN RPAREN
    (101) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (102) primary -> . lhs
    (103) primary -> . method_invocation
    (90) literal -> . INTEGERCONSTANT
    (91) literal -> . FLOATCONSTANT
    (92) literal -> . STRINGCONSTANT
    (93) literal -> . NULL
    (94) literal -> . TRUE
    (95) literal -> . FALSE

    IF              shift and go to state 99
    WHILE           shift and go to state 79
    FOR             shift and go to state 93
    RETURN          shift and go to state 77
    BREAK           shift and go to state 104
    CONTINUE        shift and go to state 106
    SEMICOLON       shift and go to state 84
    LCURLY          shift and go to state 63
    INT             shift and go to state 16
    FLOAT           shift and go to state 18
    BOOLEAN         shift and go to state 20
    IDENTIFIER      shift and go to state 89
    PLUSPLUS        shift and go to state 94
    MINUSMINUS      shift and go to state 98
    THIS            shift and go to state 105
    SUPER           shift and go to state 108
    LPAREN          shift and go to state 96
    NEW             shift and go to state 80
    INTEGERCONSTANT shift and go to state 102
    FLOATCONSTANT   shift and go to state 100
    STRINGCONSTANT  shift and go to state 83
    NULL            shift and go to state 81
    TRUE            shift and go to state 85
    FALSE           shift and go to state 97

    field_access                   shift and go to state 92
    primary                        shift and go to state 78
    var_decl                       shift and go to state 103
    stmt                           shift and go to state 236
    stmt_expr                      shift and go to state 86
    literal                        shift and go to state 87
    array_access                   shift and go to state 82
    lhs                            shift and go to state 107
    block                          shift and go to state 110
    method_invocation              shift and go to state 88
    type                           shift and go to state 90
    assign                         shift and go to state 109

state 226

    (85) expr_array_helper -> LSQUARE expr RSQUARE expr_array_helper2 .

    SEMICOLON       reduce using rule 85 (expr_array_helper -> LSQUARE expr RSQUARE expr_array_helper2 .)
    OR              reduce using rule 85 (expr_array_helper -> LSQUARE expr RSQUARE expr_array_helper2 .)
    AND             reduce using rule 85 (expr_array_helper -> LSQUARE expr RSQUARE expr_array_helper2 .)
    EQUALS          reduce using rule 85 (expr_array_helper -> LSQUARE expr RSQUARE expr_array_helper2 .)
    NOTEQUALS       reduce using rule 85 (expr_array_helper -> LSQUARE expr RSQUARE expr_array_helper2 .)
    LT              reduce using rule 85 (expr_array_helper -> LSQUARE expr RSQUARE expr_array_helper2 .)
    GT              reduce using rule 85 (expr_array_helper -> LSQUARE expr RSQUARE expr_array_helper2 .)
    LEQ             reduce using rule 85 (expr_array_helper -> LSQUARE expr RSQUARE expr_array_helper2 .)
    GEQ             reduce using rule 85 (expr_array_helper -> LSQUARE expr RSQUARE expr_array_helper2 .)
    PLUS            reduce using rule 85 (expr_array_helper -> LSQUARE expr RSQUARE expr_array_helper2 .)
    MINUS           reduce using rule 85 (expr_array_helper -> LSQUARE expr RSQUARE expr_array_helper2 .)
    MULT            reduce using rule 85 (expr_array_helper -> LSQUARE expr RSQUARE expr_array_helper2 .)
    DIV             reduce using rule 85 (expr_array_helper -> LSQUARE expr RSQUARE expr_array_helper2 .)
    RPAREN          reduce using rule 85 (expr_array_helper -> LSQUARE expr RSQUARE expr_array_helper2 .)
    RSQUARE         reduce using rule 85 (expr_array_helper -> LSQUARE expr RSQUARE expr_array_helper2 .)
    COMMA           reduce using rule 85 (expr_array_helper -> LSQUARE expr RSQUARE expr_array_helper2 .)


state 227

    (83) expr_array_helper -> LSQUARE . expr RSQUARE
    (84) expr_array_helper -> LSQUARE . expr RSQUARE expr_array_helper
    (85) expr_array_helper -> LSQUARE . expr RSQUARE expr_array_helper2
    (86) expr_array_helper2 -> LSQUARE . RSQUARE
    (87) expr_array_helper2 -> LSQUARE . RSQUARE expr_array_helper2
    (59) expr -> . primary
    (60) expr -> . assign
    (61) expr -> . new_array
    (62) expr -> . expr OR expr
    (63) expr -> . expr AND expr
    (64) expr -> . expr EQUALS expr
    (65) expr -> . expr NOTEQUALS expr
    (66) expr -> . expr LT expr
    (67) expr -> . expr GT expr
    (68) expr -> . expr LEQ expr
    (69) expr -> . expr GEQ expr
    (70) expr -> . expr PLUS expr
    (71) expr -> . expr MINUS expr
    (72) expr -> . expr MULT expr
    (73) expr -> . expr DIV expr
    (74) expr -> . NOT expr
    (75) expr -> . MINUS expr
    (76) expr -> . PLUS expr
    (96) primary -> . literal
    (97) primary -> . THIS
    (98) primary -> . SUPER
    (99) primary -> . LPAREN expr RPAREN
    (100) primary -> . NEW IDENTIFIER LPAREN RPAREN
    (101) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (102) primary -> . lhs
    (103) primary -> . method_invocation
    (77) assign -> . lhs ASSIGN expr
    (78) assign -> . lhs PLUSPLUS
    (79) assign -> . PLUSPLUS lhs
    (80) assign -> . lhs MINUSMINUS
    (81) assign -> . MINUSMINUS lhs
    (82) new_array -> . NEW type expr_array_helper
    (90) literal -> . INTEGERCONSTANT
    (91) literal -> . FLOATCONSTANT
    (92) literal -> . STRINGCONSTANT
    (93) literal -> . NULL
    (94) literal -> . TRUE
    (95) literal -> . FALSE
    (106) lhs -> . field_access
    (107) lhs -> . array_access
    (111) method_invocation -> . field_access LPAREN RPAREN
    (112) method_invocation -> . field_access LPAREN arguments RPAREN
    (108) field_access -> . primary DOT IDENTIFIER
    (109) field_access -> . IDENTIFIER
    (110) array_access -> . primary LSQUARE expr RSQUARE

    RSQUARE         shift and go to state 237
    NOT             shift and go to state 130
    MINUS           shift and go to state 121
    PLUS            shift and go to state 123
    THIS            shift and go to state 105
    SUPER           shift and go to state 108
    LPAREN          shift and go to state 96
    NEW             shift and go to state 120
    PLUSPLUS        shift and go to state 94
    MINUSMINUS      shift and go to state 98
    INTEGERCONSTANT shift and go to state 102
    FLOATCONSTANT   shift and go to state 100
    STRINGCONSTANT  shift and go to state 83
    NULL            shift and go to state 81
    TRUE            shift and go to state 85
    FALSE           shift and go to state 97
    IDENTIFIER      shift and go to state 125

    new_array                      shift and go to state 118
    field_access                   shift and go to state 126
    expr                           shift and go to state 207
    primary                        shift and go to state 119
    array_access                   shift and go to state 82
    literal                        shift and go to state 87
    lhs                            shift and go to state 129
    method_invocation              shift and go to state 124
    assign                         shift and go to state 128

state 228

    (84) expr_array_helper -> LSQUARE expr RSQUARE expr_array_helper .

    SEMICOLON       reduce using rule 84 (expr_array_helper -> LSQUARE expr RSQUARE expr_array_helper .)
    OR              reduce using rule 84 (expr_array_helper -> LSQUARE expr RSQUARE expr_array_helper .)
    AND             reduce using rule 84 (expr_array_helper -> LSQUARE expr RSQUARE expr_array_helper .)
    EQUALS          reduce using rule 84 (expr_array_helper -> LSQUARE expr RSQUARE expr_array_helper .)
    NOTEQUALS       reduce using rule 84 (expr_array_helper -> LSQUARE expr RSQUARE expr_array_helper .)
    LT              reduce using rule 84 (expr_array_helper -> LSQUARE expr RSQUARE expr_array_helper .)
    GT              reduce using rule 84 (expr_array_helper -> LSQUARE expr RSQUARE expr_array_helper .)
    LEQ             reduce using rule 84 (expr_array_helper -> LSQUARE expr RSQUARE expr_array_helper .)
    GEQ             reduce using rule 84 (expr_array_helper -> LSQUARE expr RSQUARE expr_array_helper .)
    PLUS            reduce using rule 84 (expr_array_helper -> LSQUARE expr RSQUARE expr_array_helper .)
    MINUS           reduce using rule 84 (expr_array_helper -> LSQUARE expr RSQUARE expr_array_helper .)
    MULT            reduce using rule 84 (expr_array_helper -> LSQUARE expr RSQUARE expr_array_helper .)
    DIV             reduce using rule 84 (expr_array_helper -> LSQUARE expr RSQUARE expr_array_helper .)
    RPAREN          reduce using rule 84 (expr_array_helper -> LSQUARE expr RSQUARE expr_array_helper .)
    RSQUARE         reduce using rule 84 (expr_array_helper -> LSQUARE expr RSQUARE expr_array_helper .)
    COMMA           reduce using rule 84 (expr_array_helper -> LSQUARE expr RSQUARE expr_array_helper .)


state 229

    (50) stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt .

    RCURLY          reduce using rule 50 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    IF              reduce using rule 50 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    WHILE           reduce using rule 50 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    FOR             reduce using rule 50 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    RETURN          reduce using rule 50 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    BREAK           reduce using rule 50 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    CONTINUE        reduce using rule 50 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    SEMICOLON       reduce using rule 50 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    LCURLY          reduce using rule 50 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    INT             reduce using rule 50 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    FLOAT           reduce using rule 50 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    BOOLEAN         reduce using rule 50 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    IDENTIFIER      reduce using rule 50 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    PLUSPLUS        reduce using rule 50 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    MINUSMINUS      reduce using rule 50 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    THIS            reduce using rule 50 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    SUPER           reduce using rule 50 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    LPAREN          reduce using rule 50 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    NEW             reduce using rule 50 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    INTEGERCONSTANT reduce using rule 50 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    FLOATCONSTANT   reduce using rule 50 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    STRINGCONSTANT  reduce using rule 50 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    NULL            reduce using rule 50 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    TRUE            reduce using rule 50 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    FALSE           reduce using rule 50 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    ELSE            reduce using rule 50 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)


state 230

    (48) stmt -> FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt .

    RCURLY          reduce using rule 48 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt .)
    IF              reduce using rule 48 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt .)
    WHILE           reduce using rule 48 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt .)
    FOR             reduce using rule 48 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt .)
    RETURN          reduce using rule 48 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt .)
    BREAK           reduce using rule 48 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt .)
    CONTINUE        reduce using rule 48 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt .)
    SEMICOLON       reduce using rule 48 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt .)
    LCURLY          reduce using rule 48 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt .)
    INT             reduce using rule 48 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt .)
    FLOAT           reduce using rule 48 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt .)
    BOOLEAN         reduce using rule 48 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt .)
    IDENTIFIER      reduce using rule 48 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt .)
    PLUSPLUS        reduce using rule 48 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt .)
    MINUSMINUS      reduce using rule 48 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt .)
    THIS            reduce using rule 48 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt .)
    SUPER           reduce using rule 48 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt .)
    LPAREN          reduce using rule 48 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt .)
    NEW             reduce using rule 48 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt .)
    INTEGERCONSTANT reduce using rule 48 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt .)
    FLOATCONSTANT   reduce using rule 48 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt .)
    STRINGCONSTANT  reduce using rule 48 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt .)
    NULL            reduce using rule 48 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt .)
    TRUE            reduce using rule 48 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt .)
    FALSE           reduce using rule 48 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt .)
    ELSE            reduce using rule 48 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt .)


state 231

    (49) stmt -> FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN . stmt
    (40) stmt -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (41) stmt -> . IF LPAREN expr RPAREN stmt
    (42) stmt -> . WHILE LPAREN expr RPAREN stmt
    (43) stmt -> . FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt
    (44) stmt -> . FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt
    (45) stmt -> . FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt
    (46) stmt -> . FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt
    (47) stmt -> . FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (48) stmt -> . FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt
    (49) stmt -> . FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (50) stmt -> . FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt
    (51) stmt -> . block
    (52) stmt -> . var_decl
    (53) stmt -> . stmt_expr SEMICOLON
    (54) stmt -> . RETURN expr SEMICOLON
    (55) stmt -> . RETURN SEMICOLON
    (56) stmt -> . BREAK SEMICOLON
    (57) stmt -> . CONTINUE SEMICOLON
    (58) stmt -> . SEMICOLON
    (36) block -> . LCURLY empty RCURLY
    (37) block -> . LCURLY stmthelper RCURLY
    (19) var_decl -> . type variables SEMICOLON
    (88) stmt_expr -> . assign
    (89) stmt_expr -> . method_invocation
    (20) type -> . INT
    (21) type -> . FLOAT
    (22) type -> . BOOLEAN
    (23) type -> . IDENTIFIER
    (77) assign -> . lhs ASSIGN expr
    (78) assign -> . lhs PLUSPLUS
    (79) assign -> . PLUSPLUS lhs
    (80) assign -> . lhs MINUSMINUS
    (81) assign -> . MINUSMINUS lhs
    (111) method_invocation -> . field_access LPAREN RPAREN
    (112) method_invocation -> . field_access LPAREN arguments RPAREN
    (106) lhs -> . field_access
    (107) lhs -> . array_access
    (108) field_access -> . primary DOT IDENTIFIER
    (109) field_access -> . IDENTIFIER
    (110) array_access -> . primary LSQUARE expr RSQUARE
    (96) primary -> . literal
    (97) primary -> . THIS
    (98) primary -> . SUPER
    (99) primary -> . LPAREN expr RPAREN
    (100) primary -> . NEW IDENTIFIER LPAREN RPAREN
    (101) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (102) primary -> . lhs
    (103) primary -> . method_invocation
    (90) literal -> . INTEGERCONSTANT
    (91) literal -> . FLOATCONSTANT
    (92) literal -> . STRINGCONSTANT
    (93) literal -> . NULL
    (94) literal -> . TRUE
    (95) literal -> . FALSE

    IF              shift and go to state 99
    WHILE           shift and go to state 79
    FOR             shift and go to state 93
    RETURN          shift and go to state 77
    BREAK           shift and go to state 104
    CONTINUE        shift and go to state 106
    SEMICOLON       shift and go to state 84
    LCURLY          shift and go to state 63
    INT             shift and go to state 16
    FLOAT           shift and go to state 18
    BOOLEAN         shift and go to state 20
    IDENTIFIER      shift and go to state 89
    PLUSPLUS        shift and go to state 94
    MINUSMINUS      shift and go to state 98
    THIS            shift and go to state 105
    SUPER           shift and go to state 108
    LPAREN          shift and go to state 96
    NEW             shift and go to state 80
    INTEGERCONSTANT shift and go to state 102
    FLOATCONSTANT   shift and go to state 100
    STRINGCONSTANT  shift and go to state 83
    NULL            shift and go to state 81
    TRUE            shift and go to state 85
    FALSE           shift and go to state 97

    field_access                   shift and go to state 92
    primary                        shift and go to state 78
    var_decl                       shift and go to state 103
    stmt                           shift and go to state 238
    stmt_expr                      shift and go to state 86
    literal                        shift and go to state 87
    array_access                   shift and go to state 82
    lhs                            shift and go to state 107
    block                          shift and go to state 110
    method_invocation              shift and go to state 88
    type                           shift and go to state 90
    assign                         shift and go to state 109

state 232

    (44) stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt .

    RCURLY          reduce using rule 44 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt .)
    IF              reduce using rule 44 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt .)
    WHILE           reduce using rule 44 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt .)
    FOR             reduce using rule 44 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt .)
    RETURN          reduce using rule 44 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt .)
    BREAK           reduce using rule 44 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt .)
    CONTINUE        reduce using rule 44 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt .)
    SEMICOLON       reduce using rule 44 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt .)
    LCURLY          reduce using rule 44 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt .)
    INT             reduce using rule 44 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt .)
    FLOAT           reduce using rule 44 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt .)
    BOOLEAN         reduce using rule 44 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt .)
    IDENTIFIER      reduce using rule 44 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt .)
    PLUSPLUS        reduce using rule 44 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt .)
    MINUSMINUS      reduce using rule 44 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt .)
    THIS            reduce using rule 44 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt .)
    SUPER           reduce using rule 44 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt .)
    LPAREN          reduce using rule 44 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt .)
    NEW             reduce using rule 44 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt .)
    INTEGERCONSTANT reduce using rule 44 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt .)
    FLOATCONSTANT   reduce using rule 44 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt .)
    STRINGCONSTANT  reduce using rule 44 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt .)
    NULL            reduce using rule 44 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt .)
    TRUE            reduce using rule 44 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt .)
    FALSE           reduce using rule 44 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt .)
    ELSE            reduce using rule 44 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt .)


state 233

    (46) stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN . stmt
    (40) stmt -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (41) stmt -> . IF LPAREN expr RPAREN stmt
    (42) stmt -> . WHILE LPAREN expr RPAREN stmt
    (43) stmt -> . FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt
    (44) stmt -> . FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt
    (45) stmt -> . FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt
    (46) stmt -> . FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt
    (47) stmt -> . FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (48) stmt -> . FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt
    (49) stmt -> . FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (50) stmt -> . FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt
    (51) stmt -> . block
    (52) stmt -> . var_decl
    (53) stmt -> . stmt_expr SEMICOLON
    (54) stmt -> . RETURN expr SEMICOLON
    (55) stmt -> . RETURN SEMICOLON
    (56) stmt -> . BREAK SEMICOLON
    (57) stmt -> . CONTINUE SEMICOLON
    (58) stmt -> . SEMICOLON
    (36) block -> . LCURLY empty RCURLY
    (37) block -> . LCURLY stmthelper RCURLY
    (19) var_decl -> . type variables SEMICOLON
    (88) stmt_expr -> . assign
    (89) stmt_expr -> . method_invocation
    (20) type -> . INT
    (21) type -> . FLOAT
    (22) type -> . BOOLEAN
    (23) type -> . IDENTIFIER
    (77) assign -> . lhs ASSIGN expr
    (78) assign -> . lhs PLUSPLUS
    (79) assign -> . PLUSPLUS lhs
    (80) assign -> . lhs MINUSMINUS
    (81) assign -> . MINUSMINUS lhs
    (111) method_invocation -> . field_access LPAREN RPAREN
    (112) method_invocation -> . field_access LPAREN arguments RPAREN
    (106) lhs -> . field_access
    (107) lhs -> . array_access
    (108) field_access -> . primary DOT IDENTIFIER
    (109) field_access -> . IDENTIFIER
    (110) array_access -> . primary LSQUARE expr RSQUARE
    (96) primary -> . literal
    (97) primary -> . THIS
    (98) primary -> . SUPER
    (99) primary -> . LPAREN expr RPAREN
    (100) primary -> . NEW IDENTIFIER LPAREN RPAREN
    (101) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (102) primary -> . lhs
    (103) primary -> . method_invocation
    (90) literal -> . INTEGERCONSTANT
    (91) literal -> . FLOATCONSTANT
    (92) literal -> . STRINGCONSTANT
    (93) literal -> . NULL
    (94) literal -> . TRUE
    (95) literal -> . FALSE

    IF              shift and go to state 99
    WHILE           shift and go to state 79
    FOR             shift and go to state 93
    RETURN          shift and go to state 77
    BREAK           shift and go to state 104
    CONTINUE        shift and go to state 106
    SEMICOLON       shift and go to state 84
    LCURLY          shift and go to state 63
    INT             shift and go to state 16
    FLOAT           shift and go to state 18
    BOOLEAN         shift and go to state 20
    IDENTIFIER      shift and go to state 89
    PLUSPLUS        shift and go to state 94
    MINUSMINUS      shift and go to state 98
    THIS            shift and go to state 105
    SUPER           shift and go to state 108
    LPAREN          shift and go to state 96
    NEW             shift and go to state 80
    INTEGERCONSTANT shift and go to state 102
    FLOATCONSTANT   shift and go to state 100
    STRINGCONSTANT  shift and go to state 83
    NULL            shift and go to state 81
    TRUE            shift and go to state 85
    FALSE           shift and go to state 97

    field_access                   shift and go to state 92
    primary                        shift and go to state 78
    var_decl                       shift and go to state 103
    stmt                           shift and go to state 239
    stmt_expr                      shift and go to state 86
    literal                        shift and go to state 87
    array_access                   shift and go to state 82
    lhs                            shift and go to state 107
    block                          shift and go to state 110
    method_invocation              shift and go to state 88
    type                           shift and go to state 90
    assign                         shift and go to state 109

state 234

    (45) stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN . stmt
    (40) stmt -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (41) stmt -> . IF LPAREN expr RPAREN stmt
    (42) stmt -> . WHILE LPAREN expr RPAREN stmt
    (43) stmt -> . FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt
    (44) stmt -> . FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt
    (45) stmt -> . FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt
    (46) stmt -> . FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt
    (47) stmt -> . FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (48) stmt -> . FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt
    (49) stmt -> . FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (50) stmt -> . FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt
    (51) stmt -> . block
    (52) stmt -> . var_decl
    (53) stmt -> . stmt_expr SEMICOLON
    (54) stmt -> . RETURN expr SEMICOLON
    (55) stmt -> . RETURN SEMICOLON
    (56) stmt -> . BREAK SEMICOLON
    (57) stmt -> . CONTINUE SEMICOLON
    (58) stmt -> . SEMICOLON
    (36) block -> . LCURLY empty RCURLY
    (37) block -> . LCURLY stmthelper RCURLY
    (19) var_decl -> . type variables SEMICOLON
    (88) stmt_expr -> . assign
    (89) stmt_expr -> . method_invocation
    (20) type -> . INT
    (21) type -> . FLOAT
    (22) type -> . BOOLEAN
    (23) type -> . IDENTIFIER
    (77) assign -> . lhs ASSIGN expr
    (78) assign -> . lhs PLUSPLUS
    (79) assign -> . PLUSPLUS lhs
    (80) assign -> . lhs MINUSMINUS
    (81) assign -> . MINUSMINUS lhs
    (111) method_invocation -> . field_access LPAREN RPAREN
    (112) method_invocation -> . field_access LPAREN arguments RPAREN
    (106) lhs -> . field_access
    (107) lhs -> . array_access
    (108) field_access -> . primary DOT IDENTIFIER
    (109) field_access -> . IDENTIFIER
    (110) array_access -> . primary LSQUARE expr RSQUARE
    (96) primary -> . literal
    (97) primary -> . THIS
    (98) primary -> . SUPER
    (99) primary -> . LPAREN expr RPAREN
    (100) primary -> . NEW IDENTIFIER LPAREN RPAREN
    (101) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (102) primary -> . lhs
    (103) primary -> . method_invocation
    (90) literal -> . INTEGERCONSTANT
    (91) literal -> . FLOATCONSTANT
    (92) literal -> . STRINGCONSTANT
    (93) literal -> . NULL
    (94) literal -> . TRUE
    (95) literal -> . FALSE

    IF              shift and go to state 99
    WHILE           shift and go to state 79
    FOR             shift and go to state 93
    RETURN          shift and go to state 77
    BREAK           shift and go to state 104
    CONTINUE        shift and go to state 106
    SEMICOLON       shift and go to state 84
    LCURLY          shift and go to state 63
    INT             shift and go to state 16
    FLOAT           shift and go to state 18
    BOOLEAN         shift and go to state 20
    IDENTIFIER      shift and go to state 89
    PLUSPLUS        shift and go to state 94
    MINUSMINUS      shift and go to state 98
    THIS            shift and go to state 105
    SUPER           shift and go to state 108
    LPAREN          shift and go to state 96
    NEW             shift and go to state 80
    INTEGERCONSTANT shift and go to state 102
    FLOATCONSTANT   shift and go to state 100
    STRINGCONSTANT  shift and go to state 83
    NULL            shift and go to state 81
    TRUE            shift and go to state 85
    FALSE           shift and go to state 97

    field_access                   shift and go to state 92
    primary                        shift and go to state 78
    var_decl                       shift and go to state 103
    stmt                           shift and go to state 240
    stmt_expr                      shift and go to state 86
    literal                        shift and go to state 87
    array_access                   shift and go to state 82
    lhs                            shift and go to state 107
    block                          shift and go to state 110
    method_invocation              shift and go to state 88
    type                           shift and go to state 90
    assign                         shift and go to state 109

state 235

    (47) stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr . RPAREN stmt

    RPAREN          shift and go to state 241


state 236

    (40) stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .

    RCURLY          reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    IF              reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    WHILE           reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    FOR             reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    RETURN          reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    BREAK           reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    CONTINUE        reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    SEMICOLON       reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    LCURLY          reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    INT             reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    FLOAT           reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    BOOLEAN         reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    IDENTIFIER      reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    PLUSPLUS        reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    MINUSMINUS      reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    THIS            reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    SUPER           reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    LPAREN          reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    NEW             reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    INTEGERCONSTANT reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    FLOATCONSTANT   reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    STRINGCONSTANT  reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    NULL            reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    TRUE            reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    FALSE           reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    ELSE            reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)


state 237

    (86) expr_array_helper2 -> LSQUARE RSQUARE .
    (87) expr_array_helper2 -> LSQUARE RSQUARE . expr_array_helper2
    (86) expr_array_helper2 -> . LSQUARE RSQUARE
    (87) expr_array_helper2 -> . LSQUARE RSQUARE expr_array_helper2

    SEMICOLON       reduce using rule 86 (expr_array_helper2 -> LSQUARE RSQUARE .)
    OR              reduce using rule 86 (expr_array_helper2 -> LSQUARE RSQUARE .)
    AND             reduce using rule 86 (expr_array_helper2 -> LSQUARE RSQUARE .)
    EQUALS          reduce using rule 86 (expr_array_helper2 -> LSQUARE RSQUARE .)
    NOTEQUALS       reduce using rule 86 (expr_array_helper2 -> LSQUARE RSQUARE .)
    LT              reduce using rule 86 (expr_array_helper2 -> LSQUARE RSQUARE .)
    GT              reduce using rule 86 (expr_array_helper2 -> LSQUARE RSQUARE .)
    LEQ             reduce using rule 86 (expr_array_helper2 -> LSQUARE RSQUARE .)
    GEQ             reduce using rule 86 (expr_array_helper2 -> LSQUARE RSQUARE .)
    PLUS            reduce using rule 86 (expr_array_helper2 -> LSQUARE RSQUARE .)
    MINUS           reduce using rule 86 (expr_array_helper2 -> LSQUARE RSQUARE .)
    MULT            reduce using rule 86 (expr_array_helper2 -> LSQUARE RSQUARE .)
    DIV             reduce using rule 86 (expr_array_helper2 -> LSQUARE RSQUARE .)
    RPAREN          reduce using rule 86 (expr_array_helper2 -> LSQUARE RSQUARE .)
    RSQUARE         reduce using rule 86 (expr_array_helper2 -> LSQUARE RSQUARE .)
    COMMA           reduce using rule 86 (expr_array_helper2 -> LSQUARE RSQUARE .)
    LSQUARE         shift and go to state 243

    expr_array_helper2             shift and go to state 242

state 238

    (49) stmt -> FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .

    RCURLY          reduce using rule 49 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    IF              reduce using rule 49 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    WHILE           reduce using rule 49 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    FOR             reduce using rule 49 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    RETURN          reduce using rule 49 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    BREAK           reduce using rule 49 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    CONTINUE        reduce using rule 49 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    SEMICOLON       reduce using rule 49 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    LCURLY          reduce using rule 49 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    INT             reduce using rule 49 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    FLOAT           reduce using rule 49 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    BOOLEAN         reduce using rule 49 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    IDENTIFIER      reduce using rule 49 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    PLUSPLUS        reduce using rule 49 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    MINUSMINUS      reduce using rule 49 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    THIS            reduce using rule 49 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    SUPER           reduce using rule 49 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    LPAREN          reduce using rule 49 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    NEW             reduce using rule 49 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    INTEGERCONSTANT reduce using rule 49 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    FLOATCONSTANT   reduce using rule 49 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    STRINGCONSTANT  reduce using rule 49 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    NULL            reduce using rule 49 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    TRUE            reduce using rule 49 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    FALSE           reduce using rule 49 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    ELSE            reduce using rule 49 (stmt -> FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)


state 239

    (46) stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt .

    RCURLY          reduce using rule 46 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    IF              reduce using rule 46 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    WHILE           reduce using rule 46 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    FOR             reduce using rule 46 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    RETURN          reduce using rule 46 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    BREAK           reduce using rule 46 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    CONTINUE        reduce using rule 46 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    SEMICOLON       reduce using rule 46 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    LCURLY          reduce using rule 46 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    INT             reduce using rule 46 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    FLOAT           reduce using rule 46 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    BOOLEAN         reduce using rule 46 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    IDENTIFIER      reduce using rule 46 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    PLUSPLUS        reduce using rule 46 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    MINUSMINUS      reduce using rule 46 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    THIS            reduce using rule 46 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    SUPER           reduce using rule 46 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    LPAREN          reduce using rule 46 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    NEW             reduce using rule 46 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    INTEGERCONSTANT reduce using rule 46 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    FLOATCONSTANT   reduce using rule 46 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    STRINGCONSTANT  reduce using rule 46 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    NULL            reduce using rule 46 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    TRUE            reduce using rule 46 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    FALSE           reduce using rule 46 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)
    ELSE            reduce using rule 46 (stmt -> FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt .)


state 240

    (45) stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt .

    RCURLY          reduce using rule 45 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt .)
    IF              reduce using rule 45 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt .)
    WHILE           reduce using rule 45 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt .)
    FOR             reduce using rule 45 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt .)
    RETURN          reduce using rule 45 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt .)
    BREAK           reduce using rule 45 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt .)
    CONTINUE        reduce using rule 45 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt .)
    SEMICOLON       reduce using rule 45 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt .)
    LCURLY          reduce using rule 45 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt .)
    INT             reduce using rule 45 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt .)
    FLOAT           reduce using rule 45 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt .)
    BOOLEAN         reduce using rule 45 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt .)
    IDENTIFIER      reduce using rule 45 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt .)
    PLUSPLUS        reduce using rule 45 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt .)
    MINUSMINUS      reduce using rule 45 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt .)
    THIS            reduce using rule 45 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt .)
    SUPER           reduce using rule 45 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt .)
    LPAREN          reduce using rule 45 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt .)
    NEW             reduce using rule 45 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt .)
    INTEGERCONSTANT reduce using rule 45 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt .)
    FLOATCONSTANT   reduce using rule 45 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt .)
    STRINGCONSTANT  reduce using rule 45 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt .)
    NULL            reduce using rule 45 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt .)
    TRUE            reduce using rule 45 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt .)
    FALSE           reduce using rule 45 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt .)
    ELSE            reduce using rule 45 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt .)


state 241

    (47) stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN . stmt
    (40) stmt -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (41) stmt -> . IF LPAREN expr RPAREN stmt
    (42) stmt -> . WHILE LPAREN expr RPAREN stmt
    (43) stmt -> . FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt
    (44) stmt -> . FOR LPAREN stmt_expr SEMICOLON SEMICOLON RPAREN stmt
    (45) stmt -> . FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON RPAREN stmt
    (46) stmt -> . FOR LPAREN stmt_expr SEMICOLON SEMICOLON stmt_expr RPAREN stmt
    (47) stmt -> . FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (48) stmt -> . FOR LPAREN SEMICOLON expr SEMICOLON RPAREN stmt
    (49) stmt -> . FOR LPAREN SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (50) stmt -> . FOR LPAREN SEMICOLON SEMICOLON stmt_expr RPAREN stmt
    (51) stmt -> . block
    (52) stmt -> . var_decl
    (53) stmt -> . stmt_expr SEMICOLON
    (54) stmt -> . RETURN expr SEMICOLON
    (55) stmt -> . RETURN SEMICOLON
    (56) stmt -> . BREAK SEMICOLON
    (57) stmt -> . CONTINUE SEMICOLON
    (58) stmt -> . SEMICOLON
    (36) block -> . LCURLY empty RCURLY
    (37) block -> . LCURLY stmthelper RCURLY
    (19) var_decl -> . type variables SEMICOLON
    (88) stmt_expr -> . assign
    (89) stmt_expr -> . method_invocation
    (20) type -> . INT
    (21) type -> . FLOAT
    (22) type -> . BOOLEAN
    (23) type -> . IDENTIFIER
    (77) assign -> . lhs ASSIGN expr
    (78) assign -> . lhs PLUSPLUS
    (79) assign -> . PLUSPLUS lhs
    (80) assign -> . lhs MINUSMINUS
    (81) assign -> . MINUSMINUS lhs
    (111) method_invocation -> . field_access LPAREN RPAREN
    (112) method_invocation -> . field_access LPAREN arguments RPAREN
    (106) lhs -> . field_access
    (107) lhs -> . array_access
    (108) field_access -> . primary DOT IDENTIFIER
    (109) field_access -> . IDENTIFIER
    (110) array_access -> . primary LSQUARE expr RSQUARE
    (96) primary -> . literal
    (97) primary -> . THIS
    (98) primary -> . SUPER
    (99) primary -> . LPAREN expr RPAREN
    (100) primary -> . NEW IDENTIFIER LPAREN RPAREN
    (101) primary -> . NEW IDENTIFIER LPAREN arguments RPAREN
    (102) primary -> . lhs
    (103) primary -> . method_invocation
    (90) literal -> . INTEGERCONSTANT
    (91) literal -> . FLOATCONSTANT
    (92) literal -> . STRINGCONSTANT
    (93) literal -> . NULL
    (94) literal -> . TRUE
    (95) literal -> . FALSE

    IF              shift and go to state 99
    WHILE           shift and go to state 79
    FOR             shift and go to state 93
    RETURN          shift and go to state 77
    BREAK           shift and go to state 104
    CONTINUE        shift and go to state 106
    SEMICOLON       shift and go to state 84
    LCURLY          shift and go to state 63
    INT             shift and go to state 16
    FLOAT           shift and go to state 18
    BOOLEAN         shift and go to state 20
    IDENTIFIER      shift and go to state 89
    PLUSPLUS        shift and go to state 94
    MINUSMINUS      shift and go to state 98
    THIS            shift and go to state 105
    SUPER           shift and go to state 108
    LPAREN          shift and go to state 96
    NEW             shift and go to state 80
    INTEGERCONSTANT shift and go to state 102
    FLOATCONSTANT   shift and go to state 100
    STRINGCONSTANT  shift and go to state 83
    NULL            shift and go to state 81
    TRUE            shift and go to state 85
    FALSE           shift and go to state 97

    field_access                   shift and go to state 92
    primary                        shift and go to state 78
    var_decl                       shift and go to state 103
    stmt                           shift and go to state 244
    stmt_expr                      shift and go to state 86
    literal                        shift and go to state 87
    array_access                   shift and go to state 82
    lhs                            shift and go to state 107
    block                          shift and go to state 110
    method_invocation              shift and go to state 88
    type                           shift and go to state 90
    assign                         shift and go to state 109

state 242

    (87) expr_array_helper2 -> LSQUARE RSQUARE expr_array_helper2 .

    SEMICOLON       reduce using rule 87 (expr_array_helper2 -> LSQUARE RSQUARE expr_array_helper2 .)
    OR              reduce using rule 87 (expr_array_helper2 -> LSQUARE RSQUARE expr_array_helper2 .)
    AND             reduce using rule 87 (expr_array_helper2 -> LSQUARE RSQUARE expr_array_helper2 .)
    EQUALS          reduce using rule 87 (expr_array_helper2 -> LSQUARE RSQUARE expr_array_helper2 .)
    NOTEQUALS       reduce using rule 87 (expr_array_helper2 -> LSQUARE RSQUARE expr_array_helper2 .)
    LT              reduce using rule 87 (expr_array_helper2 -> LSQUARE RSQUARE expr_array_helper2 .)
    GT              reduce using rule 87 (expr_array_helper2 -> LSQUARE RSQUARE expr_array_helper2 .)
    LEQ             reduce using rule 87 (expr_array_helper2 -> LSQUARE RSQUARE expr_array_helper2 .)
    GEQ             reduce using rule 87 (expr_array_helper2 -> LSQUARE RSQUARE expr_array_helper2 .)
    PLUS            reduce using rule 87 (expr_array_helper2 -> LSQUARE RSQUARE expr_array_helper2 .)
    MINUS           reduce using rule 87 (expr_array_helper2 -> LSQUARE RSQUARE expr_array_helper2 .)
    MULT            reduce using rule 87 (expr_array_helper2 -> LSQUARE RSQUARE expr_array_helper2 .)
    DIV             reduce using rule 87 (expr_array_helper2 -> LSQUARE RSQUARE expr_array_helper2 .)
    RPAREN          reduce using rule 87 (expr_array_helper2 -> LSQUARE RSQUARE expr_array_helper2 .)
    RSQUARE         reduce using rule 87 (expr_array_helper2 -> LSQUARE RSQUARE expr_array_helper2 .)
    COMMA           reduce using rule 87 (expr_array_helper2 -> LSQUARE RSQUARE expr_array_helper2 .)


state 243

    (86) expr_array_helper2 -> LSQUARE . RSQUARE
    (87) expr_array_helper2 -> LSQUARE . RSQUARE expr_array_helper2

    RSQUARE         shift and go to state 237


state 244

    (47) stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .

    RCURLY          reduce using rule 47 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    IF              reduce using rule 47 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    WHILE           reduce using rule 47 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    FOR             reduce using rule 47 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    RETURN          reduce using rule 47 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    BREAK           reduce using rule 47 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    CONTINUE        reduce using rule 47 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    SEMICOLON       reduce using rule 47 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    LCURLY          reduce using rule 47 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    INT             reduce using rule 47 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    FLOAT           reduce using rule 47 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    BOOLEAN         reduce using rule 47 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    IDENTIFIER      reduce using rule 47 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    PLUSPLUS        reduce using rule 47 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    MINUSMINUS      reduce using rule 47 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    THIS            reduce using rule 47 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    SUPER           reduce using rule 47 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    LPAREN          reduce using rule 47 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    NEW             reduce using rule 47 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    INTEGERCONSTANT reduce using rule 47 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    FLOATCONSTANT   reduce using rule 47 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    STRINGCONSTANT  reduce using rule 47 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    NULL            reduce using rule 47 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    TRUE            reduce using rule 47 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    FALSE           reduce using rule 47 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    ELSE            reduce using rule 47 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)

